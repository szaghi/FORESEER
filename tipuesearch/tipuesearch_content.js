var tipuesearch = {"pages":[{"text":"FORESEER FORESEER FORESEER, FOrtran RiEmann SolvErs EnviRonment A KISS pure Fortran Library providing a large set of Riemann Solvers: FORESEER is a pure Fortran (KISS) library for solving Riemann problems (1D); FORESEER is Fortran 2008+ standard compliant; FORESEER is OOP designed; FORESEER is TDD developed; FORESEER is a Free, Open Source Project. A taste of FORESEER use foreseer type ( eos_compressible ) :: eos ! Equation of state. type ( conservative_compressible ) :: state_left ! Left state. type ( conservative_compressible ) :: state_right ! Right state. type ( conservative_compressible ) :: fluxes ! Conservative fluxes. class ( riemann_solver_compressible_llf ) :: riemann_solver ! Riemman Problem solver. ! air eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) ! SOD's Riemann Problem state_left = conservative_compressible ( density = 1._R8P , & energy = 1._R8P * eos % energy ( density = 1._R8P , & pressure = 1._R8P )) state_right = conservative_compressible ( density = 0.125_R8P , & energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , & pressure = 0.1_R8P )) ! solve Riemann Problem call riemann_solver % solve ( eos_left = eos , state_left = state_left , & eos_right = eos , state_right = state_right , normal = ex , & fluxes = fluxes ) ! print results print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) Issues Compiler Support What is FORESEER? | Main features | Copyrights | Download | Compilation | Documentation | References What is FORESEER? FORESEER is a modern Fortran library providing a large set of Riemann Solvers. To be completed. How to use To be written. Go to Top Main features To be written. Any feature request is welcome. Go to Top Copyrights FORESEER is a Free and Open Source Software (FOSS), it is distributed under a very permissive multi-licensing system: selectable licenses are GPLv3 , BSD2-Clause , BSD3-Clause and MIT , feel free to select the license that best matches your workflow. Anyone is interest to use, to develop or to contribute to FORESEER is welcome. More details can be found on wiki . Go to Top Download To be written. Go to Top Compilation To be written. Documentation Besides this README file the FORESEER documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" FORESEER "},{"text":"FORESEER, FOrtran RiEmann SolvErs EnviRonment. This File Depends On sourcefile~~foreseer.f90~~EfferentGraph sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseerf90EfferentGraph = svgPanZoom('#sourcefileforeseerf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer.f90~~AfferentGraph sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer Source Code foreseer.f90 Source Code !< FORESEER, FOrtran RiEmann SolvErs EnviRonment. module foreseer !< FORESEER, FOrtran RiEmann SolvErs EnviRonment. use foreseer_compressible_transformations , only : conservative_to_primitive_compressible , primitive_to_conservative_compressible use foreseer_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use foreseer_conservative_object , only : conservative_object use foreseer_eos_compressible , only : eos_compressible use foreseer_eos_object , only : eos_object use foreseer_primitive_compressible , only : primitive_compressible , primitive_compressible_pointer use foreseer_primitive_object , only : primitive_object use foreseer_riemann_solver_compressible_exact , only : riemann_solver_compressible_exact use foreseer_riemann_solver_compressible_hllc , only : riemann_solver_compressible_hllc use foreseer_riemann_solver_compressible_llf , only : riemann_solver_compressible_llf use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_compressible_pvl , only : riemann_solver_compressible_pvl use foreseer_riemann_solver_compressible_roe , only : riemann_solver_compressible_roe use foreseer_riemann_solver_object , only : riemann_solver_object implicit none private public :: conservative_to_primitive_compressible , primitive_to_conservative_compressible public :: conservative_compressible , conservative_compressible_pointer public :: conservative_object public :: eos_compressible public :: eos_object public :: primitive_compressible , primitive_compressible_pointer public :: primitive_object public :: riemann_solver_compressible_exact public :: riemann_solver_compressible_hllc public :: riemann_solver_compressible_llf public :: riemann_solver_compressible_object public :: riemann_solver_compressible_pvl public :: riemann_solver_compressible_roe public :: riemann_solver_object endmodule foreseer","tags":"","loc":"sourcefile/foreseer.f90.html","title":"foreseer.f90 – FORESEER"},{"text":"Define compressible variables transformations of FORESEER library. This File Depends On sourcefile~~foreseer_compressible_transformations.f90~~EfferentGraph sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_compressible_transformationsf90EfferentGraph = svgPanZoom('#sourcefileforeseer_compressible_transformationsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_compressible_transformations.f90~~AfferentGraph sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_compressible_transformationsf90AfferentGraph = svgPanZoom('#sourcefileforeseer_compressible_transformationsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_compressible_transformations Source Code foreseer_compressible_transformations.f90 Source Code !< Define compressible variables transformations of FORESEER library. module foreseer_compressible_transformations !< Define compressible variables transformations of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible use foreseer_primitive_compressible , only : primitive_compressible use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: conservative_to_primitive_compressible public :: primitive_to_conservative_compressible contains ! public procedures elemental function conservative_to_primitive_compressible ( conservative , eos ) result ( primitive_ ) !< Return a [[primitive_compressible]] state transforming a given [[conservative_compressible]] state. type ( conservative_compressible ), intent ( in ) :: conservative !< Conservative state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( primitive_compressible ) :: primitive_ !< Primitive state. primitive_ % density = conservative % density primitive_ % velocity = conservative % velocity () primitive_ % pressure = conservative % pressure ( eos = eos ) endfunction conservative_to_primitive_compressible elemental function primitive_to_conservative_compressible ( primitive , eos ) result ( conservative_ ) !< Return a [[conservative_compressible]] state transforming a given [[primitive_compressible]] state. type ( primitive_compressible ), intent ( in ) :: primitive !< Primitive state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( conservative_compressible ) :: conservative_ !< Conservative state. conservative_ % density = primitive % density conservative_ % momentum = primitive % momentum () conservative_ % energy = primitive % energy ( eos = eos ) endfunction primitive_to_conservative_compressible endmodule foreseer_compressible_transformations","tags":"","loc":"sourcefile/foreseer_compressible_transformations.f90.html","title":"foreseer_compressible_transformations.f90 – FORESEER"},{"text":"Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_conservative_compressible.f90~~EfferentGraph sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_conservative_compressible.f90~~AfferentGraph sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_conservative_compressiblef90AfferentGraph = svgPanZoom('#sourcefileforeseer_conservative_compressiblef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_conservative_compressible Source Code foreseer_conservative_compressible.f90 Source Code !< Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. module foreseer_conservative_compressible !< Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use penf , only : R8P , str use vecfor , only : vector implicit none private public :: conservative_compressible public :: conservative_compressible_pointer type , extends ( conservative_object ) :: conservative_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ) :: energy = 0._R8P !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. contains ! public methods procedure , pass ( self ) :: compute_fluxes_from_primitive !< Compute conservative fluxes from primitives at interface. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of conservative. procedure , pass ( self ) :: compute_fluxes !< Compute conservative fluxes. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy conservative. procedure , pass ( self ) :: initialize !< Initialize conservative. procedure , pass ( self ) :: pressure !< Return pressure value. procedure , pass ( self ) :: velocity !< Return velocity vector. procedure , pass ( lhs ) :: cons_assign_cons !< Operator `=`. procedure , pass ( lhs ) :: cons_divide_real !< Operator `cons / real`. procedure , pass ( lhs ) :: cons_multiply_real !< Operator `cons * real`. procedure , pass ( lhs ) :: cons_multiply_cons !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_cons !< Operator `real * cons`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ cons`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- cons`. endtype conservative_compressible interface conservative_compressible !< Overload [[conservative_compressible]] name with its constructor. module procedure conservative_compressible_instance endinterface contains ! public non TBP function conservative_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( conservative_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( conservative_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( conservative_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast conservative_object to conservative_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction conservative_compressible_pointer ! public methods elemental subroutine compute_fluxes_from_primitive ( self , eos , p , r , u , normal ) !< Compute conservative fluxes from primitives at interface. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: p !< Pressure at interface. real ( R8P ), intent ( in ) :: r !< Density at interface. real ( R8P ), intent ( in ) :: u !< Velocity (normal component) at interface. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. self % density = r * u self % momentum = ( r * u * u + p ) * normal self % energy = ( r * eos % energy ( density = r , pressure = p ) + r * u * u * 0.5_R8P + p ) * u endsubroutine compute_fluxes_from_primitive ! deferred methods pure function array ( self ) result ( array_ ) !< Return serialized array of conservative. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of conservative. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % momentum % x array_ ( 3 ) = self % momentum % y array_ ( 4 ) = self % momentum % z array_ ( 5 ) = self % energy endfunction array subroutine compute_fluxes ( self , eos , normal , fluxes ) !< Compute conservative fluxes. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. real ( R8P ) :: velocity_normal_ !< Velocity component parallel to given normal. select type ( fluxes ) class is ( conservative_compressible ) pressure_ = self % pressure ( eos = eos ) velocity_ = self % velocity () velocity_normal_ = velocity_ . dot . normal fluxes % density = self % momentum . dot . normal fluxes % momentum = self % density * velocity_ * velocity_normal_ + pressure_ * normal fluxes % energy = ( self % energy + pressure_ ) * velocity_normal_ endselect endsubroutine compute_fluxes pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'momentum = ' // trim ( str ( n = [ self % momentum % x , self % momentum % y , self % momentum % z ])) // NL desc = desc // prefix_ // 'energy   = ' // trim ( str ( n = self % energy )) endfunction description elemental subroutine destroy ( self ) !< Destroy conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. type ( conservative_compressible ) :: fresh !< Fresh instance of conservative object. self = fresh endsubroutine destroy subroutine initialize ( self , initial_state ) !< Initialize conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( conservative_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( conservative_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize elemental function pressure ( self , eos ) result ( pressure_ ) !< Return pressure value. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % velocity () pressure_ = ( eos % g () - 1._R8P ) * ( self % energy - 0.5_R8P * self % density * velocity_ % sq_norm ()) endfunction pressure elemental function velocity ( self ) result ( velocity_ ) !< Return velocity vector. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % momentum / self % density endfunction velocity ! operators pure subroutine cons_assign_cons ( lhs , rhs ) !< Operator `=`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( conservative_compressible ) lhs % density = rhs % density lhs % momentum = rhs % momentum lhs % energy = rhs % energy endselect endsubroutine cons_assign_cons function cons_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons / real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density / rhs operator_result % momentum = lhs % momentum / rhs operator_result % energy = lhs % energy / rhs endselect endfunction cons_divide_real function cons_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons * real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs operator_result % momentum = lhs % momentum * rhs operator_result % energy = lhs % energy * rhs endselect endfunction cons_multiply_real function real_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `real * cons`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs * rhs % density operator_result % momentum = lhs * rhs % momentum operator_result % energy = lhs * rhs % energy endselect endfunction real_multiply_cons function cons_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs % density operator_result % momentum = lhs % momentum * rhs % momentum operator_result % energy = lhs % energy * rhs % energy endselect endselect endfunction cons_multiply_cons function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density + rhs % density operator_result % momentum = lhs % momentum + rhs % momentum operator_result % energy = lhs % energy + rhs % energy endselect endselect endfunction add function positive ( self ) result ( operator_result ) !< Unary operator `+ cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = + self % density operator_result % momentum = + self % momentum operator_result % energy = + self % energy endselect endfunction positive function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density - rhs % density operator_result % momentum = lhs % momentum - rhs % momentum operator_result % energy = lhs % energy - rhs % energy endselect endselect endfunction sub function negative ( self ) result ( operator_result ) !< Unary operator `- cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = - self % density operator_result % momentum = - self % momentum operator_result % energy = - self % energy endselect endfunction negative ! private non TBP elemental function conservative_compressible_instance ( density , momentum , energy ) result ( instance ) !< Return and instance of [[conservative_compressible]]. !< !< @note This procedure is used for overloading [[conservative_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ), intent ( in ), optional :: energy !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. type ( conservative_compressible ) :: instance !< Instance of [[conservative_compressible]]. if ( present ( density )) instance % density = density if ( present ( momentum )) instance % momentum = momentum if ( present ( energy )) instance % energy = energy endfunction conservative_compressible_instance endmodule foreseer_conservative_compressible","tags":"","loc":"sourcefile/foreseer_conservative_compressible.f90.html","title":"foreseer_conservative_compressible.f90 – FORESEER"},{"text":"Define the abstract conservative state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_conservative_object.f90~~EfferentGraph sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_conservative_object.f90~~AfferentGraph sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_conservative_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_conservative_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_conservative_object Source Code foreseer_conservative_object.f90 Source Code !< Define the abstract conservative state of a Riemann Problem for FORESEER library. module foreseer_conservative_object !< Define the abstract conservative state of a Riemann Problem for FORESEER library. use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: conservative_object type , abstract :: conservative_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of conservative. procedure ( compute_fluxes_interface ), pass ( self ), deferred :: compute_fluxes !< Compute conservative fluxes. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy conservative. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize conservative. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure value. procedure ( velocity_interface ), pass ( self ), deferred :: velocity !< Return velocity vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: cons_assign_cons !< Operator `=`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_divide_real !< Operator `cons / real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: cons_multiply_cons !< Operator `*`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_multiply_real !< Operator `cons * real`. procedure ( real_operator_cons ), pass ( rhs ), deferred :: real_multiply_cons !< Operator `real * cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- cons`. ! operators generic :: assignment ( = ) => cons_assign_cons !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => cons_multiply_cons , cons_multiply_real , real_multiply_cons !< Overload `*`. generic :: operator ( / ) => cons_divide_real !< Overload `/`. endtype conservative_object abstract interface !< Abstract interfaces of deferred methods of [[conservative_object]]. pure function array_interface ( self ) result ( array_ ) !< Return serialized array of conservative. import :: conservative_object , R8P class ( conservative_object ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of conservative. endfunction array_interface subroutine compute_fluxes_interface ( self , eos , normal , fluxes ) !< Compute conservative fluxes. import :: conservative_object , eos_object , vector class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. endsubroutine compute_fluxes_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: conservative_object class ( conservative_object ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface elemental subroutine destroy_interface ( self ) !< Destroy conservative. import :: conservative_object class ( conservative_object ), intent ( inout ) :: self !< Conservative. endsubroutine destroy_interface subroutine initialize_interface ( self , initial_state ) !< Initialize conservative. import :: conservative_object class ( conservative_object ), intent ( inout ) :: self !< Conservative. class ( conservative_object ), optional , intent ( in ) :: initial_state !< Initial state. endsubroutine initialize_interface elemental function pressure_interface ( self , eos ) result ( pressure_ ) !< Return pressure value. import :: conservative_object , eos_object , R8P class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. endfunction pressure_interface elemental function velocity_interface ( self ) result ( velocity_ ) !< Return velocity vector. import :: conservative_object , vector class ( conservative_object ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. endfunction velocity_interface pure subroutine assignment_interface ( lhs , rhs ) !< Operator `=`. import :: conservative_object class ( conservative_object ), intent ( inout ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_interface function cons_operator_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons.op.real`. import :: conservative_object , R8P class ( conservative_object ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction cons_operator_real function real_operator_cons ( lhs , rhs ) result ( operator_result ) !< Operator `real.op.cons`. import :: conservative_object , R8P real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction real_operator_cons function symmetric_operator ( lhs , rhs ) result ( operator_result ) !< Symmetric operator `cons.op.cons`. import :: conservative_object class ( conservative_object ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction symmetric_operator function unary_operator ( self ) result ( operator_result ) !< Unary operator `.op.cons`. import :: conservative_object class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. endfunction unary_operator endinterface endmodule foreseer_conservative_object","tags":"","loc":"sourcefile/foreseer_conservative_object.f90.html","title":"foreseer_conservative_object.f90 – FORESEER"},{"text":"Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. This File Depends On sourcefile~~foreseer_eos_compressible.f90~~EfferentGraph sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_eos_compressible.f90~~AfferentGraph sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_eos_compressiblef90AfferentGraph = svgPanZoom('#sourcefileforeseer_eos_compressiblef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_eos_compressible Source Code foreseer_eos_compressible.f90 Source Code !< Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. module foreseer_eos_compressible !< Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foreseer_eos_object , only : eos_object use penf , only : R8P , str implicit none private public :: eos_compressible public :: eos_compressible_pointer type , extends ( eos_object ) :: eos_compressible !< Equation of state (EOS) of ideal compressible object class. real ( R8P ) :: cp_ = 0._R8P !< Specific heat at constant pressure `cp`. real ( R8P ) :: cv_ = 0._R8P !< Specific heat at constant volume `cv`. real ( R8P ) :: g_ = 0._R8P !< Specific heats ratio `gamma = cp / cv`. real ( R8P ) :: R_ = 0._R8P !< Fluid constant `R = cp - cv`. real ( R8P ) :: gm1_ = 0._R8P !< `gamma - 1`. real ( R8P ) :: gp1_ = 0._R8P !< `gamma + 1`. real ( R8P ) :: delta_ = 0._R8P !< `(gamma - 1) / 2`. real ( R8P ) :: eta_ = 0._R8P !< `2 * gamma / (gamma - 1)`. contains ! public methods procedure , pass ( self ) :: compute_derivate !< Compute derivate quantities (from `cp` and `cv`). ! deferred methods procedure , pass ( self ) :: cp !< Return specific heat at constant pressure. procedure , pass ( self ) :: cv !< Return specific heat at constant volume. procedure , pass ( self ) :: delta !< Return `(gamma - 1) / 2`. procedure , pass ( self ) :: density !< Return density. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: energy !< Return specific internal energy. procedure , pass ( lhs ) :: eos_assign_eos !< Operator `=`. procedure , pass ( self ) :: eta !< Return `2 * gamma / (gamma - 1)`. procedure , pass ( self ) :: g !< Return specific heats ratio `gamma=cp/cv`. procedure , pass ( self ) :: gm1 !< Return `gamma - 1`. procedure , pass ( self ) :: gp1 !< Return `gamma + 1`. procedure , pass ( self ) :: pressure !< Return pressure. procedure , pass ( self ) :: R !< Return fluid constant `R=cp-cv`. procedure , pass ( self ) :: speed_of_sound !< Return speed of sound. procedure , pass ( self ) :: temperature !< Return temperature. endtype eos_compressible interface eos_compressible !< Overload [[eos_compressible]] name with its constructor. module procedure eos_compressible_instance endinterface contains ! public non TBP function eos_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( eos_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( eos_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( eos_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast eos_object to eos_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction eos_compressible_pointer ! public methods elemental subroutine compute_derivate ( self ) !< Compute derivate quantities (from `cp` and `cv`). class ( eos_compressible ), intent ( inout ) :: self !< Equation of state. self % g_ = self % cp_ / self % cv_ self % R_ = self % cp_ - self % cv_ self % gm1_ = self % g_ - 1._R8P self % gp1_ = self % g_ + 1._R8P self % delta_ = ( self % g_ - 1._R8P ) * 0.5_R8P self % eta_ = 2._R8P * self % g_ / ( self % g_ - 1._R8P ) endsubroutine compute_derivate ! deferred methods elemental function cp ( self ) result ( cp_ ) !< Return specific heat at constant pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cp_ !< `cp` value. cp_ = self % cp_ endfunction cp elemental function cv ( self ) result ( cv_ ) !< Return specific heat at constant volume. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cv_ !< `cv` value. cv_ = self % cv_ endfunction cv elemental function delta ( self ) result ( delta_ ) !< Return `(gamma - 1) / 2`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: delta_ !< `(gamma - 1) / 2` value. delta_ = self % delta_ endfunction delta elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % g_ - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R_ * temperature ) endif endfunction density pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % g_ - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy elemental function eta ( self ) result ( eta_ ) !< Return `2 * gamma / (gamma - 1)`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: eta_ !< `2 * gamma / (gamma - 1)` value. eta_ = self % eta_ endfunction eta elemental function g ( self ) result ( g_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: g_ !< Specific heats ratio value. g_ = self % g_ endfunction g elemental function gm1 ( self ) result ( gm1_ ) !< Return `gamma - 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gm1_ !< `gamma - 1` value. gm1_ = self % gm1_ endfunction gm1 elemental function gp1 ( self ) result ( gp1_ ) !< Return `gamma + 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gp1_ !< `gamma + 1` value. gp1_ = self % gp1_ endfunction gp1 elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % g_ - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R_ * temperature endif endfunction pressure elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % R_ endfunction R elemental function speed_of_sound ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. speed_of_sound_ = sqrt ( self % g_ * pressure / density ) endfunction speed_of_sound elemental function temperature ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. temperature_ = 0._R8P if ( present ( density ). and . present ( pressure )) then temperature_ = pressure / ( self % R_ * density ) elseif ( present ( energy )) then temperature_ = energy / self % cv () endif endfunction temperature ! operators pure subroutine eos_assign_eos ( lhs , rhs ) !< Operator `=`. class ( eos_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( eos_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( eos_compressible ) lhs % cp_ = rhs % cp_ lhs % cv_ = rhs % cv_ lhs % g_ = rhs % g_ lhs % R_ = rhs % R_ lhs % delta_ = rhs % delta_ lhs % eta_ = rhs % eta_ lhs % gm1_ = rhs % gm1_ lhs % gp1_ = rhs % gp1_ endselect endsubroutine eos_assign_eos ! private non TBP elemental function eos_compressible_instance ( cp , cv , gam , R ) result ( instance ) !< Return and instance of [[eos_compressible]]. !< !< @note This procedure is used for overloading [[eos_compressible]] name. real ( R8P ), intent ( in ), optional :: cp !< Specific heat at constant pressure `cp` value. real ( R8P ), intent ( in ), optional :: cv !< Specific heat at constant volume `cv` value. real ( R8P ), intent ( in ), optional :: gam !< Specific heats ratio `gamma=cp/cv` value. real ( R8P ), intent ( in ), optional :: R !< Fluid constant `R=cp-cv` value. type ( eos_compressible ) :: instance !< Instance of [[eos_compressible]]. if ( present ( cp ). and . present ( cv )) then instance % cp_ = cp instance % cv_ = cv elseif ( present ( gam ). and . present ( R )) then instance % cv_ = R / ( gam - 1._R8P ) instance % cp_ = gam * instance % cv_ elseif ( present ( gam ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp / gam elseif ( present ( gam ). and . present ( cv )) then instance % cp_ = gam * cv instance % cv_ = cv elseif ( present ( R ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp - R elseif ( present ( R ). and . present ( cv )) then instance % cp_ = cv + R instance % cv_ = cv endif call instance % compute_derivate endfunction eos_compressible_instance endmodule foreseer_eos_compressible","tags":"","loc":"sourcefile/foreseer_eos_compressible.f90.html","title":"foreseer_eos_compressible.f90 – FORESEER"},{"text":"Define the abstract equation of state (EOS) for FORESEER library. Files Dependent On This One sourcefile~~foreseer_eos_object.f90~~AfferentGraph sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_eos_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_eos_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_eos_object Source Code foreseer_eos_object.f90 Source Code !< Define the abstract equation of state (EOS) for FORESEER library. module foreseer_eos_object !< Define the abstract equation of state (EOS) for FORESEER library. use penf , only : R8P implicit none private public :: eos_object type , abstract :: eos_object !< Equation of State (EOS) object class. contains ! deferred methods procedure ( scalar_interface ), pass ( self ), deferred :: cp !< Return specific heat at constant pressure. procedure ( scalar_interface ), pass ( self ), deferred :: cv !< Return specific heat at constant volume. procedure ( density_interface ), pass ( self ), deferred :: density !< Return density. procedure ( scalar_interface ), pass ( self ), deferred :: delta !< Return `(gamma - 1) / 2`. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return specific internal energy. procedure ( assignment_interface ), pass ( lhs ), deferred :: eos_assign_eos !< Operator `=`. procedure ( scalar_interface ), pass ( self ), deferred :: eta !< Return `2 * gamma / (gamma - 1)`. procedure ( scalar_interface ), pass ( self ), deferred :: g !< Return specific heats ratio `gamma=cp/cv`. procedure ( scalar_interface ), pass ( self ), deferred :: gm1 !< Return `gamma - 1`. procedure ( scalar_interface ), pass ( self ), deferred :: gp1 !< Return `gamma + 1`. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure. procedure ( scalar_interface ), pass ( self ), deferred :: R !< Return fluid constant `R=cp-cv`. procedure ( speed_of_sound_interface ), pass ( self ), deferred :: speed_of_sound !< Return speed of sound. procedure ( temperature_interface ), pass ( self ), deferred :: temperature !< Return temperature. ! operators generic :: assignment ( = ) => eos_assign_eos !< Overload `=`. endtype eos_object abstract interface !< Abstract interfaces of deferred methods of [[eos_object]]. pure subroutine assignment_interface ( lhs , rhs ) !< Operator `=`. import :: eos_object class ( eos_object ), intent ( inout ) :: lhs !< Left hand side. class ( eos_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_interface elemental function density_interface ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. endfunction density_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: eos_object class ( eos_object ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface elemental function energy_interface ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. endfunction energy_interface elemental function pressure_interface ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. endfunction pressure_interface elemental function scalar_interface ( self ) result ( scalar_ ) !< Return a scalar real value by only `self` data. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: scalar_ !< Scalar value. endfunction scalar_interface elemental function speed_of_sound_interface ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. endfunction speed_of_sound_interface elemental function temperature_interface ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. endfunction temperature_interface endinterface endmodule foreseer_eos_object","tags":"","loc":"sourcefile/foreseer_eos_object.f90.html","title":"foreseer_eos_object.f90 – FORESEER"},{"text":"Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_primitive_compressible.f90~~EfferentGraph sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_primitive_compressible.f90~~AfferentGraph sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_primitive_compressiblef90AfferentGraph = svgPanZoom('#sourcefileforeseer_primitive_compressiblef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_primitive_compressible Source Code foreseer_primitive_compressible.f90 Source Code !< Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. module foreseer_primitive_compressible !< Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foreseer_primitive_object , only : primitive_object use foreseer_eos_object , only : eos_object use penf , only : R8P , str use vecfor , only : vector implicit none private public :: primitive_compressible public :: primitive_compressible_pointer type , extends ( primitive_object ) :: primitive_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. contains ! public methods procedure , pass ( self ) :: left_eigenvectors !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. procedure , pass ( self ) :: right_eigenvectors !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of primitive. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. procedure , pass ( lhs ) :: prim_assign_prim !< Operator `=`. procedure , pass ( lhs ) :: prim_divide_real !< Operator `prim / real`. procedure , pass ( lhs ) :: prim_multiply_real !< Operator `prim * real`. procedure , pass ( lhs ) :: prim_multiply_prim !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_prim !< Operator `real * prim`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ prim`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- prim`. endtype primitive_compressible interface primitive_compressible !< Overload [[primitive_compressible]] name with its constructor. module procedure primitive_compressible_instance endinterface contains ! public non TBP function primitive_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[primitive_compressible]] pointer associated to [[primitive_object]] or its extensions until !< [[primitive_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( primitive_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( primitive_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( primitive_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast primitive_object to primitive_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction primitive_compressible_pointer ! public methods pure function left_eigenvectors ( self , eos ) result ( eig ) !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_a !< `g*p/a`. gp = eos % g () * self % pressure gp_a = gp / eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0._R8P ; eig ( 1 , 2 ) = - gp_a ; eig ( 1 , 3 ) = 1._R8P eig ( 2 , 1 ) = gp / self % density ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - 1._R8P eig ( 3 , 1 ) = 0._R8P ; eig ( 3 , 2 ) = gp_a ; eig ( 3 , 3 ) = 1._R8P endfunction left_eigenvectors pure function right_eigenvectors ( self , eos ) result ( eig ) !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_inv !< `1/(g*p)`. real ( R8P ) :: a !< Speed of sound, `sqrt(g*p/r)`. gp = eos % g () * self % pressure gp_inv = 1._R8P / gp a = eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0.5_R8P * self % density * gp_inv ; eig ( 1 , 2 ) = self % density * gp_inv ; eig ( 1 , 3 ) = eig ( 1 , 1 ) eig ( 2 , 1 ) = - 0.5_R8P * a * gp_inv ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - eig ( 2 , 1 ) eig ( 3 , 1 ) = 0.5_R8P ; eig ( 3 , 2 ) = 0._R8P ; eig ( 3 , 3 ) = eig ( 3 , 1 ) endfunction right_eigenvectors ! deferred methods pure function array ( self ) result ( array_ ) !< Return serialized array of primitive. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of primitive. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endfunction array pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endfunction description elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % g () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum ! operators pure subroutine prim_assign_prim ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure endselect endsubroutine prim_assign_prim function prim_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim / real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density / rhs operator_result % velocity = lhs % velocity / rhs operator_result % pressure = lhs % pressure / rhs endselect endfunction prim_divide_real function prim_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim * real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs operator_result % velocity = lhs % velocity * rhs operator_result % pressure = lhs % pressure * rhs endselect endfunction prim_multiply_real function real_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `real * prim`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs * rhs % density operator_result % velocity = lhs * rhs % velocity operator_result % pressure = lhs * rhs % pressure endselect endfunction real_multiply_prim function prim_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs % density operator_result % velocity = lhs % velocity * rhs % velocity operator_result % pressure = lhs % pressure * rhs % pressure endselect endselect endfunction prim_multiply_prim function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density + rhs % density operator_result % velocity = lhs % velocity + rhs % velocity operator_result % pressure = lhs % pressure + rhs % pressure endselect endselect endfunction add function positive ( self ) result ( operator_result ) !< Unary operator `+ prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = + self % density operator_result % velocity = + self % velocity operator_result % pressure = + self % pressure endselect endfunction positive function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density - rhs % density operator_result % velocity = lhs % velocity - rhs % velocity operator_result % pressure = lhs % pressure - rhs % pressure endselect endselect endfunction sub function negative ( self ) result ( operator_result ) !< Unary operator `- prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = - self % density operator_result % velocity = - self % velocity operator_result % pressure = - self % pressure endselect endfunction negative ! private non TBP elemental function primitive_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[primitive_compressible]]. !< !< @note This procedure is used for overloading [[primitive_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: velocity !< Velocity, `v`. real ( R8P ), intent ( in ), optional :: pressure !< Pressure, `p`. type ( primitive_compressible ) :: instance !< Instance of [[primitive_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure endfunction primitive_compressible_instance endmodule foreseer_primitive_compressible","tags":"","loc":"sourcefile/foreseer_primitive_compressible.f90.html","title":"foreseer_primitive_compressible.f90 – FORESEER"},{"text":"Define the abstract primitive state of a Riemann Problem for FORESEER library. This File Depends On sourcefile~~foreseer_primitive_object.f90~~EfferentGraph sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_primitive_object.f90~~AfferentGraph sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_primitive_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_primitive_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_primitive_object Source Code foreseer_primitive_object.f90 Source Code !< Define the abstract primitive state of a Riemann Problem for FORESEER library. module foreseer_primitive_object !< Define the abstract primitive state of a Riemann Problem for FORESEER library. use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: primitive_object type , abstract :: primitive_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of primitive. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy primitive. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return energy value. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize primitive. procedure ( momentum_interface ), pass ( self ), deferred :: momentum !< Return momentum vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: prim_assign_prim !< Operator `=`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_divide_real !< Operator `prim / real`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_multiply_real !< Operator `prim * real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: prim_multiply_prim !< Operator `*`. procedure ( real_operator_prim ), pass ( rhs ), deferred :: real_multiply_prim !< Operator `real * prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- prim`. ! operators generic :: assignment ( = ) => prim_assign_prim !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => prim_multiply_prim , prim_multiply_real , real_multiply_prim !< Overload `*`. generic :: operator ( / ) => prim_divide_real !< Overload `/`. endtype primitive_object abstract interface !< Abstract interfaces of deferred methods of [[primitive_object]]. pure function array_interface ( self ) result ( array_ ) !< Return serialized array of primitive. import :: primitive_object , R8P class ( primitive_object ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of primitive. endfunction array_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: primitive_object class ( primitive_object ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface elemental subroutine destroy_interface ( self ) !< Destroy primitive. import :: primitive_object class ( primitive_object ), intent ( inout ) :: self !< Primitive. endsubroutine destroy_interface elemental function energy_interface ( self , eos ) result ( energy_ ) !< Return energy value. import :: primitive_object , eos_object , R8P class ( primitive_object ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. endfunction energy_interface subroutine initialize_interface ( self , initial_state ) !< Initialize primitive. import :: primitive_object class ( primitive_object ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), optional , intent ( in ) :: initial_state !< Initial state. endsubroutine initialize_interface elemental function momentum_interface ( self ) result ( momentum_ ) !< Return momentum vector. import :: primitive_object , vector class ( primitive_object ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. endfunction momentum_interface pure subroutine assignment_interface ( lhs , rhs ) !< Operator `=`. import :: primitive_object class ( primitive_object ), intent ( inout ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_interface function prim_operator_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim.op.real`. import :: primitive_object , R8P class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction prim_operator_real function real_operator_prim ( lhs , rhs ) result ( operator_result ) !< Operator `real * prim`. import :: primitive_object , R8P real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction real_operator_prim function symmetric_operator ( lhs , rhs ) result ( operator_result ) !< Symmetric operator `prim.op.prim`. import :: primitive_object class ( primitive_object ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction symmetric_operator function unary_operator ( self ) result ( operator_result ) !< Unary operator `.op.prim`. import :: primitive_object class ( primitive_object ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. endfunction unary_operator endinterface endmodule foreseer_primitive_object","tags":"","loc":"sourcefile/foreseer_primitive_object.f90.html","title":"foreseer_primitive_object.f90 – FORESEER"},{"text":"Define the exact (Newton-iterative) Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_exact.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 var pansourcefileforeseer_riemann_solver_compressible_exactf90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_exactf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_exact.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_riemann_solver_compressible_exactf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_exactf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_exact Source Code foreseer_riemann_solver_compressible_exact.F90 Source Code !< Define the exact (Newton-iterative) Riemann solver of FORESEER library. module foreseer_riemann_solver_compressible_exact !< Define the exact (Newton-iterative) Riemann solver of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_compressible_pvl , only : riemann_solver_compressible_pvl use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : cton , R8P use vecfor , only : vector implicit none private public :: riemann_solver_compressible_exact type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_exact !< Exact (Newton-iterative) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. real ( R8P ) :: tolerance = 1.e-10_R8P !< Tolerance on Newton convergence. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_exact contains ! public deferred methods pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. class ( riemann_solver_compressible_exact ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. type ( conservative_compressible ) :: fluxes !< Fluxes of the Riemann Problem solution. call self % solve ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal , & fluxes = fluxes ) waves ( 1 ) = self % S_1 waves ( 2 ) = self % S_2 waves ( 3 ) = self % u23 waves ( 4 ) = self % S_3 waves ( 5 ) = self % S_4 endsubroutine compute_waves subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_exact ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local variable. config_ = '1.e-10' ; if ( present ( config )) config_ = config self % tolerance = cton ( config_ , knd = 1._R8P ) endsubroutine initialize pure subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_exact ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: dum , alfa , beta !< Dummies coefficients. real ( R8P ) :: p_2 , p_3 !< Pessure of state 2 and 3. real ( R8P ) :: dp2 , dp3 !< Derivate of pessure (dp/du) of state 2 and 3. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) ! initiale u23 speed if ( self % p_1 < self % p_4 ) then dum = 0.5_R8P * self % eos_4 % gm1 () / self % eos_4 % g () ! (gamma - 1) / (gamma * 2) else dum = 0.5_R8P * self % eos_1 % gm1 () / self % eos_1 % g () ! (gamma - 1) / (gamma * 2) endif alfa = ( self % p_1 / self % p_4 ) ** dum beta = alfa * self % eos_1 % delta () / self % a_1 + self % eos_4 % delta () / self % a_4 self % u23 = ( alfa - 1.0_R8P ) / beta + & 0.5_R8P * ( self % u_1 + self % u_4 ) + & 0.5_R8P * ( self % u_1 - self % u_4 ) * ( alfa * self % eos_1 % delta () / self % a_1 - self % eos_4 % delta () / self % a_4 ) / beta Newton : do call self % compute_states23_from_u23 ( p_2 = p_2 , p_3 = p_3 ) ! evaluate the Newton-Rapson convergence if ( abs ( 1.0_R8P - ( p_2 / p_3 )) >= self % tolerance ) then dp2 = - 1._R8P * self % eos_1 % g () * p_2 / self % a_2 dp3 = 1._R8P * self % eos_4 % g () * p_3 / self % a_3 self % u23 = self % u23 - (( p_2 - p_3 ) / ( dp2 - dp3 )) else self % p23 = p_2 ! p_2 ~= p_3 exit Newton endif enddo Newton call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve endmodule foreseer_riemann_solver_compressible_exact","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_exact.f90.html","title":"foreseer_riemann_solver_compressible_exact.F90 – FORESEER"},{"text":"Define the HLLC Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_hllc.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 var pansourcefileforeseer_riemann_solver_compressible_hllcf90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_hllcf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_hllc.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_riemann_solver_compressible_hllcf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_hllcf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_hllc Source Code foreseer_riemann_solver_compressible_hllc.F90 Source Code !< Define the HLLC Riemann solver of FORESEER library. module foreseer_riemann_solver_compressible_hllc !< Define the HLLC Riemann solver of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_compressible_pvl , only : riemann_solver_compressible_pvl use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : R8P use vecfor , only : vector implicit none private public :: riemann_solver_compressible_hllc type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_hllc !< HLLC (Harten, Lax, Van Leer, Toro) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_hllc contains ! public deferred methods pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_hllc ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_hllc ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local variable. config_ = 'up23' ; if ( present ( config )) config_ = config call self % solver_pvl % initialize ( config = config_ ) endsubroutine initialize subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_hllc ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ) :: state23 !< Intermediate states. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: u23 !< Maximum wave speed estimation. state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) associate ( r_1 => self % solver_pvl % r_1 , u_1 => self % solver_pvl % u_1 , p_1 => self % solver_pvl % p_1 , g_1 => self % solver_pvl % eos_1 % g (), & r_4 => self % solver_pvl % r_4 , u_4 => self % solver_pvl % u_4 , p_4 => self % solver_pvl % p_4 , g_4 => self % solver_pvl % eos_4 % g (), & s_1 => self % solver_pvl % s_1 , s_4 => self % solver_pvl % s_4 , & E_1 => state_left_ % energy / state_left_ % density , E_4 => state_right_ % energy / state_right_ % density ) u23 = ( r_4 * u_4 * ( s_4 - u_4 ) - r_1 * u_1 * ( s_1 - u_1 ) + p_1 - p_4 ) / & ( r_4 * ( s_4 - u_4 ) - r_1 * ( s_1 - u_1 )) select case ( minloc ([ - s_1 , s_1 * u23 , u23 * s_4 , s_4 ], dim = 1 )) case ( 1 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes ) case ( 2 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes ) state23 % density = r_1 * ( s_1 - u_1 ) / ( s_1 - u23 ) state23 % momentum = state23 % density * u23 * normal state23 % energy = state23 % density * ( E_1 + ( u23 - u_1 ) * ( u23 + p_1 / ( r_1 * ( s_1 - u_1 )))) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + s_1 * ( state23 - state_left_ ) endselect case ( 3 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes ) state23 % density = r_4 * ( s_4 - u_4 ) / ( s_4 - u23 ) state23 % momentum = state23 % density * u23 * normal state23 % energy = state23 % density * ( E_4 + ( u23 - u_4 ) * ( u23 + p_4 / ( r_4 * ( s_4 - u_4 )))) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + s_4 * ( state23 - state_right_ ) endselect case ( 4 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes ) endselect endassociate endsubroutine solve endmodule foreseer_riemann_solver_compressible_hllc","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_hllc.f90.html","title":"foreseer_riemann_solver_compressible_hllc.F90 – FORESEER"},{"text":"Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_llf.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 var pansourcefileforeseer_riemann_solver_compressible_llff90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_llff90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_llf.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_riemann_solver_compressible_llff90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_llff90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_llf Source Code foreseer_riemann_solver_compressible_llf.F90 Source Code !< Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. module foreseer_riemann_solver_compressible_llf !< Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_compressible_pvl , only : riemann_solver_compressible_pvl use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : R8P use vecfor , only : vector implicit none private public :: riemann_solver_compressible_llf type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf !< Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_llf contains ! public deferred methods pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local variable. config_ = 'up23' ; if ( present ( config )) config_ = config call self % solver_pvl % initialize ( config = config_ ) endsubroutine initialize subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( conservative_compressible ) :: fluxes_left !< Fluxes of left state. type ( conservative_compressible ) :: fluxes_right !< Fluxes of right state. type ( conservative_compressible ) :: fluxes_ !< Fluxes, local variable. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: lmax !< Maximum wave speed estimation. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) lmax = maxval ( abs ( waves )) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) select type ( fluxes ) type is ( conservative_compressible ) #ifdef __GFORTRAN__ fluxes = 0.5_R8P * ( fluxes_left + fluxes_right - ( lmax * ( state_right_ - state_left_ ))) #else ! Intel Fortran has issue in resolving the equation with multiple operators... it must be split fluxes_ = state_right_ - state_left_ fluxes_ = lmax * fluxes_ fluxes = fluxes_left + fluxes_right fluxes = fluxes - fluxes_ fluxes = 0.5_R8P * fluxes #endif endselect endsubroutine solve endmodule foreseer_riemann_solver_compressible_llf","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_llf.f90.html","title":"foreseer_riemann_solver_compressible_llf.F90 – FORESEER"},{"text":"Define the Riemann solver for ideal compressible fluid for FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_object.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 var pansourcefileforeseer_riemann_solver_compressible_objectf90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_object.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_riemann_solver_compressible_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_object Source Code foreseer_riemann_solver_compressible_object.f90 Source Code !< Define the Riemann solver for ideal compressible fluid for FORESEER library. module foreseer_riemann_solver_compressible_object !< Define the Riemann solver for ideal compressible fluid for FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible use foreseer_conservative_object , only : conservative_object use foreseer_eos_compressible , only : eos_compressible use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : R8P , str , ZeroR8 use vecfor , only : vector implicit none private public :: riemann_solver_compressible_object type , extends ( riemann_solver_object ), abstract :: riemann_solver_compressible_object !< Riemann solver for ideal compressible fluid object class. !< !< The ideal compressible fluid generates a 3-waves pattern: 2 genuinely non-linear acoustic waves and 1 !< linear-degener contact discontinuity. !< !<``` !<   t &#94;                                . !<     |     S1 _       S2 _            .      _ S=u23   _ S3       _ S4 !<     |       |\\_        |\\_           .      /|      __/|       __/| !<     |          \\__        \\_     U2  .     /  U3  _/       ___/ !<     |             \\___      \\_       .    /    __/     ___/ !<     |                 \\____   \\_     .   /   _/    ___/ !<     |                      \\___ \\_   .  / __/  ___/ !<     |          UL=U1           \\__\\_ . /_/____/          UR=U4 !<     |                              \\\\./// !<  ---+--------------------------------o---------------------------------> !<     |                                xo                                x !<``` type ( eos_compressible ) :: eos_1 !< Equation of state 1. real ( R8P ) :: r_1 = 0._R8P !< Density of state 1. real ( R8P ) :: u_1 = 0._R8P !< Velocity (normal) of state 1. real ( R8P ) :: p_1 = 0._R8P !< Pressure of state 1. real ( R8P ) :: a_1 = 0._R8P !< Speed of sound of state 1. type ( eos_compressible ) :: eos_4 !< Equation of state 4. real ( R8P ) :: r_4 = 0._R8P !< Density of state 4. real ( R8P ) :: u_4 = 0._R8P !< Velocity (normal) of state 4. real ( R8P ) :: p_4 = 0._R8P !< Pressure of state 4. real ( R8P ) :: a_4 = 0._R8P !< Speed of sound of state 4. real ( R8P ) :: u23 = 0._R8P !< Velocity (normal) of intermediate states. real ( R8P ) :: p23 = 0._R8P !< Pressure of intermediate states. real ( R8P ) :: r_2 = 0._R8P !< Density of state 2. real ( R8P ) :: a_2 = 0._R8P !< Speed of sound of state 2. real ( R8P ) :: r_3 = 0._R8P !< Density of state 3. real ( R8P ) :: a_3 = 0._R8P !< Speed of sound of state 3. real ( R8P ) :: s_1 = 0._R8P !< Left-front of left wave. real ( R8P ) :: s_2 = 0._R8P !< Right-front of left wave. real ( R8P ) :: s_3 = 0._R8P !< Left-front of right wave. real ( R8P ) :: s_4 = 0._R8P !< Right-front of right wave. contains ! deferred methods procedure , pass ( self ) :: description !< Return pretty-printed object description. ! public methods procedure , pass ( self ) :: compute_fluxes !< Compute fluxes at interface `x=xo`. procedure , pass ( self ) :: compute_states23_from_u23 !< Compute interstates 2 and 3 given veloctiy `S=u23`. procedure , pass ( self ) :: set_states14 !< Set states 1 and 4. endtype riemann_solver_compressible_object contains ! deferred methods pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'r_1 = ' // trim ( str ( n = self % r_1 )) // NL desc = desc // prefix_ // 'u_1 = ' // trim ( str ( n = self % u_1 )) // NL desc = desc // prefix_ // 'p_1 = ' // trim ( str ( n = self % p_1 )) // NL desc = desc // prefix_ // 'a_1 = ' // trim ( str ( n = self % a_1 )) // NL desc = desc // prefix_ // 'r_4 = ' // trim ( str ( n = self % r_4 )) // NL desc = desc // prefix_ // 'u_4 = ' // trim ( str ( n = self % u_4 )) // NL desc = desc // prefix_ // 'p_4 = ' // trim ( str ( n = self % p_4 )) // NL desc = desc // prefix_ // 'a_4 = ' // trim ( str ( n = self % a_4 )) // NL desc = desc // prefix_ // 'u23 = ' // trim ( str ( n = self % u23 )) // NL desc = desc // prefix_ // 'p23 = ' // trim ( str ( n = self % p23 )) // NL desc = desc // prefix_ // 'r_2 = ' // trim ( str ( n = self % r_2 )) // NL desc = desc // prefix_ // 'a_2 = ' // trim ( str ( n = self % a_2 )) // NL desc = desc // prefix_ // 'r_3 = ' // trim ( str ( n = self % r_3 )) // NL desc = desc // prefix_ // 'a_3 = ' // trim ( str ( n = self % a_3 )) // NL desc = desc // prefix_ // 's_1 = ' // trim ( str ( n = self % s_1 )) // NL desc = desc // prefix_ // 's_2 = ' // trim ( str ( n = self % s_2 )) // NL desc = desc // prefix_ // 's_3 = ' // trim ( str ( n = self % s_3 )) // NL desc = desc // prefix_ // 's_4 = ' // trim ( str ( n = self % s_4 )) endfunction description ! public methods elemental subroutine compute_fluxes ( self , eos_left , eos_right , normal , fluxes ) !< Compute fluxes at interface `x=xo`. !< !< Sampling the pattern, the interface states are computed. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes at interface `x=xo`. real ( R8P ) :: a !< Speed of sound at interface `x=xo`. real ( R8P ) :: p !< Pressure at interface `x=xo`. real ( R8P ) :: r !< Desnity at interface `x=xo`. call fluxes % destroy associate ( s1 => self % s_1 , s2 => self % s_2 , u23 => self % u23 , s3 => self % s_3 , s4 => self % s_4 , & g1 => self % eos_1 % g (), d1 => self % eos_1 % delta (), e1 => self % eos_1 % eta (), & g4 => self % eos_4 % g (), d4 => self % eos_4 % delta (), e4 => self % eos_4 % eta (), & p1 => self % p_1 , r1 => self % r_1 , u1 => self % u_1 , a1 => self % a_1 , & p4 => self % p_4 , r4 => self % r_4 , u4 => self % u_4 , a4 => self % a_4 , & p23 => self % p23 , r2 => self % r_2 , r3 => self % r_3 ) select type ( fluxes ) class is ( conservative_compressible ) select case ( minloc ([ - s1 , s1 * s2 , s2 * u23 , u23 * s3 , s3 * s4 , s4 ], dim = 1 )) case ( 1 ) ! left supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p1 , r = r1 , u = u1 , normal = normal ) case ( 2 ) ! left transonic a = ( a1 + u1 * d1 ) / ( 1._R8P + d1 ) p = p1 * ( a / a1 ) ** e1 r = eos_left % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p , r = r , u = a , normal = normal ) case ( 3 ) ! left subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p23 , r = r2 , u = u23 , normal = normal ) case ( 4 ) ! right subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p23 , r = r3 , u = u23 , normal = normal ) case ( 5 ) ! right transonic a = ( a4 - u4 * d4 ) / ( 1._R8P + d4 ) p = p4 * ( a / a4 ) ** e4 r = eos_right % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p , r = r , u =- a , normal = normal ) case ( 6 ) ! right supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p4 , r = r4 , u = u4 , normal = normal ) endselect endselect endassociate endsubroutine compute_fluxes elemental subroutine compute_states23_from_u23 ( self , p_2 , p_3 ) !< Compute interstates 2 and 3 given (an approximation of) veloctiy `S=u23`. !< !< @Note the pressure of interstates, that should be equal, are returned into separate arguments for allowing a *convergence !< checking*, namely if the approximation of `u23` is exact the output is `p_2=p_3=p23`. class ( riemann_solver_compressible_object ), intent ( inout ) :: self !< Solver. real ( R8P ), intent ( out ) :: p_2 !< Pressure of state 2. real ( R8P ), intent ( out ) :: p_3 !< Pressure of state 3. ! left wave if ( abs ( self % u23 - self % u_1 ) <= ZeroR8 ) then call compute_post_rarefaction ( eos = self % eos_1 , sgn =- 1._R8P , & u0 = self % u_1 , p0 = self % p_1 , a0 = self % a_1 , ux = self % u23 , & rx = self % r_2 , px = p_2 , ax = self % a_2 , s0 = self % S_1 , sx = self % S_2 ) else if ( self % u23 < self % u_1 ) then call compute_post_shock ( eos = self % eos_1 , sgn =- 1._R8P , & u0 = self % u_1 , p0 = self % p_1 , a0 = self % a_1 , ux = self % u23 , & rx = self % r_2 , px = p_2 , ax = self % a_2 , ss = self % S_1 ) self % S_2 = self % S_1 else call compute_post_rarefaction ( eos = self % eos_1 , sgn =- 1._R8P , & u0 = self % u_1 , p0 = self % p_1 , a0 = self % a_1 , ux = self % u23 , & rx = self % r_2 , px = p_2 , ax = self % a_2 , s0 = self % S_1 , sx = self % S_2 ) endif endif ! right wave if ( abs ( self % u23 - self % u_4 ) <= ZeroR8 ) then call compute_post_rarefaction ( eos = self % eos_4 , sgn = 1._R8P , & u0 = self % u_4 , p0 = self % p_4 , a0 = self % a_4 , ux = self % u23 , & rx = self % r_3 , px = p_3 , ax = self % a_3 , s0 = self % S_4 , sx = self % S_3 ) else if ( self % u23 > self % u_4 ) then call compute_post_shock ( eos = self % eos_4 , sgn = 1._R8P , & u0 = self % u_4 , p0 = self % p_4 , a0 = self % a_4 , ux = self % u23 , & rx = self % r_3 , px = p_3 , ax = self % a_3 , ss = self % S_4 ) self % S_3 = self % S_4 else call compute_post_rarefaction ( eos = self % eos_4 , sgn = 1._R8P , & u0 = self % u_4 , p0 = self % p_4 , a0 = self % a_4 , ux = self % u23 , & rx = self % r_3 , px = p_3 , ax = self % a_3 , s0 = self % S_4 , sx = self % S_3 ) endif endif endsubroutine compute_states23_from_u23 elemental subroutine set_states14 ( self , eos_left , state_left , eos_right , state_right , normal ) !< Set states 1 and 4. class ( riemann_solver_compressible_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. select type ( eos_left ) class is ( eos_compressible ) self % eos_1 = eos_left endselect select type ( state_left ) class is ( conservative_compressible ) self % u_1 = state_left % velocity (). dot . normal self % p_1 = state_left % pressure ( eos = eos_left ) self % r_1 = state_left % density self % a_1 = eos_left % speed_of_sound ( density = state_left % density , pressure = self % p_1 ) endselect select type ( eos_right ) class is ( eos_compressible ) self % eos_4 = eos_right endselect select type ( state_right ) class is ( conservative_compressible ) self % u_4 = state_right % velocity (). dot . normal self % p_4 = state_right % pressure ( eos = eos_right ) self % r_4 = state_right % density self % a_4 = eos_right % speed_of_sound ( density = state_right % density , pressure = self % p_4 ) endselect endsubroutine set_states14 ! non TBP elemental subroutine compute_post_rarefaction ( eos , sgn , u0 , p0 , a0 , ux , rx , px , ax , s0 , sx ) !< Compute an unknown state `x` from a known state `0` when the two states are separated by a rarefaction, given the velocity !< `ux`. !< !< The `sgn` dummy argument indicates if the rarefaction propagates on `u-a (sgn=-1)` or `u+a (sgn=1)`. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: sgn !< Sign for distinguishing *left* (-1) from *right* (1) wave. real ( R8P ), intent ( in ) :: u0 , p0 , a0 !< Known state (speed, pressure and speed of sound). real ( R8P ), intent ( in ) :: ux !< Known speed of unknown state. real ( R8P ), intent ( out ) :: rx , px , ax !< Unknown pressure and density. real ( R8P ), intent ( out ) :: s0 , sx !< Wave speeds (head and back fronts). ax = a0 + sgn * eos % delta () * ( ux - u0 ) ! unknown speed of sound px = p0 * (( ax / a0 ) ** ( eos % eta ())) ! unknown pressure rx = eos % density ( pressure = px , speed_of_sound = ax ) ! unknown density s0 = u0 + sgn * a0 ! left wave speed sx = ux + sgn * ax ! right wave speed endsubroutine compute_post_rarefaction elemental subroutine compute_post_shock ( eos , sgn , u0 , p0 , a0 , ux , rx , px , ax , ss ) !< Computing an unknown state `x` from a known state `0` when the two states are separated by a shock, given the velocity !< `ux`. !< !< The `sgn` dummy argument indicates if the shock propagates on `u-a (sgn=-1)` or `u+a (sgn=1)`. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: sgn !< Sign for distinguishing *left* (-1) from *right* (1) wave. real ( R8P ), intent ( in ) :: u0 , p0 , a0 !< Known state (speed, pressure and speed of sound). real ( R8P ), intent ( in ) :: ux !< Unknown speed. real ( R8P ), intent ( out ) :: rx , px , ax !< Unknown state (density, pressure and speed of sound). real ( R8P ), intent ( out ) :: ss !< Shock wave speed. real ( R8P ) :: M0 !< Relative Mach number of known state. real ( R8P ) :: x !< Dummy variable. x = 0.25_R8P * eos % gp1 () * ( ux - u0 ) / a0 ! dummy variable M0 = x + sgn * sqrt ( 1.0_R8P + x * x ) ! relative Mach number of known state x = 1._R8P + 2._R8P * eos % g () * ( M0 * M0 - 1._R8P ) / eos % gp1 () ! dummy variable (pressure ratio px/p0) ax = a0 * sqrt (( eos % gp1 () + eos % gm1 () * x ) / ( eos % gp1 () + eos % gm1 () / x )) ! unknown speed of sound px = p0 * x ! unknown pressure rx = eos % density ( pressure = px , speed_of_sound = ax ) ! unknown density ss = u0 + a0 * M0 ! shock wave speed endsubroutine compute_post_shock endmodule foreseer_riemann_solver_compressible_object","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_object.f90.html","title":"foreseer_riemann_solver_compressible_object.f90 – FORESEER"},{"text":"Define the Primitive Variables Linearization based Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_pvl.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 var pansourcefileforeseer_riemann_solver_compressible_pvlf90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_pvlf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_pvl.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 var pansourcefileforeseer_riemann_solver_compressible_pvlf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_pvlf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_pvl Source Code foreseer_riemann_solver_compressible_pvl.f90 Source Code !< Define the Primitive Variables Linearization based Riemann solver of FORESEER library. module foreseer_riemann_solver_compressible_pvl !< Define the Primitive Variables Linearization based Riemann solver of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : I4P , R8P use vecfor , only : vector implicit none private public :: riemann_solver_compressible_pvl type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl !< Primitive Variables Linearization based Riemann solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. procedure ( compute_waves_interface ), pointer :: compute_waves_ => compute_waves_up23 !< Compute waves pattern procedure ( solve_interface ), pointer :: solve_ => solve_up23 !< Solve Riemann problem. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. ! private methods procedure , pass ( self ), private :: compute_u23 !< Compute interstates velocity. procedure , pass ( self ), private :: compute_up23 !< Compute interstates velocity and pressure. procedure , pass ( self ), private :: compute_waves_u23 !< Compute waves speed by `u23` algorithm. procedure , pass ( self ), private :: compute_waves_up23 !< Compute waves speed by `up23` algorithm. procedure , pass ( self ), private :: solve_u23 !< Compute whole pattern by `u23` algorithm. procedure , pass ( self ), private :: solve_up23 !< Compute whole pattern by `up23` algorithm. endtype riemann_solver_compressible_pvl abstract interface pure subroutine compute_waves_interface ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. import :: conservative_object , eos_object , riemann_solver_compressible_pvl , R8P , vector class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. endsubroutine compute_waves_interface pure subroutine solve_interface ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem. import :: conservative_object , eos_object , riemann_solver_compressible_pvl , vector class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. endsubroutine solve_interface endinterface contains ! public deferred methods pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % compute_waves_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves pure subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. call self % solve_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , fluxes = fluxes ) endsubroutine solve subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local var. self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 config_ = '' ; if ( present ( config )) config_ = config select case ( config_ ) case ( 'u23' ) self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 case ( 'up23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 case ( 'upr23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 endselect endsubroutine initialize ! private methods elemental subroutine compute_u23 ( self ) !< Compute interstates velocity. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. self % u23 = 0.5_R8P * ( self % u_1 + self % u_4 ) - 2.0_R8P * ( self % p_4 - self % p_1 ) / (( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 )) endsubroutine compute_u23 elemental subroutine compute_up23 ( self ) !< Compute interstates velocity and pressure. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. real ( R8P ) :: ram !< Mean value of `r * a`. ram = 0.25_R8P * ( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 ) self % u23 = 0.5_R8P * (( self % u_1 + self % u_4 ) - ( self % p_4 - self % p_1 ) / ram ) self % p23 = 0.5_R8P * (( self % p_1 + self % p_4 ) - ( self % u_4 - self % u_1 ) * ram ) endsubroutine compute_up23 pure subroutine compute_waves_u23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. real ( R8P ) :: x !< Dummy variable. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_u23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock x = 0.25_R8P * ( self % eos_1 % g () + 1._R8P ) * ( self % u23 - self % u_1 ) / self % a_1 self % s_1 = self % u_1 + self % a_1 * ( x - sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock x = 0.25_R8P * ( self % eos_4 % g () + 1._R8P ) * ( self % u23 - self % u_4 ) / self % a_4 self % s_4 = self % u_4 + self % a_4 * ( x + sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_u23 pure subroutine compute_waves_up23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_up23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock self % s_1 = self % u_1 - self % a_1 * sqrt ( 1._R8P + 0.5_R8P * ( self % eos_1 % g () + 1._R8P ) / & self % eos_1 % g () * ( self % p23 / self % p_1 - 1._R8P )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock self % s_4 = self % u_4 + self % a_4 * sqrt ( 1._R8P + 0.5_R8P * ( self % eos_4 % g () + 1._R8P ) / & self % eos_4 % g () * ( self % p23 / self % p_4 - 1._R8P )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_up23 pure subroutine solve_u23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem by `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_u23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_u23 pure subroutine solve_up23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem `up23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Riemann pattern. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_up23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_up23 endmodule foreseer_riemann_solver_compressible_pvl","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_pvl.f90.html","title":"foreseer_riemann_solver_compressible_pvl.f90 – FORESEER"},{"text":"Define the Roe (with the Harten-Hyman entropy fix) Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_compressible_roe.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 var pansourcefileforeseer_riemann_solver_compressible_roef90EfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_roef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_compressible_roe.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_riemann_solver_compressible_roef90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_compressible_roef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_compressible_roe Source Code foreseer_riemann_solver_compressible_roe.F90 Source Code !< Define the Roe (with the Harten-Hyman entropy fix) Riemann solver of FORESEER library. module foreseer_riemann_solver_compressible_roe !< Define the Roe (with the Harten-Hyman entropy fix) Riemann solver of FORESEER library. use foreseer_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use foreseer_conservative_object , only : conservative_object use foreseer_eos_compressible , only : eos_compressible , eos_compressible_pointer use foreseer_eos_object , only : eos_object use foreseer_riemann_solver_compressible_object , only : riemann_solver_compressible_object use foreseer_riemann_solver_compressible_pvl , only : riemann_solver_compressible_pvl use foreseer_riemann_solver_object , only : riemann_solver_object use penf , only : R8P use vecfor , only : vector implicit none private public :: riemann_solver_compressible_roe type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_roe !< Roe (with the Harten-Hyman entropy fix) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. procedure , nopass :: compute_roe_state !< Compute intermediate state. endtype riemann_solver_compressible_roe contains ! public deferred methods pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_roe ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_roe ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. call self % solver_pvl % initialize ( config = 'u23' ) endsubroutine initialize subroutine compute_roe_state ( eos_left , state_left , eos_right , state_right , r_d , r_u , r_e , r_a ) !< Evaluate the intermediate state from the known states U1,U4 using the Roe linearization. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. real ( R8P ), intent ( out ) :: r_d !< Roe intermediate state density. type ( vector ), intent ( out ) :: r_u !< Roe intermediate state velocity vector.. real ( R8P ), intent ( out ) :: r_e !< Roe intermediate state enthalpy. real ( R8P ), intent ( out ) :: r_a !< Roe intermediate state sound speed. real ( R8P ) :: x , omx !< x = sqrt(r1)/(sqrt(r1)+sqrt(r4)),  omx = 1-x real ( R8P ) :: cp , cv !< Roe intermediate state Cp and Cv. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( eos_compressible ), pointer :: eos_left_ !< Left Riemann state, local variable. type ( eos_compressible ), pointer :: eos_right_ !< Right Riemann state, local variable. state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) eos_left_ => eos_compressible_pointer ( to = eos_left ) eos_right_ => eos_compressible_pointer ( to = eos_right ) x = sqrt ( state_left_ % density ) / ( sqrt ( state_left_ % density ) + sqrt ( state_right_ % density )) ; omx = 1._R8P - x r_d = sqrt ( state_left_ % density * state_right_ % density ) r_u % x = state_left_ % momentum % x / state_left_ % density * x + state_right_ % momentum % x / state_right_ % density * omx r_u % y = state_left_ % momentum % y / state_left_ % density * x + state_right_ % momentum % y / state_right_ % density * omx r_u % z = state_left_ % momentum % z / state_left_ % density * x + state_right_ % momentum % z / state_right_ % density * omx r_e = ( state_left_ % energy + state_left_ % pressure ( eos_left )) / state_left_ % density * x + & ( state_right_ % energy + state_right_ % pressure ( eos_right )) / state_right_ % density * omx cp = eos_left_ % cp_ * x + eos_right_ % cp_ * omx cv = eos_left_ % cv_ * x + eos_right_ % cv_ * omx r_a = sqrt (( cp / cv - 1._R8P ) * ( r_e - 0.5_R8P * r_u % sq_norm ())) endsubroutine compute_roe_state subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on Roe (with Harten-Hyman entropy fix) algorithm. class ( riemann_solver_compressible_roe ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( conservative_compressible ) :: fluxes_left !< Fluxes of left state. type ( conservative_compressible ) :: fluxes_right !< Fluxes of right state. type ( conservative_compressible ) :: state23 !< Intermediate states. real ( R8P ) :: r_d !< Roe intermediate state density. type ( vector ) :: r_u !< Roe intermediate state velocity vector.. real ( R8P ) :: r_e !< Roe intermediate state enthalpy. real ( R8P ) :: r_a !< Roe intermediate state sound speed. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: lmax !< Maximum wave speed estimation. type ( vector ) :: vec_a !< Vector of sound speeds, local variable. type ( vector ) :: vec_r !< Vector of densities, local variable. type ( vector ) :: vec_m !< Vector of momentums, local variable. type ( vector ) :: vec_e !< Vector of energies, local variable. real ( R8P ) :: Dr !< Density difference  Dr = r4-r1. real ( R8P ) :: Du !< Velocity difference Du = u4-u1. real ( R8P ) :: Dp !< Pressure difference Dp = p4-p1. real ( R8P ) :: aa1 , aa2 , aa3 !< Wawes amplitudes Roe's estimation. real ( R8P ) :: ll1 , ll2 , ll3 !< Wawes speeds Roe's estimation. real ( R8P ) :: ls1 , ls3 !< Wawes speeds Roe's estimation with entropy fix of Harten-Hyman. real ( R8P ) :: p_2 , p_3 !< Pessure of state 2 and 3. real ( R8P ) :: u23 !< Maximum wave speed estimation. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) associate ( r_1 => self % solver_pvl % r_1 , u_1 => self % solver_pvl % u_1 , p_1 => self % solver_pvl % p_1 , & r_4 => self % solver_pvl % r_4 , u_4 => self % solver_pvl % u_4 , p_4 => self % solver_pvl % p_4 , & s_1 => self % s_1 , s_2 => self % s_2 , s_3 => self % s_3 , s_4 => self % s_4 , u23 => self % u23 ) s_1 = waves ( 1 ) u23 = waves ( 3 ) s_4 = waves ( 5 ) call self % compute_states23_from_u23 ( p_2 = p_2 , p_3 = p_3 ) select case ( minloc ([ - s_1 , s_1 * s_2 , s_2 * u23 , u23 * s_3 , s_3 * s_4 , s_4 ], dim = 1 )) case ( 1 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) case ( 2 ) call compute_roe_state ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , & r_d = r_d , r_u = r_u , r_e = r_e , r_a = r_a ) Du = u_4 - u_1 Dp = p_4 - p_1 aa1 = 0.5_R8P * ( Dp - r_d * r_a * Du ) / ( r_a * r_a ) ll1 = ( r_u . dot . normal ) - r_a ls1 = s_1 * ( s_2 - ll1 ) / ( s_2 - s_1 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) state23 % density = aa1 state23 % momentum = aa1 * ll1 * normal state23 % energy = aa1 * ( r_e - ( r_u . dot . normal ) * r_a ) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + ls1 * state23 endselect case ( 3 , 4 ) call compute_roe_state ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , & r_d = r_d , r_u = r_u , r_e = r_e , r_a = r_a ) Dr = r_4 - r_1 Du = u_4 - u_1 Dp = p_4 - p_1 aa1 = 0.5_R8P * ( Dp - r_d * r_a * Du ) / ( r_a * r_a ) aa2 = Dr - Dp / ( r_a * r_a ) aa3 = 0.5_R8P * ( Dp + r_d * r_a * Du ) / ( r_a * r_a ) ll1 = ( r_u . dot . normal ) - r_d ll2 = ( r_u . dot . normal ) ll3 = ( r_u . dot . normal ) + r_d call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) vec_a % x = abs ( ll1 ) ; vec_a % y = abs ( ll2 ) ; vec_a % z = abs ( ll3 ) vec_r % x = aa1 ; vec_r % y = aa2 ; vec_r % z = aa3 vec_m % x = aa1 * ll1 ; vec_m % y = aa2 * ll2 ; vec_m % z = aa3 * ll3 vec_e % x = aa1 * ( r_e - ( r_u . dot . normal ) * r_a ); vec_e % y = aa2 * 0.5_R8P * ll2 * ll2 vec_e % x = aa3 * ( r_e - ( r_u . dot . normal ) * r_a ) state23 % density = vec_a . dot . vec_r state23 % momentum = ( vec_a . dot . vec_m ) * normal state23 % energy = vec_a . dot . vec_e select type ( fluxes ) type is ( conservative_compressible ) fluxes = 0.5_R8P * ( fluxes_left + fluxes_right - state23 ) endselect case ( 5 ) call compute_roe_state ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , & r_d = r_d , r_u = r_u , r_e = r_e , r_a = r_a ) Du = u_4 - u_1 Dp = p_4 - p_1 aa3 = 0.5_R8P * ( Dp - r_d * r_a * Du ) / ( r_a * r_a ) ll3 = ( r_u . dot . normal ) - r_a ls3 = s_4 * ( ll3 - s_3 ) / ( s_4 - s_3 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) state23 % density = aa3 state23 % momentum = aa3 * ll3 * normal state23 % energy = aa3 * ( r_e - ( r_u . dot . normal ) * r_a ) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + ls3 * state23 endselect case ( 6 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) endselect endassociate endsubroutine solve endmodule foreseer_riemann_solver_compressible_roe","tags":"","loc":"sourcefile/foreseer_riemann_solver_compressible_roe.f90.html","title":"foreseer_riemann_solver_compressible_roe.F90 – FORESEER"},{"text":"Define the abstract Riemann solver of FORESEER library. This File Depends On sourcefile~~foreseer_riemann_solver_object.f90~~EfferentGraph sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foreseer_riemann_solver_object.f90~~AfferentGraph sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 var pansourcefileforeseer_riemann_solver_objectf90AfferentGraph = svgPanZoom('#sourcefileforeseer_riemann_solver_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foreseer_riemann_solver_object Source Code foreseer_riemann_solver_object.f90 Source Code !< Define the abstract Riemann solver of FORESEER library. module foreseer_riemann_solver_object !< Define the abstract Riemann solver of FORESEER library. use foreseer_conservative_object , only : conservative_object use foreseer_eos_object , only : eos_object use penf , only : R8P use vecfor , only : vector implicit none private public :: riemann_solver_object type , abstract :: riemann_solver_object !< Abstract Riemann Solver. contains ! public deferred methods procedure ( compute_waves_interface ), pass ( self ), deferred :: compute_waves !< Compute waves pattern. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize solver. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( solve_interface ), pass ( self ), deferred :: solve !< Solve Riemann Problem. endtype riemann_solver_object abstract interface !< Abstract interfaces of [[riemann_solver_object]] deferred methods. pure subroutine compute_waves_interface ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< This compute only the waves pattern, not the fluxes: this is useful for building solvers being hybrid of other solvers. import :: conservative_object , eos_object , riemann_solver_object , R8P , vector class ( riemann_solver_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. endsubroutine compute_waves_interface subroutine initialize_interface ( self , config ) !< Initialize solver. import :: riemann_solver_object class ( riemann_solver_object ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. endsubroutine initialize_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: riemann_solver_object class ( riemann_solver_object ), intent ( in ) :: self !< Solver. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface subroutine solve_interface ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. import :: conservative_object , eos_object , riemann_solver_object , vector class ( riemann_solver_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. endsubroutine solve_interface endinterface endmodule foreseer_riemann_solver_object","tags":"","loc":"sourcefile/foreseer_riemann_solver_object.f90.html","title":"foreseer_riemann_solver_object.f90 – FORESEER"},{"text":"FORESEER test: compressible variables transformations test. This File Depends On sourcefile~~foreseer_test_compressible_transformations.f90~~EfferentGraph sourcefile~foreseer_test_compressible_transformations.f90 foreseer_test_compressible_transformations.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_compressible_transformations.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_compressible_transformationsf90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_compressible_transformationsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_compressible_transformations Source Code foreseer_test_compressible_transformations.f90 Source Code !< FORESEER test: compressible variables transformations test. program foreseer_test_compressible_transformations !< FORESEER test: compressible variables transformations test. use foreseer , only : eos_compressible , conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( primitive_compressible ) :: p !< A primitive compressible instance. type ( conservative_compressible ) :: u !< A conservative compressible instance. logical :: are_tests_passed ( 2 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) p = conservative_to_primitive_compressible ( conservative = u , eos = eos ) are_tests_passed ( 1 ) = ( p % density >= 1._R8P - ZeroR8 ). and .( p % density <= 1._R8P + ZeroR8 ). and . & ( p % velocity >= 0._R8P - ZeroR8 ). and .( p % velocity <= 0._R8P + ZeroR8 ). and . & ( p % pressure >= 1._R8P - ZeroR8 ). and .( p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u to p, is done right? ' , are_tests_passed ( 1 ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) u = primitive_to_conservative_compressible ( primitive = p , eos = eos ) are_tests_passed ( 2 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 2.5_R8P - ZeroR8 ). and .( u % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'p to u, is done right? ' , are_tests_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_compressible_transformations","tags":"","loc":"sourcefile/foreseer_test_compressible_transformations.f90.html","title":"foreseer_test_compressible_transformations.f90 – FORESEER"},{"text":"FORESEER test: conservative compressible class test. This File Depends On sourcefile~~foreseer_test_conservative_compressible.f90~~EfferentGraph sourcefile~foreseer_test_conservative_compressible.f90 foreseer_test_conservative_compressible.F90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_conservative_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_conservative_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_conservative_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_conservative_compressible Source Code foreseer_test_conservative_compressible.F90 Source Code !< FORESEER test: conservative compressible class test. program foreseer_test_conservative_compressible !< FORESEER test: conservative compressible class test. use foreseer , only : eos_compressible , conservative_compressible , conservative_compressible_pointer use penf , only : R8P , ZeroR8 use vecfor , only : ex , vector implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( conservative_compressible ) :: u !< A conservative compressible instance. type ( conservative_compressible ) :: another_u !< Another conservative compressible instance. type ( conservative_compressible ), pointer :: u_pointer !< A conservative compressible pointer. type ( conservative_compressible ) :: f !< Conservative fluxes. type ( vector ) :: velocity !< Velocity vector. real ( R8P ), allocatable :: u_serialized (:) !< Conservative variable serialized. #ifdef __GFORTRAN__ logical :: are_tests_passed ( 17 ) !< List of passed tests. #else logical :: are_tests_passed ( 9 ) !< List of passed tests. #endif are_tests_passed = . false . call u % initialize are_tests_passed ( 1 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'conservative = 0, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) are_tests_passed ( 2 ) = ( u % pressure ( eos = eos ) >= 1._R8P - ZeroR8 ). and .( u % pressure ( eos = eos ) <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%pressure() = 1, is right? ' , are_tests_passed ( 2 ) velocity = u % velocity () are_tests_passed ( 3 ) = ( u % velocity () >= 0._R8P - ZeroR8 ). and .( u % velocity () <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%velocity() = 0, is right? ' , are_tests_passed ( 3 ) u_serialized = u % array () are_tests_passed ( 4 ) = ( size ( u_serialized , dim = 1 ) == 5 ). and . & ( u_serialized ( 1 ) == 1._R8P ). and . & ( u_serialized ( 2 ) == 0._R8P ). and . & ( u_serialized ( 3 ) == 0._R8P ). and . & ( u_serialized ( 4 ) == 0._R8P ). and . & ( u_serialized ( 5 ) == 2.5_R8P ) print \"(A,L1)\" , 'u => serialized, is done right? ' , are_tests_passed ( 4 ) call u % destroy are_tests_passed ( 5 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'u destroyed, is right? ' , are_tests_passed ( 5 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) call u % compute_fluxes ( eos = eos , normal = ex , fluxes = f ) are_tests_passed ( 6 ) = ( f % density >= 1._R8P - ZeroR8 ). and .( f % density <= 1._R8P + ZeroR8 ). and . & ( f % momentum >= 1.8_R8P - ZeroR8 ). and .( f % momentum <= 1.8_R8P + ZeroR8 ). and . & ( f % energy >= 3.3_R8P - ZeroR8 ). and .( f % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'compute fluxes along X, is done right? ' , are_tests_passed ( 6 ) u = f are_tests_passed ( 7 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 1.8_R8P - ZeroR8 ). and .( u % momentum <= 1.8_R8P + ZeroR8 ). and . & ( u % energy >= 3.3_R8P - ZeroR8 ). and .( u % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = f, is done right? ' , are_tests_passed ( 7 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u_pointer => conservative_compressible_pointer ( to = u ) are_tests_passed ( 8 ) = ( u_pointer % density >= 1._R8P - ZeroR8 ). and .( u_pointer % density <= 1._R8P + ZeroR8 ). and . & ( u_pointer % momentum >= 1._R8P - ZeroR8 ). and .( u_pointer % momentum <= 1._R8P + ZeroR8 ). and . & ( u_pointer % energy >= 2.5_R8P - ZeroR8 ). and .( u_pointer % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u => u, is done right? ' , are_tests_passed ( 8 ) call another_u % initialize ( initial_state = u ) are_tests_passed ( 9 ) = ( another_u % density >= 1._R8P - ZeroR8 ). and .( another_u % density <= 1._R8P + ZeroR8 ). and . & ( another_u % momentum >= 1._R8P - ZeroR8 ). and .( another_u % momentum <= 1._R8P + ZeroR8 ). and . & ( another_u % energy >= 2.5_R8P - ZeroR8 ). and .( another_u % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'antoher_u == u, is right? ' , are_tests_passed ( 9 ) #ifdef __GFORTRAN__ u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u = 2._R8P * u are_tests_passed ( 10 ) = ( u % density >= 2._R8P - ZeroR8 ). and .( u % density <= 2._R8P + ZeroR8 ). and . & ( u % momentum >= 2._R8P - ZeroR8 ). and .( u % momentum <= 2._R8P + ZeroR8 ). and . & ( u % energy >= 5._R8P - ZeroR8 ). and .( u % energy <= 5._R8P + ZeroR8 ) print \"(A,L1)\" , '2 * u, is done right? ' , are_tests_passed ( 10 ) u = u * u are_tests_passed ( 11 ) = ( u % density >= 4._R8P - ZeroR8 ). and .( u % density <= 4._R8P + ZeroR8 ). and . & ( u % momentum >= 4._R8P - ZeroR8 ). and .( u % momentum <= 4._R8P + ZeroR8 ). and . & ( u % energy >= 2 5._R8P - ZeroR8 ). and .( u % energy <= 2 5._R8P + ZeroR8 ) print \"(A,L1)\" , 'u * u, is done right? ' , are_tests_passed ( 11 ) u = u + u are_tests_passed ( 12 ) = ( u % density >= 8._R8P - ZeroR8 ). and .( u % density <= 8._R8P + ZeroR8 ). and . & ( u % momentum >= 8._R8P - ZeroR8 ). and .( u % momentum <= 8._R8P + ZeroR8 ). and . & ( u % energy >= 5 0._R8P - ZeroR8 ). and .( u % energy <= 5 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u + u, is done right? ' , are_tests_passed ( 12 ) u = u - u are_tests_passed ( 13 ) = ( u % density >= 0._R8P - ZeroR8 ). and .( u % density <= 0._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 0._R8P - ZeroR8 ). and .( u % energy <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u - u, is done right? ' , are_tests_passed ( 13 ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) u = - u are_tests_passed ( 14 ) = ( u % density >= - 1._R8P - ZeroR8 ). and .( u % density <= - 1._R8P + ZeroR8 ). and . & ( u % energy >= - 2.5_R8P - ZeroR8 ). and .( u % energy <= - 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = - u, is done right? ' , are_tests_passed ( 14 ) u = + u are_tests_passed ( 15 ) = ( u % density >= - 1._R8P - ZeroR8 ). and .( u % density <= - 1._R8P + ZeroR8 ). and . & ( u % energy >= - 2.5_R8P - ZeroR8 ). and .( u % energy <= - 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = + u, is done right? ' , are_tests_passed ( 15 ) u = u * 2._R8P are_tests_passed ( 16 ) = ( u % density >= - 2._R8P - ZeroR8 ). and .( u % density <= - 2._R8P + ZeroR8 ). and . & ( u % energy >= - 5._R8P - ZeroR8 ). and .( u % energy <= - 5._R8P + ZeroR8 ) print \"(A,L1)\" , 'u * 2, is done right? ' , are_tests_passed ( 16 ) u = u / 2._R8P are_tests_passed ( 17 ) = ( u % density >= - 1._R8P - ZeroR8 ). and .( u % density <= - 1._R8P + ZeroR8 ). and . & ( u % energy >= - 2.5_R8P - ZeroR8 ). and .( u % energy <= - 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u / 2, is done right? ' , are_tests_passed ( 17 ) #endif print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_conservative_compressible","tags":"","loc":"sourcefile/foreseer_test_conservative_compressible.f90.html","title":"foreseer_test_conservative_compressible.F90 – FORESEER"},{"text":"FORESEER test: equation of state compressible class test. This File Depends On sourcefile~~foreseer_test_eos_compressible.f90~~EfferentGraph sourcefile~foreseer_test_eos_compressible.f90 foreseer_test_eos_compressible.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_eos_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_eos_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_eos_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_eos_compressible Source Code foreseer_test_eos_compressible.f90 Source Code !< FORESEER test: equation of state compressible class test. program foreseer_test_eos_compressible !< FORESEER test: equation of state compressible class test. use foreseer , only : eos_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. logical :: are_tests_passed ( 14 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) print \"(A)\" , 'EOS description:' print \"(A)\" , eos % description () are_tests_passed ( 1 ) = ( eos % g () >= 1.4_R8P - ZeroR8 ). and .( eos % g () <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%g() = 1.4, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , gam = 1.4_R8P ) are_tests_passed ( 2 ) = ( eos % cv () >= 74 2.86_R8P - ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 2 ) eos = eos_compressible ( cv = 74 2.86_R8P , gam = 1.4_R8P ) are_tests_passed ( 3 ) = ( eos % R () >= 29 7.144_R8P - 1000 * ZeroR8 ). and .( eos % R () <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%R() = 297.144, is right? ' , are_tests_passed ( 3 ) eos = eos_compressible ( cv = 74 2.86_R8P , R = 29 7.144_R8P ) are_tests_passed ( 4 ) = ( eos % cp () >= 104 0.004_R8P - ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 4 ) eos = eos_compressible ( cp = 104 0.004_R8P , R = 29 7.144_R8P ) are_tests_passed ( 5 ) = ( eos % cv () >= 74 2.86_R8P - 1000 * ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 5 ) eos = eos_compressible ( gam = 1.4_R8P , R = 29 7.144_R8P ) are_tests_passed ( 6 ) = ( eos % cp () >= 104 0.004_R8P - 1000 * ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 6 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 7 ) = ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) >= 0.4_R8P - ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) <= 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, energy=1) = 0.4, is right? ' , are_tests_passed ( 7 ) are_tests_passed ( 8 ) = ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) >= 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, temperature=1) = 297.144, is right? ' , are_tests_passed ( 8 ) are_tests_passed ( 9 ) = ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) >= 1._R8P / 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) <= 1._R8P / 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, temperature=1) = 1/297.144, is right? ' , are_tests_passed ( 9 ) are_tests_passed ( 10 ) = ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, energy=1) = 1/0.4, is right? ' , are_tests_passed ( 10 ) are_tests_passed ( 11 ) = ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(density=1, pressure=1) = 1/0.4, is right? ' , are_tests_passed ( 11 ) are_tests_passed ( 12 ) = ( eos % energy ( temperature = 1._R8P ) >= 74 2.86_R8P - ZeroR8 ). and .& ( eos % energy ( temperature = 1._R8P ) <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(temperature=1) = 742.86, is right? ' , are_tests_passed ( 12 ) are_tests_passed ( 13 ) = ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 29 7.144_R8P - ZeroR8 ). and .& ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 29 7.144_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(density=1, pressure=1) = 1/297.144, is right? ' , are_tests_passed ( 13 ) are_tests_passed ( 14 ) = ( eos % temperature ( energy = 1._R8P ) >= 1._R8P / 74 2.86_R8P - ZeroR8 ). and .& ( eos % temperature ( energy = 1._R8P ) <= 1._R8P / 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(energy=1) = 1/742.86, is right? ' , are_tests_passed ( 14 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_eos_compressible","tags":"","loc":"sourcefile/foreseer_test_eos_compressible.f90.html","title":"foreseer_test_eos_compressible.f90 – FORESEER"},{"text":"FORESEER test: primitive compressible class test. This File Depends On sourcefile~~foreseer_test_primitive_compressible.f90~~EfferentGraph sourcefile~foreseer_test_primitive_compressible.f90 foreseer_test_primitive_compressible.F90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_primitive_compressible.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_primitive_compressiblef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_primitive_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_primitive_compressible Source Code foreseer_test_primitive_compressible.F90 Source Code !< FORESEER test: primitive compressible class test. program foreseer_test_primitive_compressible !< FORESEER test: primitive compressible class test. use foreseer , only : eos_compressible , primitive_compressible , primitive_compressible_pointer use penf , only : R8P , ZeroR8 use vecfor , only : ex , vector implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( primitive_compressible ) :: p !< A primitive compressible instance. type ( primitive_compressible ) :: another_p !< A primitive compressible instance. type ( primitive_compressible ), pointer :: p_pointer !< A primitive compressible pointer. type ( vector ) :: momentum !< Momentum vector. real ( R8P ), allocatable :: p_serialized (:) !< Primitive variable serialized. real ( R8P ), allocatable :: l_eigenvectors (:,:) !< Left eigenvectors matrix. real ( R8P ), allocatable :: r_eigenvectors (:,:) !< Right eigenvectors matrix. real ( R8P ), allocatable :: identity (:,:) !< Identity tensor. #ifdef __GFORTRAN__ logical :: are_tests_passed ( 16 ) !< List of passed tests. #else logical :: are_tests_passed ( 8 ) !< List of passed tests. #endif are_tests_passed = . false . call p % initialize are_tests_passed ( 1 ) = ( p % density == 0._R8P ). and . & ( p % velocity == 0._R8P ). and . & ( p % pressure == 0._R8P ) print \"(A,L1)\" , 'primitive = 0, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) are_tests_passed ( 2 ) = ( p % energy ( eos = eos ) >= 2.5_R8P - ZeroR8 ). and .( p % energy ( eos = eos ) <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'p%energy() = 2.5, is right? ' , are_tests_passed ( 2 ) momentum = p % momentum () are_tests_passed ( 3 ) = ( p % momentum () >= 0._R8P - ZeroR8 ). and .( p % momentum () <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'p%momentum() = 0, is right? ' , are_tests_passed ( 3 ) p_serialized = p % array () are_tests_passed ( 4 ) = ( size ( p_serialized , dim = 1 ) == 5 ). and . & ( p_serialized ( 1 ) == 1._R8P ). and . & ( p_serialized ( 2 ) == 0._R8P ). and . & ( p_serialized ( 3 ) == 0._R8P ). and . & ( p_serialized ( 4 ) == 0._R8P ). and . & ( p_serialized ( 5 ) == 1._R8P ) print \"(A,L1)\" , 'p => serialized, is done right? ' , are_tests_passed ( 4 ) call p % destroy are_tests_passed ( 5 ) = ( p % density == 0._R8P ). and . & ( p % velocity == 0._R8P ). and . & ( p % pressure == 0._R8P ) print \"(A,L1)\" , 'p destroyed, is right? ' , are_tests_passed ( 5 ) p = primitive_compressible ( density = 1._R8P , velocity = ex , pressure = 1._R8P ) another_p = p are_tests_passed ( 6 ) = ( another_p % density >= 1._R8P - ZeroR8 ). and .( another_p % density <= 1._R8P + ZeroR8 ). and . & ( another_p % velocity >= 1._R8P - ZeroR8 ). and .( another_p % velocity <= 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= 1._R8P - ZeroR8 ). and .( another_p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'another_p = p, is done right? ' , are_tests_passed ( 6 ) p_pointer => primitive_compressible_pointer ( to = p ) are_tests_passed ( 7 ) = ( p_pointer % density >= 1._R8P - ZeroR8 ). and .( p_pointer % density <= 1._R8P + ZeroR8 ). and . & ( p_pointer % velocity >= 1._R8P - ZeroR8 ). and .( p_pointer % velocity <= 1._R8P + ZeroR8 ). and . & ( p_pointer % pressure >= 1._R8P - ZeroR8 ). and .( p_pointer % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'p => p, is done right? ' , are_tests_passed ( 7 ) call another_p % initialize ( initial_state = p ) are_tests_passed ( 8 ) = ( another_p % density >= 1._R8P - ZeroR8 ). and .( another_p % density <= 1._R8P + ZeroR8 ). and . & ( another_p % velocity >= 1._R8P - ZeroR8 ). and .( another_p % velocity <= 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= 1._R8P - ZeroR8 ). and .( another_p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'antoher_p == p, is right? ' , are_tests_passed ( 8 ) #ifdef __GFORTRAN__ p = 2._R8P * p are_tests_passed ( 9 ) = ( p % density >= 2._R8P - ZeroR8 ). and .( p % density <= 2._R8P + ZeroR8 ). and . & ( p % velocity >= 2._R8P - ZeroR8 ). and .( p % velocity <= 2._R8P + ZeroR8 ). and . & ( p % pressure >= 2._R8P - ZeroR8 ). and .( p % pressure <= 2._R8P + ZeroR8 ) print \"(A,L1)\" , '2 * p, is done right? ' , are_tests_passed ( 9 ) p = p * p are_tests_passed ( 10 ) = ( p % density >= 4._R8P - ZeroR8 ). and .( p % density <= 4._R8P + ZeroR8 ). and . & ( p % velocity >= 4._R8P - ZeroR8 ). and .( p % velocity <= 4._R8P + ZeroR8 ). and . & ( p % pressure >= 4._R8P - ZeroR8 ). and .( p % pressure <= 4._R8P + ZeroR8 ) print \"(A,L1)\" , 'p * p, is done right? ' , are_tests_passed ( 10 ) p = p + p are_tests_passed ( 11 ) = ( p % density >= 8._R8P - ZeroR8 ). and .( p % density <= 8._R8P + ZeroR8 ). and . & ( p % velocity >= 8._R8P - ZeroR8 ). and .( p % velocity <= 8._R8P + ZeroR8 ). and . & ( p % pressure >= 8._R8P - ZeroR8 ). and .( p % pressure <= 8._R8P + ZeroR8 ) print \"(A,L1)\" , 'p + p, is done right? ' , are_tests_passed ( 11 ) p = p - p are_tests_passed ( 12 ) = ( p % density >= 0._R8P - ZeroR8 ). and .( p % density <= 0._R8P + ZeroR8 ). and . & ( p % velocity >= 0._R8P - ZeroR8 ). and .( p % velocity <= 0._R8P + ZeroR8 ). and . & ( p % pressure >= 0._R8P - ZeroR8 ). and .( p % pressure <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'p - p, is done right? ' , are_tests_passed ( 12 ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) another_p = - p are_tests_passed ( 13 ) = ( another_p % density >= - 1._R8P - ZeroR8 ). and .( another_p % density <= - 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= - 1._R8P - ZeroR8 ). and .( another_p % pressure <= - 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'another_p = - p, is done right? ' , are_tests_passed ( 13 ) another_p = + p are_tests_passed ( 14 ) = ( another_p % density >= 1._R8P - ZeroR8 ). and .( another_p % density <= 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= 1._R8P - ZeroR8 ). and .( another_p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'another_p = + p, is done right? ' , are_tests_passed ( 14 ) p = p * 2._R8P are_tests_passed ( 15 ) = ( p % density >= 2._R8P - ZeroR8 ). and .( p % density <= 2._R8P + ZeroR8 ). and . & ( p % pressure >= 2._R8P - ZeroR8 ). and .( p % pressure <= 2._R8P + ZeroR8 ) print \"(A,L1)\" , 'p * 2, is done right? ' , are_tests_passed ( 15 ) p = p / 2._R8P are_tests_passed ( 16 ) = ( p % density >= 1._R8P - ZeroR8 ). and .( p % density <= 1._R8P + ZeroR8 ). and . & ( p % pressure >= 1._R8P - ZeroR8 ). and .( p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'p / 2, is done right? ' , are_tests_passed ( 16 ) #endif p = primitive_compressible ( density = 1._R8P , velocity = ex , pressure = 1._R8P ) print \"(A)\" , \"Test pretty printing\" print \"(A)\" , p_pointer % description () print \"(A)\" , \"Test eigenvector computing\" l_eigenvectors = p % left_eigenvectors ( eos = eos ) r_eigenvectors = p % right_eigenvectors ( eos = eos ) identity = matmul ( l_eigenvectors , r_eigenvectors ) print \"(A)\" , \"Left\" print \"(3F7.3)\" , l_eigenvectors ( 1 ,:) print \"(3F7.3)\" , l_eigenvectors ( 2 ,:) print \"(3F7.3)\" , l_eigenvectors ( 3 ,:) print \"(A)\" , \"Right\" print \"(3F7.3)\" , r_eigenvectors ( 1 ,:) print \"(3F7.3)\" , r_eigenvectors ( 2 ,:) print \"(3F7.3)\" , r_eigenvectors ( 3 ,:) print \"(A)\" , \"L * R\" print \"(3F7.3)\" , identity ( 1 ,:) print \"(3F7.3)\" , identity ( 2 ,:) print \"(3F7.3)\" , identity ( 3 ,:) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_primitive_compressible","tags":"","loc":"sourcefile/foreseer_test_primitive_compressible.f90.html","title":"foreseer_test_primitive_compressible.F90 – FORESEER"},{"text":"FORESEER test: Riemann solver compressible exact (Newton iterative) class test. This File Depends On sourcefile~~foreseer_test_riemann_solver_compressible_exact.f90~~EfferentGraph sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_riemann_solver_compressible_exactf90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_riemann_solver_compressible_exactf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_riemann_solver_compressible_hllc Source Code foreseer_test_riemann_solver_compressible_exact.f90 Source Code !< FORESEER test: Riemann solver compressible exact (Newton iterative) class test. program foreseer_test_riemann_solver_compressible_hllc !< FORESEER test: Riemann solver compressible exact (Newton iterative) class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_exact use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_exact ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'States pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"10&#94;-15\" tolerance:' call riemann_solver % initialize ( config = '1.e-15' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'States pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_hllc","tags":"","loc":"sourcefile/foreseer_test_riemann_solver_compressible_exact.f90.html","title":"foreseer_test_riemann_solver_compressible_exact.f90 – FORESEER"},{"text":"FORESEER test: Riemann solver compressible HLLC class test. This File Depends On sourcefile~~foreseer_test_riemann_solver_compressible_hllc.f90~~EfferentGraph sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_riemann_solver_compressible_hllcf90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_riemann_solver_compressible_hllcf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_riemann_solver_compressible_hllc Source Code foreseer_test_riemann_solver_compressible_hllc.f90 Source Code !< FORESEER test: Riemann solver compressible HLLC class test. program foreseer_test_riemann_solver_compressible_hllc !< FORESEER test: Riemann solver compressible HLLC class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_hllc use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_hllc ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_hllc","tags":"","loc":"sourcefile/foreseer_test_riemann_solver_compressible_hllc.f90.html","title":"foreseer_test_riemann_solver_compressible_hllc.f90 – FORESEER"},{"text":"FORESEER test: Riemann solver compressible LLF class test. This File Depends On sourcefile~~foreseer_test_riemann_solver_compressible_llf.f90~~EfferentGraph sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_riemann_solver_compressible_llff90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_riemann_solver_compressible_llff90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_riemann_solver_compressible_llf Source Code foreseer_test_riemann_solver_compressible_llf.f90 Source Code !< FORESEER test: Riemann solver compressible LLF class test. program foreseer_test_riemann_solver_compressible_llf !< FORESEER test: Riemann solver compressible LLF class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_llf use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_llf","tags":"","loc":"sourcefile/foreseer_test_riemann_solver_compressible_llf.f90.html","title":"foreseer_test_riemann_solver_compressible_llf.f90 – FORESEER"},{"text":"FORESEER test: Riemann solver compressible PVL class test. This File Depends On sourcefile~~foreseer_test_riemann_solver_compressible_pvl.f90~~EfferentGraph sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_riemann_solver_compressible_pvlf90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_riemann_solver_compressible_pvlf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_riemann_solver_compressible_pvl Source Code foreseer_test_riemann_solver_compressible_pvl.f90 Source Code !< FORESEER test: Riemann solver compressible PVL class test. program foreseer_test_riemann_solver_compressible_pvl !< FORESEER test: Riemann solver compressible PVL class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_pvl use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Riemann solver internal pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Riemann solver internal pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_pvl","tags":"","loc":"sourcefile/foreseer_test_riemann_solver_compressible_pvl.f90.html","title":"foreseer_test_riemann_solver_compressible_pvl.f90 – FORESEER"},{"text":"FORESEER test: Riemann solver compressible Roe class test. This File Depends On sourcefile~~foreseer_test_riemann_solver_compressible_roe.f90~~EfferentGraph sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_riemann_solver_compressible_roef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_riemann_solver_compressible_roef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_riemann_solver_compressible_roe Source Code foreseer_test_riemann_solver_compressible_roe.f90 Source Code !< FORESEER test: Riemann solver compressible Roe class test. program foreseer_test_riemann_solver_compressible_roe !< FORESEER test: Riemann solver compressible Roe class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_roe use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_roe ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_roe","tags":"","loc":"sourcefile/foreseer_test_riemann_solver_compressible_roe.f90.html","title":"foreseer_test_riemann_solver_compressible_roe.f90 – FORESEER"},{"text":"FORESEER test: shock tube tester, 1D Euler equation. This File Depends On sourcefile~~foreseer_test_shock_tube.f90~~EfferentGraph sourcefile~foreseer_test_shock_tube.f90 foreseer_test_shock_tube.f90 sourcefile~foreseer.f90 foreseer.f90 sourcefile~foreseer.f90->sourcefile~foreseer_test_shock_tube.f90 sourcefile~foreseer_riemann_solver_compressible_llf.f90 foreseer_riemann_solver_compressible_llf.F90 sourcefile~foreseer_riemann_solver_compressible_llf.f90->sourcefile~foreseer.f90 sourcefile~foreseer_compressible_transformations.f90 foreseer_compressible_transformations.f90 sourcefile~foreseer_compressible_transformations.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90 foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90 foreseer_riemann_solver_compressible_exact.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90 foreseer_riemann_solver_compressible_roe.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90 foreseer_riemann_solver_compressible_hllc.F90 sourcefile~foreseer_riemann_solver_compressible_pvl.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_eos_object.f90 foreseer_eos_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90 foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90 foreseer_riemann_solver_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_compressible.f90 foreseer_conservative_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_primitive_compressible.f90 foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_compressible.f90 sourcefile~foreseer_eos_compressible.f90 foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_eos_compressible.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_object.f90 foreseer_conservative_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_conservative_object.f90 sourcefile~foreseer_primitive_object.f90 foreseer_primitive_object.f90 sourcefile~foreseer_eos_object.f90->sourcefile~foreseer_primitive_object.f90 sourcefile~foreseer_riemann_solver_compressible_exact.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_compressible.f90->sourcefile~foreseer_compressible_transformations.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_eos_compressible.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_riemann_solver_compressible_roe.f90->sourcefile~foreseer.f90 sourcefile~foreseer_riemann_solver_compressible_hllc.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_llf.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_pvl.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_exact.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_object.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_conservative_compressible.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_roe.f90 sourcefile~foreseer_conservative_object.f90->sourcefile~foreseer_riemann_solver_compressible_hllc.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer.f90 sourcefile~foreseer_primitive_object.f90->sourcefile~foreseer_primitive_compressible.f90 var pansourcefileforeseer_test_shock_tubef90EfferentGraph = svgPanZoom('#sourcefileforeseer_test_shock_tubef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foreseer_test_shock_tube Modules foreseer_euler_1d Source Code foreseer_test_shock_tube.f90 Source Code !< FORESEER test: shock tube tester, 1D Euler equation. module foreseer_euler_1d !< Definition of Euler 1D class for FORESEER test. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foreseer , only : conservative_object , conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible , & eos_object , eos_compressible , & riemann_solver_object , riemann_solver_compressible_exact , & riemann_solver_compressible_hllc , riemann_solver_compressible_llf , & riemann_solver_compressible_pvl , riemann_solver_compressible_roe use penf , only : I4P , R8P use foodie , only : integrand use vecfor , only : ex , vector use wenoof , only : interpolator_object , wenoof_create implicit none private public :: euler_1d type , extends ( integrand ) :: euler_1d !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an !< ideal (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). integer ( I4P ) :: weno_order = 0 !< WENO reconstruction order. integer ( I4P ) :: Ni = 0 !< Space dimension. integer ( I4P ) :: Ng = 0 !< Ghost cells number. real ( R8P ) :: Dx = 0._R8P !< Space step. type ( eos_compressible ) :: eos !< Equation of state. type ( conservative_compressible ), allocatable :: U (:) !< Integrand (state) variables. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. procedure ( reconstruct_interfaces_ ), pointer :: reconstruct_interfaces => & reconstruct_interfaces_characteristic !< Reconstruct interface states. procedure ( riemann_solver_ ), pointer :: riemann_solver => riemann_solver_llf !< Actual Riemann Problem solver. contains ! auxiliary methods procedure , pass ( self ) :: initialize !< Initialize field. procedure , pass ( self ) :: destroy !< Destroy field. procedure , pass ( self ) :: output !< Extract Euler field. procedure , pass ( self ) :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ) :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ) :: local_error => euler_local_error !< Operator `||euler-euler||`. procedure , pass ( lhs ) :: integrand_multiply_integrand => euler_multiply_euler !< Operator `*`. procedure , pass ( lhs ) :: integrand_multiply_real => euler_multiply_real !< Operator `euler * real`. procedure , pass ( rhs ) :: real_multiply_integrand => real_multiply_euler !< Operator `real * euler`. procedure , pass ( lhs ) :: add => add_euler !< Operator `+`. procedure , pass ( lhs ) :: sub => sub_euler !< Operator `-`. procedure , pass ( lhs ) :: assign_integrand => euler_assign_euler !< Operator `=`. procedure , pass ( lhs ) :: assign_real => euler_assign_real !< Operator `euler = real`. ! private methods procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_characteristic !< Reconstruct (charc.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_conservative !< Reconstruct (cons.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_primitive !< Reconstruct (prim.) interface states. procedure , pass ( self ), private :: riemann_solver_exact !< Exact Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_hllc !< HLLC Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_llf !< LLF Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_pvl !< PVL Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_roe !< Roe Riemann Problem solver. endtype euler_1d abstract interface !< Abstract interfaces of [[euler_1d]] pointer methods. subroutine riemann_solver_ ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver. import :: conservative_compressible , eos_compressible , euler_1d , vector class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. endsubroutine riemann_solver_ subroutine reconstruct_interfaces_ ( self , conservative , r_conservative ) !< Reconstruct interface states. import :: conservative_compressible , euler_1d , primitive_compressible class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative variables. endsubroutine reconstruct_interfaces_ endinterface contains ! auxiliary methods subroutine initialize ( self , Ni , Dx , BC_L , BC_R , initial_state , eos , weno_order , weno_variables , riemann_solver_scheme ) !< Initialize field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: Ni !< Space dimension. real ( R8P ), intent ( in ) :: Dx !< Space step. character ( * ), intent ( in ) :: BC_L !< Left boundary condition type. character ( * ), intent ( in ) :: BC_R !< Right boundary condition type. type ( primitive_compressible ), intent ( in ) :: initial_state ( 1 :) !< Initial state of primitive variables. type ( eos_compressible ), intent ( in ) :: eos !< Equation of state. integer ( I4P ), intent ( in ), optional :: weno_order !< WENO reconstruction order. character ( * ), intent ( in ), optional :: weno_variables !< Variables on which WENO reconstruction is done. character ( * ), intent ( in ), optional :: riemann_solver_scheme !< Riemann solver scheme. character (:), allocatable :: weno_variables_ !< WENO Variables, local variable. character (:), allocatable :: riemann_solver_scheme_ !< Riemann solver scheme, local variable. integer ( I4P ) :: i !< Space couner. call self % destroy self % weno_order = 1 ; if ( present ( weno_order )) self % weno_order = weno_order self % Ni = Ni self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = Dx self % eos = eos if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 - self % Ng : self % Ni + self % Ng )) do i = 1 , Ni self % U ( i ) = primitive_to_conservative_compressible ( primitive = initial_state ( i ), eos = eos ) enddo self % BC_L = BC_L self % BC_R = BC_R if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = self % interpolator ) weno_variables_ = 'characteristic' if ( present ( weno_variables )) weno_variables_ = trim ( adjustl ( weno_variables )) select case ( weno_variables_ ) case ( 'characteristic' ) self % reconstruct_interfaces => reconstruct_interfaces_characteristic case ( 'conservative' ) self % reconstruct_interfaces => reconstruct_interfaces_conservative case ( 'primitive' ) self % reconstruct_interfaces => reconstruct_interfaces_primitive case default write ( stderr , '(A)' ) 'error: WENO reconstruction variables set \"' // weno_variables_ // '\" unknown!' stop endselect riemann_solver_scheme_ = 'llf' if ( present ( riemann_solver_scheme )) riemann_solver_scheme_ = trim ( adjustl ( riemann_solver_scheme )) select case ( riemann_solver_scheme_ ) case ( 'exact' ) self % riemann_solver => riemann_solver_exact case ( 'hllc' ) self % riemann_solver => riemann_solver_hllc case ( 'llf' ) self % riemann_solver => riemann_solver_llf case ( 'pvl' ) self % riemann_solver => riemann_solver_pvl case ( 'roe' ) self % riemann_solver => riemann_solver_roe case default write ( stderr , '(A)' ) 'error: Riemann Solver scheme \"' // riemann_solver_scheme_ // '\" unknown!' stop endselect endsubroutine initialize pure subroutine destroy ( self ) !< Destroy field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. self % weno_order = 0 self % Ni = 0 self % Ng = 0 self % Dx = 0._R8P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) if ( allocated ( self % interpolator )) deallocate ( self % interpolator ) endsubroutine destroy pure function output ( self , is_primitive ) result ( state ) !< Output the Euler field state. class ( euler_1d ), intent ( in ) :: self !< Euler field. logical , intent ( in ), optional :: is_primitive !< Output in primitive variables. real ( R8P ), allocatable :: state (:,:) !< Euler state vector. real ( R8P ), allocatable :: state_ (:) !< Euler state vector, local variable. logical :: is_primitive_ !< Output in primitive variables, local variable. type ( primitive_compressible ) :: primitive !< Primitive state. integer ( I4P ) :: i !< Counter. is_primitive_ = . false . ; if ( present ( is_primitive )) is_primitive_ = is_primitive if ( is_primitive_ ) then allocate ( state ( 1 : size ( primitive % array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni primitive = conservative_to_primitive_compressible ( conservative = self % U ( i ), eos = self % eos ) state_ = primitive % array () enddo else allocate ( state ( 1 : size ( self % U ( 1 )% array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni state_ = self % U ( i )% array () state (:, i ) = state_ enddo endif endfunction output pure function compute_dt ( self , steps_max , t_max , t , CFL ) result ( Dt ) !< Compute the current time step by means of CFL condition. class ( euler_1d ), intent ( in ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: steps_max !< Maximun number of time steps. real ( R8P ), intent ( in ) :: t_max !< Maximum integration time. real ( R8P ), intent ( in ) :: t !< Time. real ( R8P ), intent ( in ) :: CFL !< CFL value. real ( R8P ) :: Dt !< Time step. type ( vector ) :: u !< Velocity vector. real ( R8P ) :: a !< Speed of sound. real ( R8P ) :: vmax !< Maximum propagation speed of signals. integer ( I4P ) :: i !< Counter. associate ( Ni => self % Ni , Dx => self % Dx ) vmax = 0._R8P do i = 1 , Ni u = self % U ( i )% velocity () a = self % eos % speed_of_sound ( density = self % U ( i )% density , pressure = self % U ( i )% pressure ( eos = self % eos )) vmax = max ( vmax , u % normL2 () + a ) enddo Dt = Dx * CFL / vmax if ( steps_max <= 0 . and . t_max > 0._R8P ) then if (( t + Dt ) > t_max ) Dt = t_max - t endif endassociate endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !< Time derivative of Euler field, the residuals function. class ( euler_1d ), intent ( in ) :: self !< Euler field. real ( R8P ), intent ( in ), optional :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. type ( conservative_compressible ) :: U ( 1 - self % Ng : self % Ni + self % Ng ) !< Conservative variables. type ( conservative_compressible ) :: UR ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed conservative variables. type ( conservative_compressible ) :: F ( 0 : self % Ni ) !< Fluxes of conservative variables. integer ( I4P ) :: i !< Counter. do i = 1 , self % Ni U ( i ) = self % U ( i ) enddo call self % impose_boundary_conditions ( U = U ) call self % reconstruct_interfaces ( conservative = U , r_conservative = UR ) do i = 0 , self % Ni call self % riemann_solver ( eos_left = self % eos , state_left = UR ( 2 , i ), & eos_right = self % eos , state_right = UR ( 1 , i + 1 ), normal = ex , fluxes = F ( i )) enddo allocate ( euler_1d :: dState_dt ) select type ( dState_dt ) class is ( euler_1d ) dState_dt = self do i = 1 , self % Ni dState_dt % U ( i ) = ( F ( i - 1 ) - F ( i )) / self % Dx enddo endselect endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. real ( R8P ) :: error !< Error estimation. real ( R8P ), allocatable :: U_lhs (:) !< Serialized conservative variables. real ( R8P ), allocatable :: U_rhs (:) !< Serialized conservative variables. integer ( I4P ) :: i !< Space counter. integer ( I4P ) :: v !< Variables counter. select type ( rhs ) class is ( euler_1d ) error = 0._R8P do i = 1 , lhs % Ni U_lhs = lhs % U ( i )% array () U_rhs = rhs % U ( i )% array () do v = 1 , size ( U_lhs , dim = 1 ) error = error + ( U_lhs ( v ) - U_rhs ( v )) ** 2 / U_lhs ( v ) ** 2 enddo enddo error = sqrt ( error ) endselect endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by another one. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) * rhs % U ( i ) enddo endselect endselect endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by a real scalar. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs do i = 1 , lhs % Ni opr % U ( i ) = rhs * lhs % U ( i ) enddo endselect endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply a real scalar by an Euler field. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( euler_1d ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = rhs do i = 1 , rhs % Ni opr % U ( i ) = lhs * rhs % U ( i ) enddo endselect endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !< Add two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) + rhs % U ( i ) enddo endselect endselect endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !< Subtract two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) - rhs % U ( i ) enddo endselect endselect endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !< Assign one Euler field to another. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. select type ( rhs ) class is ( euler_1d ) lhs % weno_order = rhs % weno_order lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Dx = rhs % Dx lhs % eos = rhs % eos if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Ni )) select type ( rhs ) class is ( euler_1d ) if ( allocated ( rhs % U )) then do i = 1 , lhs % Ni lhs % U ( i ) = rhs % U ( i ) enddo endif endselect endif if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R if ( allocated ( rhs % interpolator )) then if ( allocated ( lhs % interpolator )) deallocate ( lhs % interpolator ) allocate ( lhs % interpolator , source = rhs % interpolator ) endif if ( associated ( rhs % reconstruct_interfaces )) lhs % reconstruct_interfaces => rhs % reconstruct_interfaces if ( associated ( rhs % riemann_solver )) lhs % riemann_solver => rhs % riemann_solver endselect endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !< Assign one real to an Euler field. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. if ( allocated ( lhs % U )) then do i = 1 , lhs % Ni lhs % U ( i )% density = rhs lhs % U ( i )% momentum = rhs lhs % U ( i )% energy = rhs enddo endif endsubroutine euler_assign_real ! private methods ! pure subroutine impose_boundary_conditions(self, P) pure subroutine impose_boundary_conditions ( self , U ) !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( inout ) :: U ( 1 - self % Ng :) !< Conservative variables. ! type(primitive_compressible), intent(inout) :: P(1-self%Ng:) !< Primitive variables. integer ( I4P ) :: i !< Space counter. select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 ! P(i) = P(-i+1) U ( i ) = U ( - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 ! P(i)%density  =   P(-i+1)%density ! P(i)%velocity = - P(-i+1)%velocity ! P(i)%pressure =   P(-i+1)%pressure U ( i )% density = U ( - i + 1 )% density U ( i )% momentum = - U ( - i + 1 )% momentum U ( i )% energy = U ( - i + 1 )% energy enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i) = P(self%Ni-(i-self%Ni-1)) U ( i ) = U ( self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i)%density  =   P(self%Ni-(i-self%Ni-1))%density ! P(i)%velocity = - P(self%Ni-(i-self%Ni-1))%velocity ! P(i)%pressure =   P(self%Ni-(i-self%Ni-1))%pressure U ( i )% density = U ( self % Ni - ( i - self % Ni - 1 ))% density U ( i )% momentum = - U ( self % Ni - ( i - self % Ni - 1 ))% momentum U ( i )% energy = U ( self % Ni - ( i - self % Ni - 1 ))% energy enddo endselect endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_characteristic ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in pseudo characteristic variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. type ( primitive_compressible ) :: Pm ( 1 : 2 ) !< Mean of primitive variables. real ( R8P ) :: LPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R8P ) :: RPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean right eigenvectors matrix. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. real ( R8P ) :: buffer ( 1 : 3 ) !< Dummy buffer. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 ! compute pseudo charteristic variables do f = 1 , 2 Pm ( f ) = 0.5_R8P * ( primitive ( i + f - 2 ) + primitive ( i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = Pm ( f )% left_eigenvectors ( eos = self % eos ) RPm (:, :, f ) = Pm ( f )% right_eigenvectors ( eos = self % eos ) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , 3 C ( f , j - i , v ) = dot_product ( LPm ( v , :, f ), [ primitive ( j )% density , primitive ( j )% velocity % x , primitive ( j )% pressure ]) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , 3 buffer ( v ) = dot_product ( RPm ( v , :, f ), CR ( f , :)) enddo r_primitive ( f , i )% density = buffer ( 1 ) r_primitive ( f , i )% velocity = buffer ( 2 ) * ex r_primitive ( f , i )% pressure = buffer ( 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_characteristic subroutine reconstruct_interfaces_conservative ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in conservative variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. real ( R8P ), allocatable :: U (:) !< Serialized conservative variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng U = conservative ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = U ( 1 ) C ( f , j - i , 2 ) = U ( 2 ) C ( f , j - i , 3 ) = U ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_conservative ( f , i )% density = CR ( f , 1 ) r_conservative ( f , i )% momentum = CR ( f , 2 ) * ex r_conservative ( f , i )% energy = CR ( f , 3 ) enddo enddo endselect endsubroutine reconstruct_interfaces_conservative subroutine reconstruct_interfaces_primitive ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in primitive variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R8P ), allocatable :: P (:) !< Serialized primitive variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng P = primitive ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = P ( 1 ) C ( f , j - i , 2 ) = P ( 2 ) C ( f , j - i , 3 ) = P ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_primitive ( f , i )% density = CR ( f , 1 ) r_primitive ( f , i )% velocity = CR ( f , 2 ) * ex r_primitive ( f , i )% pressure = CR ( f , 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_primitive subroutine riemann_solver_exact ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of exact (Newton iterative) algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_exact ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_exact subroutine riemann_solver_hllc ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of HLLC algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_hllc ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_hllc subroutine riemann_solver_llf ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of LLF algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_llf subroutine riemann_solver_pvl ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of PVL algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_pvl subroutine riemann_solver_roe ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of Roe algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_roe ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_roe endmodule foreseer_euler_1d program foreseer_test_shock_tube !< FORESEER test: shock tube tester, 1D Euler equation. use flap , only : command_line_interface use foodie , only : tvd_runge_kutta_integrator use foreseer , only : conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible , & eos_compressible use foreseer_euler_1d , only : euler_1d use penf , only : cton , FR8P , I4P , R8P , str use vecfor , only : ex , vector implicit none integer ( I4P ) :: weno_order !< WENO reconstruction order. character ( len = :), allocatable :: weno_variables !< Variables set on which WENO reconstruction is done. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer ( I4P ) :: rk_stages_number !< Runge-Kutta stages number. type ( euler_1d ), allocatable :: rk_stage (:) !< Runge-Kutta stages. real ( R8P ) :: dt !< Time step. real ( R8P ) :: t !< Time. integer ( I4P ) :: step !< Time steps counter. type ( euler_1d ) :: domain !< Domain of Euler equations. real ( R8P ) :: CFL !< CFL value. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I4P ) :: Ni !< Number of grid cells. real ( R8P ) :: Dx !< Space step discretization. real ( R8P ), allocatable :: x (:) !< Cell center x-abscissa values. integer ( I4P ) :: steps_max !< Maximum number of time steps. real ( R8P ) :: t_max !< Maximum integration time. character ( 99 ), allocatable :: riemann_solver_schemes (:) !< Riemann Problem solver scheme(s). character ( 99 ) :: s_scheme !< Space integration scheme. character ( 99 ) :: t_scheme !< Time integration scheme. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I4P ) :: s !< Schemes counter. call parse_command_line_interface do s = 1 , size ( riemann_solver_schemes , dim = 1 ) if ( verbose ) print \"(A)\" , 'Use Riemann Problem solver \"' // trim ( adjustl ( riemann_solver_schemes ( s ))) // '\"' call initialize ( riemann_solver_scheme = riemann_solver_schemes ( s )) call save_time_serie ( filename = 'euler_1D-' // & trim ( adjustl ( s_scheme )) // '-' // & trim ( adjustl ( t_scheme )) // '-' // & trim ( adjustl ( riemann_solver_schemes ( s ))) // '.dat' , t = t ) step = 0 time_loop : do step = step + 1 dt = domain % dt ( steps_max = steps_max , t_max = t_max , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) if ( verbose ) print \"(A)\" , 'step = ' // str ( n = step ) // ', time step = ' // str ( n = dt ) // ', time = ' // str ( n = t ) if (( t == t_max ). or .( step == steps_max )) exit time_loop enddo time_loop enddo contains subroutine initialize ( riemann_solver_scheme ) !< Initialize the test. character ( * ), intent ( in ) :: riemann_solver_scheme !< Riemann Problem solver scheme. type ( primitive_compressible ), allocatable :: initial_state (:) !< Initial state of primitive variables. integer ( I4P ) :: i !< Space counter. if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : rk_stages_number )) call rk_integrator % init ( stages = rk_stages_number ) t = 0._R8P if ( allocated ( x )) deallocate ( x ) ; allocate ( x ( 1 : Ni )) if ( allocated ( initial_state )) deallocate ( initial_state ) ; allocate ( initial_state ( 1 : Ni )) Dx = 1._R8P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 1._R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 1._R8P enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 0.125_R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 0.1_R8P enddo call domain % initialize ( Ni = Ni , Dx = Dx , & BC_L = BC_L , BC_R = BC_R , & initial_state = initial_state , & eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ), & weno_order = weno_order , & weno_variables = weno_variables , & riemann_solver_scheme = riemann_solver_scheme ) endsubroutine initialize subroutine parse_command_line_interface () !< Parse Command Line Interface (CLI). type ( command_line_interface ) :: cli !< Command line interface handler. character ( 99 ) :: riemann_solver_scheme !< Riemann Problem solver scheme. integer ( I4P ) :: error !< Error handler. character ( len = :), allocatable :: buffer !< String buffer. call cli % init ( description = 'FORESEER test: shock tube tester, 1D Euler equations' , & examples = [ \"foreseer_test_shock_tube         \" , & \"foreseer_test_shock_tube --tserie\" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '60' ) call cli % add ( switch = '--t-max' , help = 'Maximum integration time' , required = . false ., act = 'store' , def = '0.' ) call cli % add ( switch = '--riemann' , help = 'Riemann Problem solver' , required = . false ., act = 'store' , def = 'all' , & choices = 'all,exact,hllc,llf,pvl,roe' ) call cli % add ( switch = '--s-scheme' , help = 'Space intergation scheme' , required = . false ., act = 'store' , def = 'weno-char-1' , & choices = 'weno-char-1,weno-char-3,weno-char-5,weno-char-7,weno-char-9,weno-char-11,weno-char-13,weno-char-15,weno-char-17,' // & 'weno-cons-1,weno-cons-3,weno-cons-5,weno-cons-7,weno-cons-9,weno-cons-11,weno-cons-13,weno-cons-15,weno-cons-17,' // & 'weno-prim-1,weno-prim-3,weno-prim-5,weno-prim-7,weno-prim-9,weno-prim-11,weno-prim-13,weno-prim-15,weno-prim-17' ) call cli % add ( switch = '--t-scheme' , help = 'Time intergation scheme' , required = . false ., act = 'store' , def = 'tvd-rk-1' , & choices = 'tvd-rk-1,tvd-rk-2,tvd-rk-3,tvd-rk-5' ) call cli % add ( switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.7' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-max' , val = t_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--riemann' , val = riemann_solver_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--s-scheme' , val = s_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-scheme' , val = t_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--cfl' , val = CFL , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop if ( t_max > 0._R8P ) steps_max = 0 buffer = trim ( adjustl ( s_scheme )) select case ( buffer ( 6 : 9 )) case ( 'char' ) weno_variables = 'characteristic' case ( 'cons' ) weno_variables = 'conservative' case ( 'prim' ) weno_variables = 'primitive' endselect weno_order = cton ( buffer ( 11 :), knd = 1_I4P ) select case ( trim ( adjustl ( t_scheme ))) case ( 'tvd-rk-1' ) rk_stages_number = 1 case ( 'tvd-rk-2' ) rk_stages_number = 2 case ( 'tvd-rk-3' ) rk_stages_number = 3 case ( 'tvd-rk-5' ) rk_stages_number = 5 endselect if ( trim ( adjustl ( riemann_solver_scheme )) == 'all' ) then riemann_solver_schemes = [ 'exact' , 'hllc ' , 'llf  ' , 'pvl  ' , 'roe  ' ] else riemann_solver_schemes = [ trim ( adjustl ( riemann_solver_scheme ))] endif endsubroutine parse_command_line_interface subroutine save_time_serie ( filename , finish , t ) !< Save time-serie results. character ( * ), intent ( in ), optional :: filename !< Output filename. logical , intent ( in ), optional :: finish !< Flag for triggering the file closing. real ( R8P ), intent ( in ) :: t !< Current integration time. integer ( I4P ), save :: tsfile !< File unit for saving time serie results. type ( primitive_compressible ) :: primitive !< Primitive variables. integer ( I4P ) :: i !< Counter. if ( time_serie ) then if ( present ( filename )) then open ( newunit = tsfile , file = filename ) endif write ( tsfile , '(A)' ) 'VARIABLES = \"x\" \"rho\" \"u\" \"p\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni primitive = conservative_to_primitive_compressible ( conservative = domain % U ( i ), eos = domain % eos ) write ( tsfile , '(4' // '(' // FR8P // ',1X))' ) x ( i ), primitive % density , primitive % velocity % x , primitive % pressure enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif endsubroutine save_time_serie endprogram foreseer_test_shock_tube","tags":"","loc":"sourcefile/foreseer_test_shock_tube.f90.html","title":"foreseer_test_shock_tube.f90 – FORESEER"},{"text":"type, public, extends( conservative_object ) :: conservative_compressible type~~conservative_compressible~~InheritsGraph type~conservative_compressible conservative_compressible vector vector vector->type~conservative_compressible momentum type~conservative_object conservative_object type~conservative_object->type~conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Convervative compressible object class. Inherited By type~~conservative_compressible~~InheritedByGraph type~conservative_compressible conservative_compressible type~euler_1d euler_1d type~conservative_compressible->type~euler_1d U Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables density energy momentum Constructor conservative_compressible Type-Bound Procedures add array assignment(=) compute_fluxes compute_fluxes_from_primitive cons_assign_cons cons_divide_real cons_multiply_cons cons_multiply_real description destroy initialize negative operator(*) operator(+) operator(-) operator(/) positive pressure real_multiply_cons sub velocity Source Code conservative_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: energy = 0._R8P Energy, rho * E , rho being the density and E the specific energy. type(vector), public :: momentum Momentum, rho * v , rho being the density and v the velocity vector. Constructor public interface conservative_compressible Overload conservative_compressible name with its constructor. private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array Return serialized array of conservative. private pure function array (self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: compute_fluxes Compute conservative fluxes. private subroutine compute_fluxes (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. procedure, public, pass(self) :: compute_fluxes_from_primitive Compute conservative fluxes from primitives at interface. private elemental subroutine compute_fluxes_from_primitive (self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(lhs) :: cons_assign_cons Operator = . private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: cons_divide_real Operator cons / real . private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: cons_multiply_cons Operator * . private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: cons_multiply_real Operator cons * real . private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy conservative. private elemental subroutine destroy (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. procedure, public, pass(self) :: initialize Initialize conservative. private subroutine initialize (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. procedure, public, pass(self) :: negative Unary operator - cons . private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(*) => cons_multiply_cons , cons_multiply_real , real_multiply_cons Overload * . private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(/) => cons_divide_real Overload / . private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: positive Unary operator + cons . private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: pressure Return pressure value. private elemental function pressure (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. procedure, public, pass(rhs) :: real_multiply_cons Operator real * cons . private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub Operator - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure, public, pass(self) :: velocity Return velocity vector. private elemental function velocity (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code type , extends ( conservative_object ) :: conservative_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ) :: energy = 0._R8P !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. contains ! public methods procedure , pass ( self ) :: compute_fluxes_from_primitive !< Compute conservative fluxes from primitives at interface. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of conservative. procedure , pass ( self ) :: compute_fluxes !< Compute conservative fluxes. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy conservative. procedure , pass ( self ) :: initialize !< Initialize conservative. procedure , pass ( self ) :: pressure !< Return pressure value. procedure , pass ( self ) :: velocity !< Return velocity vector. procedure , pass ( lhs ) :: cons_assign_cons !< Operator `=`. procedure , pass ( lhs ) :: cons_divide_real !< Operator `cons / real`. procedure , pass ( lhs ) :: cons_multiply_real !< Operator `cons * real`. procedure , pass ( lhs ) :: cons_multiply_cons !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_cons !< Operator `real * cons`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ cons`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- cons`. endtype conservative_compressible","tags":"","loc":"type/conservative_compressible.html","title":"conservative_compressible – FORESEER "},{"text":"type, public, abstract :: conservative_object Convervative object class. Inherited By type~~conservative_object~~InheritedByGraph type~conservative_object conservative_object type~conservative_compressible conservative_compressible type~conservative_object->type~conservative_compressible type~euler_1d euler_1d type~conservative_compressible->type~euler_1d U Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures add array assignment(=) compute_fluxes cons_assign_cons cons_divide_real cons_multiply_cons cons_multiply_real description destroy initialize negative operator(*) operator(+) operator(-) operator(/) positive pressure real_multiply_cons sub velocity Source Code conservative_object Type-Bound Procedures procedure( symmetric_operator ), public, deferred, pass(lhs) :: add Operator + . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( array_interface ), public, deferred, pass(self) :: array Return serialized array of conservative. pure function array_interface (self) result(array_) Prototype Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure( compute_fluxes_interface ), public, deferred, pass(self) :: compute_fluxes Compute conservative fluxes. subroutine compute_fluxes_interface (self, eos, normal, fluxes) Prototype Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. procedure( assignment_interface ), public, deferred, pass(lhs) :: cons_assign_cons Operator = . pure subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. procedure( cons_operator_real ), public, deferred, pass(lhs) :: cons_divide_real Operator cons / real . function cons_operator_real (lhs, rhs) result(operator_result) Prototype Operator cons.op.real . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: cons_multiply_cons Operator * . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( cons_operator_real ), public, deferred, pass(lhs) :: cons_multiply_real Operator cons * real . function cons_operator_real (lhs, rhs) result(operator_result) Prototype Operator cons.op.real . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy conservative. elemental subroutine destroy_interface (self) Prototype Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize conservative. subroutine initialize_interface (self, initial_state) Prototype Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. procedure( unary_operator ), public, deferred, pass(self) :: negative Unary operator - cons . function unary_operator (self) result(operator_result) Prototype Unary operator .op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(*) => cons_multiply_cons , cons_multiply_real , real_multiply_cons Overload * . private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. generic, public :: operator(/) => cons_divide_real Overload / . private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( unary_operator ), public, deferred, pass(self) :: positive Unary operator + cons . function unary_operator (self) result(operator_result) Prototype Unary operator .op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( pressure_interface ), public, deferred, pass(self) :: pressure Return pressure value. elemental function pressure_interface (self, eos) result(pressure_) Prototype Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. procedure( real_operator_cons ), public, deferred, pass(rhs) :: real_multiply_cons Operator real * cons . function real_operator_cons (lhs, rhs) result(operator_result) Prototype Operator real.op.cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: sub Operator - . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. procedure( velocity_interface ), public, deferred, pass(self) :: velocity Return velocity vector. elemental function velocity_interface (self) result(velocity_) Prototype Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code type , abstract :: conservative_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of conservative. procedure ( compute_fluxes_interface ), pass ( self ), deferred :: compute_fluxes !< Compute conservative fluxes. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy conservative. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize conservative. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure value. procedure ( velocity_interface ), pass ( self ), deferred :: velocity !< Return velocity vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: cons_assign_cons !< Operator `=`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_divide_real !< Operator `cons / real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: cons_multiply_cons !< Operator `*`. procedure ( cons_operator_real ), pass ( lhs ), deferred :: cons_multiply_real !< Operator `cons * real`. procedure ( real_operator_cons ), pass ( rhs ), deferred :: real_multiply_cons !< Operator `real * cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ cons`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- cons`. ! operators generic :: assignment ( = ) => cons_assign_cons !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => cons_multiply_cons , cons_multiply_real , real_multiply_cons !< Overload `*`. generic :: operator ( / ) => cons_divide_real !< Overload `/`. endtype conservative_object","tags":"","loc":"type/conservative_object.html","title":"conservative_object – FORESEER "},{"text":"type, public, extends( eos_object ) :: eos_compressible type~~eos_compressible~~InheritsGraph type~eos_compressible eos_compressible type~eos_object eos_object type~eos_object->type~eos_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Equation of state (EOS) of ideal compressible object class. Inherited By type~~eos_compressible~~InheritedByGraph type~eos_compressible eos_compressible type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~euler_1d euler_1d type~eos_compressible->type~euler_1d eos type~riemann_solver_compressible_roe riemann_solver_compressible_roe type~eos_compressible->type~riemann_solver_compressible_roe eos_1, eos_4 type~riemann_solver_compressible_hllc riemann_solver_compressible_hllc type~eos_compressible->type~riemann_solver_compressible_hllc eos_1, eos_4 type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~eos_compressible->type~riemann_solver_compressible_llf eos_1, eos_4 type~riemann_solver_compressible_exact riemann_solver_compressible_exact type~eos_compressible->type~riemann_solver_compressible_exact eos_1, eos_4 type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~eos_compressible->type~riemann_solver_compressible_pvl eos_1, eos_4 type~riemann_solver_compressible_object->type~riemann_solver_compressible_roe type~riemann_solver_compressible_object->type~riemann_solver_compressible_hllc type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_exact type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_roe solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_hllc solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl var pantypeeos_compressibleInheritedByGraph = svgPanZoom('#typeeos_compressibleInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables R_ cp_ cv_ delta_ eta_ g_ gm1_ gp1_ Constructor eos_compressible Type-Bound Procedures R assignment(=) compute_derivate cp cv delta density description energy eos_assign_eos eta g gm1 gp1 pressure speed_of_sound temperature Source Code eos_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), public :: R_ = 0._R8P Fluid constant R = cp - cv . real(kind=R8P), public :: cp_ = 0._R8P Specific heat at constant pressure cp . real(kind=R8P), public :: cv_ = 0._R8P Specific heat at constant volume cv . real(kind=R8P), public :: delta_ = 0._R8P (gamma - 1) / 2 . real(kind=R8P), public :: eta_ = 0._R8P 2 * gamma / (gamma - 1) . real(kind=R8P), public :: g_ = 0._R8P Specific heats ratio gamma = cp / cv . real(kind=R8P), public :: gm1_ = 0._R8P gamma - 1 . real(kind=R8P), public :: gp1_ = 0._R8P gamma + 1 . Constructor public interface eos_compressible Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Type-Bound Procedures procedure, public, pass(self) :: R Return fluid constant R=cp-cv . private elemental function R (self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. generic, public :: assignment(=) => eos_assign_eos Overload = . private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: compute_derivate Compute derivate quantities (from cp and cv ). private elemental subroutine compute_derivate (self) Compute derivate quantities (from cp and cv ). Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: self Equation of state. procedure, public, pass(self) :: cp Return specific heat at constant pressure. private elemental function cp (self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. procedure, public, pass(self) :: cv Return specific heat at constant volume. private elemental function cv (self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. procedure, public, pass(self) :: delta Return (gamma - 1) / 2 . private elemental function delta (self) result(delta_) Return (gamma - 1) / 2 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) (gamma - 1) / 2 value. procedure, public, pass(self) :: density Return density. private elemental function density (self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: energy Return specific internal energy. private elemental function energy (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. procedure, public, pass(lhs) :: eos_assign_eos Operator = . private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: eta Return 2 * gamma / (gamma - 1) . private elemental function eta (self) result(eta_) Return 2 * gamma / (gamma - 1) . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) 2 * gamma / (gamma - 1) value. procedure, public, pass(self) :: g Return specific heats ratio gamma=cp/cv . private elemental function g (self) result(g_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. procedure, public, pass(self) :: gm1 Return gamma - 1 . private elemental function gm1 (self) result(gm1_) Return gamma - 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma - 1 value. procedure, public, pass(self) :: gp1 Return gamma + 1 . private elemental function gp1 (self) result(gp1_) Return gamma + 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma + 1 value. procedure, public, pass(self) :: pressure Return pressure. private elemental function pressure (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. procedure, public, pass(self) :: speed_of_sound Return speed of sound. private elemental function speed_of_sound (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. procedure, public, pass(self) :: temperature Return temperature. private elemental function temperature (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Source Code type , extends ( eos_object ) :: eos_compressible !< Equation of state (EOS) of ideal compressible object class. real ( R8P ) :: cp_ = 0._R8P !< Specific heat at constant pressure `cp`. real ( R8P ) :: cv_ = 0._R8P !< Specific heat at constant volume `cv`. real ( R8P ) :: g_ = 0._R8P !< Specific heats ratio `gamma = cp / cv`. real ( R8P ) :: R_ = 0._R8P !< Fluid constant `R = cp - cv`. real ( R8P ) :: gm1_ = 0._R8P !< `gamma - 1`. real ( R8P ) :: gp1_ = 0._R8P !< `gamma + 1`. real ( R8P ) :: delta_ = 0._R8P !< `(gamma - 1) / 2`. real ( R8P ) :: eta_ = 0._R8P !< `2 * gamma / (gamma - 1)`. contains ! public methods procedure , pass ( self ) :: compute_derivate !< Compute derivate quantities (from `cp` and `cv`). ! deferred methods procedure , pass ( self ) :: cp !< Return specific heat at constant pressure. procedure , pass ( self ) :: cv !< Return specific heat at constant volume. procedure , pass ( self ) :: delta !< Return `(gamma - 1) / 2`. procedure , pass ( self ) :: density !< Return density. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: energy !< Return specific internal energy. procedure , pass ( lhs ) :: eos_assign_eos !< Operator `=`. procedure , pass ( self ) :: eta !< Return `2 * gamma / (gamma - 1)`. procedure , pass ( self ) :: g !< Return specific heats ratio `gamma=cp/cv`. procedure , pass ( self ) :: gm1 !< Return `gamma - 1`. procedure , pass ( self ) :: gp1 !< Return `gamma + 1`. procedure , pass ( self ) :: pressure !< Return pressure. procedure , pass ( self ) :: R !< Return fluid constant `R=cp-cv`. procedure , pass ( self ) :: speed_of_sound !< Return speed of sound. procedure , pass ( self ) :: temperature !< Return temperature. endtype eos_compressible","tags":"","loc":"type/eos_compressible.html","title":"eos_compressible – FORESEER "},{"text":"type, public, abstract :: eos_object Equation of State (EOS) object class. Inherited By type~~eos_object~~InheritedByGraph type~eos_object eos_object type~eos_compressible eos_compressible type~eos_object->type~eos_compressible type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~euler_1d euler_1d type~eos_compressible->type~euler_1d eos type~riemann_solver_compressible_roe riemann_solver_compressible_roe type~eos_compressible->type~riemann_solver_compressible_roe eos_1, eos_4 type~riemann_solver_compressible_hllc riemann_solver_compressible_hllc type~eos_compressible->type~riemann_solver_compressible_hllc eos_1, eos_4 type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~eos_compressible->type~riemann_solver_compressible_llf eos_1, eos_4 type~riemann_solver_compressible_exact riemann_solver_compressible_exact type~eos_compressible->type~riemann_solver_compressible_exact eos_1, eos_4 type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~eos_compressible->type~riemann_solver_compressible_pvl eos_1, eos_4 type~riemann_solver_compressible_object->type~riemann_solver_compressible_roe type~riemann_solver_compressible_object->type~riemann_solver_compressible_hllc type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_exact type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_roe solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_hllc solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl var pantypeeos_objectInheritedByGraph = svgPanZoom('#typeeos_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures R assignment(=) cp cv delta density description energy eos_assign_eos eta g gm1 gp1 pressure speed_of_sound temperature Source Code eos_object Type-Bound Procedures procedure( scalar_interface ), public, deferred, pass(self) :: R Return fluid constant R=cp-cv . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. generic, public :: assignment(=) => eos_assign_eos Overload = . private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure( scalar_interface ), public, deferred, pass(self) :: cp Return specific heat at constant pressure. elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: cv Return specific heat at constant volume. elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: delta Return (gamma - 1) / 2 . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( density_interface ), public, deferred, pass(self) :: density Return density. elemental function density_interface (self, energy, pressure, speed_of_sound, temperature) result(density_) Prototype Return density. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( energy_interface ), public, deferred, pass(self) :: energy Return specific internal energy. elemental function energy_interface (self, density, pressure, temperature) result(energy_) Prototype Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. procedure( assignment_interface ), public, deferred, pass(lhs) :: eos_assign_eos Operator = . pure subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure( scalar_interface ), public, deferred, pass(self) :: eta Return 2 * gamma / (gamma - 1) . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: g Return specific heats ratio gamma=cp/cv . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: gm1 Return gamma - 1 . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: gp1 Return gamma + 1 . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( pressure_interface ), public, deferred, pass(self) :: pressure Return pressure. elemental function pressure_interface (self, density, energy, temperature) result(pressure_) Prototype Return pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. procedure( speed_of_sound_interface ), public, deferred, pass(self) :: speed_of_sound Return speed of sound. elemental function speed_of_sound_interface (self, density, pressure) result(speed_of_sound_) Prototype Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. procedure( temperature_interface ), public, deferred, pass(self) :: temperature Return temperature. elemental function temperature_interface (self, density, energy, pressure) result(temperature_) Prototype Return temperature. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Source Code type , abstract :: eos_object !< Equation of State (EOS) object class. contains ! deferred methods procedure ( scalar_interface ), pass ( self ), deferred :: cp !< Return specific heat at constant pressure. procedure ( scalar_interface ), pass ( self ), deferred :: cv !< Return specific heat at constant volume. procedure ( density_interface ), pass ( self ), deferred :: density !< Return density. procedure ( scalar_interface ), pass ( self ), deferred :: delta !< Return `(gamma - 1) / 2`. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return specific internal energy. procedure ( assignment_interface ), pass ( lhs ), deferred :: eos_assign_eos !< Operator `=`. procedure ( scalar_interface ), pass ( self ), deferred :: eta !< Return `2 * gamma / (gamma - 1)`. procedure ( scalar_interface ), pass ( self ), deferred :: g !< Return specific heats ratio `gamma=cp/cv`. procedure ( scalar_interface ), pass ( self ), deferred :: gm1 !< Return `gamma - 1`. procedure ( scalar_interface ), pass ( self ), deferred :: gp1 !< Return `gamma + 1`. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure. procedure ( scalar_interface ), pass ( self ), deferred :: R !< Return fluid constant `R=cp-cv`. procedure ( speed_of_sound_interface ), pass ( self ), deferred :: speed_of_sound !< Return speed of sound. procedure ( temperature_interface ), pass ( self ), deferred :: temperature !< Return temperature. ! operators generic :: assignment ( = ) => eos_assign_eos !< Overload `=`. endtype eos_object","tags":"","loc":"type/eos_object.html","title":"eos_object – FORESEER "},{"text":"type, public, extends( primitive_object ) :: primitive_compressible type~~primitive_compressible~~InheritsGraph type~primitive_compressible primitive_compressible vector vector vector->type~primitive_compressible velocity type~primitive_object primitive_object type~primitive_object->type~primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Convervative compressible object class. Variables density pressure velocity Constructor primitive_compressible Type-Bound Procedures add array assignment(=) description destroy energy initialize left_eigenvectors momentum negative operator(*) operator(+) operator(-) operator(/) positive prim_assign_prim prim_divide_real prim_multiply_prim prim_multiply_real real_multiply_prim right_eigenvectors sub Source Code primitive_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor public interface primitive_compressible Overload primitive_compressible name with its constructor. private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array Return serialized array of primitive. private pure function array (self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy primitive. private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. procedure, public, pass(self) :: energy Return energy value. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. procedure, public, pass(self) :: initialize Initialize primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. procedure, public, pass(self) :: left_eigenvectors Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . private pure function left_eigenvectors (self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. procedure, public, pass(self) :: momentum Return momentum vector. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. procedure, public, pass(self) :: negative Unary operator - prim . private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(*) => prim_multiply_prim , prim_multiply_real , real_multiply_prim Overload * . private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(/) => prim_divide_real Overload / . private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(self) :: positive Unary operator + prim . private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: prim_assign_prim Operator = . private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: prim_divide_real Operator prim / real . private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: prim_multiply_prim Operator * . private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: prim_multiply_real Operator prim * real . private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_multiply_prim Operator real * prim . private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure, public, pass(self) :: right_eigenvectors Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . private pure function right_eigenvectors (self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. procedure, public, pass(lhs) :: sub Operator - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code type , extends ( primitive_object ) :: primitive_compressible !< Convervative compressible object class. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. contains ! public methods procedure , pass ( self ) :: left_eigenvectors !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. procedure , pass ( self ) :: right_eigenvectors !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of primitive. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. procedure , pass ( lhs ) :: prim_assign_prim !< Operator `=`. procedure , pass ( lhs ) :: prim_divide_real !< Operator `prim / real`. procedure , pass ( lhs ) :: prim_multiply_real !< Operator `prim * real`. procedure , pass ( lhs ) :: prim_multiply_prim !< Operator `*`. procedure , pass ( rhs ) :: real_multiply_prim !< Operator `real * prim`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( self ) :: positive !< Unary operator `+ prim`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( self ) :: negative !< Unary operator `- prim`. endtype primitive_compressible","tags":"","loc":"type/primitive_compressible.html","title":"primitive_compressible – FORESEER "},{"text":"type, public, abstract :: primitive_object Convervative object class. Inherited By type~~primitive_object~~InheritedByGraph type~primitive_object primitive_object type~primitive_compressible primitive_compressible type~primitive_object->type~primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures add array assignment(=) description destroy energy initialize momentum negative operator(*) operator(+) operator(-) operator(/) positive prim_assign_prim prim_divide_real prim_multiply_prim prim_multiply_real real_multiply_prim sub Source Code primitive_object Type-Bound Procedures procedure( symmetric_operator ), public, deferred, pass(lhs) :: add Operator + . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( array_interface ), public, deferred, pass(self) :: array Return serialized array of primitive. pure function array_interface (self) result(array_) Prototype Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy primitive. elemental subroutine destroy_interface (self) Prototype Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. procedure( energy_interface ), public, deferred, pass(self) :: energy Return energy value. elemental function energy_interface (self, eos) result(energy_) Prototype Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize primitive. subroutine initialize_interface (self, initial_state) Prototype Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. procedure( momentum_interface ), public, deferred, pass(self) :: momentum Return momentum vector. elemental function momentum_interface (self) result(momentum_) Prototype Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. procedure( unary_operator ), public, deferred, pass(self) :: negative Unary operator - prim . function unary_operator (self) result(operator_result) Prototype Unary operator .op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(*) => prim_multiply_prim , prim_multiply_real , real_multiply_prim Overload * . private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Overload + . private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Overload - . private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. generic, public :: operator(/) => prim_divide_real Overload / . private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( unary_operator ), public, deferred, pass(self) :: positive Unary operator + prim . function unary_operator (self) result(operator_result) Prototype Unary operator .op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( assignment_interface ), public, deferred, pass(lhs) :: prim_assign_prim Operator = . pure subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. procedure( prim_operator_real ), public, deferred, pass(lhs) :: prim_divide_real Operator prim / real . function prim_operator_real (lhs, rhs) result(operator_result) Prototype Operator prim.op.real . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: prim_multiply_prim Operator * . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( prim_operator_real ), public, deferred, pass(lhs) :: prim_multiply_real Operator prim * real . function prim_operator_real (lhs, rhs) result(operator_result) Prototype Operator prim.op.real . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( real_operator_prim ), public, deferred, pass(rhs) :: real_multiply_prim Operator real * prim . function real_operator_prim (lhs, rhs) result(operator_result) Prototype Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. procedure( symmetric_operator ), public, deferred, pass(lhs) :: sub Operator - . function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code type , abstract :: primitive_object !< Convervative object class. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of primitive. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy primitive. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return energy value. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize primitive. procedure ( momentum_interface ), pass ( self ), deferred :: momentum !< Return momentum vector. procedure ( assignment_interface ), pass ( lhs ), deferred :: prim_assign_prim !< Operator `=`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_divide_real !< Operator `prim / real`. procedure ( prim_operator_real ), pass ( lhs ), deferred :: prim_multiply_real !< Operator `prim * real`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: prim_multiply_prim !< Operator `*`. procedure ( real_operator_prim ), pass ( rhs ), deferred :: real_multiply_prim !< Operator `real * prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ prim`. procedure ( symmetric_operator ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- prim`. ! operators generic :: assignment ( = ) => prim_assign_prim !< Overload `=`. generic :: operator ( + ) => add , positive !< Overload `+`. generic :: operator ( - ) => sub , negative !< Overload `-`. generic :: operator ( * ) => prim_multiply_prim , prim_multiply_real , real_multiply_prim !< Overload `*`. generic :: operator ( / ) => prim_divide_real !< Overload `/`. endtype primitive_object","tags":"","loc":"type/primitive_object.html","title":"primitive_object – FORESEER "},{"text":"type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_exact type~~riemann_solver_compressible_exact~~InheritsGraph type~riemann_solver_compressible_exact riemann_solver_compressible_exact type~eos_compressible eos_compressible type~eos_compressible->type~riemann_solver_compressible_exact eos_1, eos_4 type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~eos_object eos_object type~eos_object->type~eos_compressible type~riemann_solver_compressible_object->type~riemann_solver_compressible_exact type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object var pantyperiemann_solver_compressible_exactInheritsGraph = svgPanZoom('#typeriemann_solver_compressible_exactInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Exact (Newton-iterative) Riemann Solver. Note This is the implemention for conservative_compressible Riemann states. Variables a_1 a_2 a_3 a_4 eos_1 eos_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 tolerance u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_states23_from_u23 compute_waves description initialize set_states14 solve Source Code riemann_solver_compressible_exact Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. real(kind=R8P), public :: tolerance = 1.e-10_R8P Tolerance on Newton convergence. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . private elemental subroutine compute_states23_from_u23 (self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. procedure, public, pass(self) :: compute_waves Compute waves pattern. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: initialize Initialize solver. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: solve Solve Riemann Problem. private pure subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_exact !< Exact (Newton-iterative) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. real ( R8P ) :: tolerance = 1.e-10_R8P !< Tolerance on Newton convergence. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_exact","tags":"","loc":"type/riemann_solver_compressible_exact.html","title":"riemann_solver_compressible_exact – FORESEER "},{"text":"type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_hllc type~~riemann_solver_compressible_hllc~~InheritsGraph type~riemann_solver_compressible_hllc riemann_solver_compressible_hllc type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_hllc solver_pvl type~eos_compressible eos_compressible type~eos_compressible->type~riemann_solver_compressible_hllc eos_1, eos_4 type~eos_compressible->type~riemann_solver_compressible_pvl eos_1, eos_4 type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~riemann_solver_compressible_object->type~riemann_solver_compressible_hllc type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object type~eos_object eos_object type~eos_object->type~eos_compressible var pantyperiemann_solver_compressible_hllcInheritsGraph = svgPanZoom('#typeriemann_solver_compressible_hllcInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). HLLC (Harten, Lax, Van Leer, Toro) Riemann Solver. Note This is the implemention for conservative_compressible Riemann states. Variables a_1 a_2 a_3 a_4 eos_1 eos_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 solver_pvl u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_states23_from_u23 compute_waves description initialize set_states14 solve Source Code riemann_solver_compressible_hllc Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . private elemental subroutine compute_states23_from_u23 (self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. procedure, public, pass(self) :: compute_waves Compute waves pattern. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: initialize Initialize solver. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: solve Solve Riemann Problem. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_hllc !< HLLC (Harten, Lax, Van Leer, Toro) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_hllc","tags":"","loc":"type/riemann_solver_compressible_hllc.html","title":"riemann_solver_compressible_hllc – FORESEER "},{"text":"type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf type~~riemann_solver_compressible_llf~~InheritsGraph type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl type~eos_compressible eos_compressible type~eos_compressible->type~riemann_solver_compressible_llf eos_1, eos_4 type~eos_compressible->type~riemann_solver_compressible_pvl eos_1, eos_4 type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object type~eos_object eos_object type~eos_object->type~eos_compressible var pantyperiemann_solver_compressible_llfInheritsGraph = svgPanZoom('#typeriemann_solver_compressible_llfInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. Note This is the implemention for conservative_compressible Riemann states. Variables a_1 a_2 a_3 a_4 eos_1 eos_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 solver_pvl u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_states23_from_u23 compute_waves description initialize set_states14 solve Source Code riemann_solver_compressible_llf Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . private elemental subroutine compute_states23_from_u23 (self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. procedure, public, pass(self) :: compute_waves Compute waves pattern. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: initialize Initialize solver. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: solve Solve Riemann Problem. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf !< Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. endtype riemann_solver_compressible_llf","tags":"","loc":"type/riemann_solver_compressible_llf.html","title":"riemann_solver_compressible_llf – FORESEER "},{"text":"type, public, abstract, extends( riemann_solver_object ) :: riemann_solver_compressible_object type~~riemann_solver_compressible_object~~InheritsGraph type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible eos_compressible type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~eos_object eos_object type~eos_object->type~eos_compressible type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Riemann solver for ideal compressible fluid object class. The ideal compressible fluid generates a 3-waves pattern: 2 genuinely non-linear acoustic waves and 1\n linear-degener contact discontinuity. t &#94;                                .\n     |     S1 _       S2 _            .      _ S=u23   _ S3       _ S4\n     |       |\\_        |\\_           .      /|      __/|       __/|\n     |          \\__        \\_     U2  .     /  U3  _/       ___/\n     |             \\___      \\_       .    /    __/     ___/\n     |                 \\____   \\_     .   /   _/    ___/\n     |                      \\___ \\_   .  / __/  ___/\n     |          UL=U1           \\__\\_ . /_/____/          UR=U4\n     |                              \\\\.///\n  ---+--------------------------------o--------------------------------->\n     |                                xo                                x Inherited By type~~riemann_solver_compressible_object~~InheritedByGraph type~riemann_solver_compressible_object riemann_solver_compressible_object type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_exact riemann_solver_compressible_exact type~riemann_solver_compressible_object->type~riemann_solver_compressible_exact type~riemann_solver_compressible_roe riemann_solver_compressible_roe type~riemann_solver_compressible_object->type~riemann_solver_compressible_roe type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_compressible_hllc riemann_solver_compressible_hllc type~riemann_solver_compressible_object->type~riemann_solver_compressible_hllc type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_roe solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_hllc solver_pvl var pantyperiemann_solver_compressible_objectInheritedByGraph = svgPanZoom('#typeriemann_solver_compressible_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables a_1 a_2 a_3 a_4 eos_1 eos_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_states23_from_u23 compute_waves description initialize set_states14 solve Source Code riemann_solver_compressible_object Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . private elemental subroutine compute_states23_from_u23 (self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. procedure( compute_waves_interface ), public, deferred, pass(self) :: compute_waves Compute waves pattern. pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Prototype Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize solver. subroutine initialize_interface (self, config) Prototype Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure( solve_interface ), public, deferred, pass(self) :: solve Solve Riemann Problem. subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Prototype Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_object ), abstract :: riemann_solver_compressible_object !< Riemann solver for ideal compressible fluid object class. !< !< The ideal compressible fluid generates a 3-waves pattern: 2 genuinely non-linear acoustic waves and 1 !< linear-degener contact discontinuity. !< !<``` !<   t &#94;                                . !<     |     S1 _       S2 _            .      _ S=u23   _ S3       _ S4 !<     |       |\\_        |\\_           .      /|      __/|       __/| !<     |          \\__        \\_     U2  .     /  U3  _/       ___/ !<     |             \\___      \\_       .    /    __/     ___/ !<     |                 \\____   \\_     .   /   _/    ___/ !<     |                      \\___ \\_   .  / __/  ___/ !<     |          UL=U1           \\__\\_ . /_/____/          UR=U4 !<     |                              \\\\./// !<  ---+--------------------------------o---------------------------------> !<     |                                xo                                x !<``` type ( eos_compressible ) :: eos_1 !< Equation of state 1. real ( R8P ) :: r_1 = 0._R8P !< Density of state 1. real ( R8P ) :: u_1 = 0._R8P !< Velocity (normal) of state 1. real ( R8P ) :: p_1 = 0._R8P !< Pressure of state 1. real ( R8P ) :: a_1 = 0._R8P !< Speed of sound of state 1. type ( eos_compressible ) :: eos_4 !< Equation of state 4. real ( R8P ) :: r_4 = 0._R8P !< Density of state 4. real ( R8P ) :: u_4 = 0._R8P !< Velocity (normal) of state 4. real ( R8P ) :: p_4 = 0._R8P !< Pressure of state 4. real ( R8P ) :: a_4 = 0._R8P !< Speed of sound of state 4. real ( R8P ) :: u23 = 0._R8P !< Velocity (normal) of intermediate states. real ( R8P ) :: p23 = 0._R8P !< Pressure of intermediate states. real ( R8P ) :: r_2 = 0._R8P !< Density of state 2. real ( R8P ) :: a_2 = 0._R8P !< Speed of sound of state 2. real ( R8P ) :: r_3 = 0._R8P !< Density of state 3. real ( R8P ) :: a_3 = 0._R8P !< Speed of sound of state 3. real ( R8P ) :: s_1 = 0._R8P !< Left-front of left wave. real ( R8P ) :: s_2 = 0._R8P !< Right-front of left wave. real ( R8P ) :: s_3 = 0._R8P !< Left-front of right wave. real ( R8P ) :: s_4 = 0._R8P !< Right-front of right wave. contains ! deferred methods procedure , pass ( self ) :: description !< Return pretty-printed object description. ! public methods procedure , pass ( self ) :: compute_fluxes !< Compute fluxes at interface `x=xo`. procedure , pass ( self ) :: compute_states23_from_u23 !< Compute interstates 2 and 3 given veloctiy `S=u23`. procedure , pass ( self ) :: set_states14 !< Set states 1 and 4. endtype riemann_solver_compressible_object","tags":"","loc":"type/riemann_solver_compressible_object.html","title":"riemann_solver_compressible_object – FORESEER "},{"text":"type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl type~~riemann_solver_compressible_pvl~~InheritsGraph type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~eos_compressible eos_compressible type~eos_compressible->type~riemann_solver_compressible_pvl eos_1, eos_4 type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~eos_object eos_object type~eos_object->type~eos_compressible type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object var pantyperiemann_solver_compressible_pvlInheritsGraph = svgPanZoom('#typeriemann_solver_compressible_pvlInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Primitive Variables Linearization based Riemann solver. Note This is the implemention for conservative_compressible Riemann states. Inherited By type~~riemann_solver_compressible_pvl~~InheritedByGraph type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_roe riemann_solver_compressible_roe type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_roe solver_pvl type~riemann_solver_compressible_hllc riemann_solver_compressible_hllc type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_hllc solver_pvl type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables a_1 a_2 a_3 a_4 compute_waves_ eos_1 eos_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 solve_ u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_states23_from_u23 compute_u23 compute_up23 compute_waves compute_waves_u23 compute_waves_up23 description initialize set_states14 solve solve_u23 solve_up23 Source Code riemann_solver_compressible_pvl Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. procedure( compute_waves_interface ), public, pointer :: compute_waves_ => compute_waves_up23 Compute waves pattern type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. procedure( solve_interface ), public, pointer :: solve_ => solve_up23 Solve Riemann problem. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . private elemental subroutine compute_states23_from_u23 (self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. procedure, private, pass(self) :: compute_u23 Compute interstates velocity. private elemental subroutine compute_u23 (self) Compute interstates velocity. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. procedure, private, pass(self) :: compute_up23 Compute interstates velocity and pressure. private elemental subroutine compute_up23 (self) Compute interstates velocity and pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. procedure, public, pass(self) :: compute_waves Compute waves pattern. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, private, pass(self) :: compute_waves_u23 Compute waves speed by u23 algorithm. private pure subroutine compute_waves_u23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, private, pass(self) :: compute_waves_up23 Compute waves speed by up23 algorithm. private pure subroutine compute_waves_up23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: initialize Initialize solver. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: solve Solve Riemann Problem. private pure subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: solve_u23 Compute whole pattern by u23 algorithm. private pure subroutine solve_u23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem by u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: solve_up23 Compute whole pattern by up23 algorithm. private pure subroutine solve_up23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem up23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Riemann pattern. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl !< Primitive Variables Linearization based Riemann solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. procedure ( compute_waves_interface ), pointer :: compute_waves_ => compute_waves_up23 !< Compute waves pattern procedure ( solve_interface ), pointer :: solve_ => solve_up23 !< Solve Riemann problem. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. ! private methods procedure , pass ( self ), private :: compute_u23 !< Compute interstates velocity. procedure , pass ( self ), private :: compute_up23 !< Compute interstates velocity and pressure. procedure , pass ( self ), private :: compute_waves_u23 !< Compute waves speed by `u23` algorithm. procedure , pass ( self ), private :: compute_waves_up23 !< Compute waves speed by `up23` algorithm. procedure , pass ( self ), private :: solve_u23 !< Compute whole pattern by `u23` algorithm. procedure , pass ( self ), private :: solve_up23 !< Compute whole pattern by `up23` algorithm. endtype riemann_solver_compressible_pvl","tags":"","loc":"type/riemann_solver_compressible_pvl.html","title":"riemann_solver_compressible_pvl – FORESEER "},{"text":"type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_roe type~~riemann_solver_compressible_roe~~InheritsGraph type~riemann_solver_compressible_roe riemann_solver_compressible_roe type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_roe solver_pvl type~eos_compressible eos_compressible type~eos_compressible->type~riemann_solver_compressible_roe eos_1, eos_4 type~eos_compressible->type~riemann_solver_compressible_pvl eos_1, eos_4 type~riemann_solver_compressible_object riemann_solver_compressible_object type~eos_compressible->type~riemann_solver_compressible_object eos_1, eos_4 type~riemann_solver_compressible_object->type~riemann_solver_compressible_roe type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_object riemann_solver_object type~riemann_solver_object->type~riemann_solver_compressible_object type~eos_object eos_object type~eos_object->type~eos_compressible var pantyperiemann_solver_compressible_roeInheritsGraph = svgPanZoom('#typeriemann_solver_compressible_roeInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Roe (with the Harten-Hyman entropy fix) Riemann Solver. Note This is the implemention for conservative_compressible Riemann states. Variables a_1 a_2 a_3 a_4 eos_1 eos_4 p23 p_1 p_4 r_1 r_2 r_3 r_4 s_1 s_2 s_3 s_4 solver_pvl u23 u_1 u_4 Type-Bound Procedures compute_fluxes compute_roe_state compute_states23_from_u23 compute_waves description initialize set_states14 solve Source Code riemann_solver_compressible_roe Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . procedure, public, nopass :: compute_roe_state Compute intermediate state. private subroutine compute_roe_state (eos_left, state_left, eos_right, state_right, r_d, r_u, r_e, r_a) Evaluate the intermediate state from the known states U1,U4 using the Roe linearization. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. real(kind=R8P), intent(out) :: r_d Roe intermediate state density. type(vector), intent(out) :: r_u Roe intermediate state velocity vector.. real(kind=R8P), intent(out) :: r_e Roe intermediate state enthalpy. real(kind=R8P), intent(out) :: r_a Roe intermediate state sound speed. procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . private elemental subroutine compute_states23_from_u23 (self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. procedure, public, pass(self) :: compute_waves Compute waves pattern. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: initialize Initialize solver. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure, public, pass(self) :: set_states14 Set states 1 and 4. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: solve Solve Riemann Problem. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , extends ( riemann_solver_compressible_object ) :: riemann_solver_compressible_roe !< Roe (with the Harten-Hyman entropy fix) Riemann Solver. !< !< @note This is the implemention for [[conservative_compressible]] Riemann states. type ( riemann_solver_compressible_pvl ) :: solver_pvl !< PVL Riemann solver. contains ! public deferred methods procedure , pass ( self ) :: compute_waves !< Compute waves pattern. procedure , pass ( self ) :: initialize !< Initialize solver. procedure , pass ( self ) :: solve !< Solve Riemann Problem. procedure , nopass :: compute_roe_state !< Compute intermediate state. endtype riemann_solver_compressible_roe","tags":"","loc":"type/riemann_solver_compressible_roe.html","title":"riemann_solver_compressible_roe – FORESEER "},{"text":"type, public, abstract :: riemann_solver_object Abstract Riemann Solver. Inherited By type~~riemann_solver_object~~InheritedByGraph type~riemann_solver_object riemann_solver_object type~riemann_solver_compressible_object riemann_solver_compressible_object type~riemann_solver_object->type~riemann_solver_compressible_object type~riemann_solver_compressible_llf riemann_solver_compressible_llf type~riemann_solver_compressible_object->type~riemann_solver_compressible_llf type~riemann_solver_compressible_exact riemann_solver_compressible_exact type~riemann_solver_compressible_object->type~riemann_solver_compressible_exact type~riemann_solver_compressible_roe riemann_solver_compressible_roe type~riemann_solver_compressible_object->type~riemann_solver_compressible_roe type~riemann_solver_compressible_pvl riemann_solver_compressible_pvl type~riemann_solver_compressible_object->type~riemann_solver_compressible_pvl type~riemann_solver_compressible_hllc riemann_solver_compressible_hllc type~riemann_solver_compressible_object->type~riemann_solver_compressible_hllc type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_llf solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_roe solver_pvl type~riemann_solver_compressible_pvl->type~riemann_solver_compressible_hllc solver_pvl var pantyperiemann_solver_objectInheritedByGraph = svgPanZoom('#typeriemann_solver_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures compute_waves description initialize solve Source Code riemann_solver_object Type-Bound Procedures procedure( compute_waves_interface ), public, deferred, pass(self) :: compute_waves Compute waves pattern. pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Prototype Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize solver. subroutine initialize_interface (self, config) Prototype Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. procedure( solve_interface ), public, deferred, pass(self) :: solve Solve Riemann Problem. subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Prototype Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code type , abstract :: riemann_solver_object !< Abstract Riemann Solver. contains ! public deferred methods procedure ( compute_waves_interface ), pass ( self ), deferred :: compute_waves !< Compute waves pattern. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize solver. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( solve_interface ), pass ( self ), deferred :: solve !< Solve Riemann Problem. endtype riemann_solver_object","tags":"","loc":"type/riemann_solver_object.html","title":"riemann_solver_object – FORESEER "},{"text":"type, public, extends(integrand) :: euler_1d type~~euler_1d~~InheritsGraph type~euler_1d euler_1d type~conservative_compressible conservative_compressible type~conservative_compressible->type~euler_1d U type~eos_compressible eos_compressible type~eos_compressible->type~euler_1d eos interpolator_object interpolator_object interpolator_object->type~euler_1d interpolator vector vector vector->type~conservative_compressible momentum type~conservative_object conservative_object type~conservative_object->type~conservative_compressible type~eos_object eos_object type~eos_object->type~eos_compressible integrand integrand integrand->type~euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an\n ideal (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Variables BC_L BC_R Dx Ng Ni U eos interpolator reconstruct_interfaces riemann_solver weno_order Type-Bound Procedures add assign_integrand assign_real destroy dt impose_boundary_conditions initialize integrand_multiply_integrand integrand_multiply_real local_error output real_multiply_integrand reconstruct_interfaces_characteristic reconstruct_interfaces_conservative reconstruct_interfaces_primitive riemann_solver_exact riemann_solver_hllc riemann_solver_llf riemann_solver_pvl riemann_solver_roe sub t Source Code euler_1d Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: BC_L Left boundary condition type. character(len=:), public, allocatable :: BC_R Right boundary condition type. real(kind=R8P), public :: Dx = 0._R8P Space step. integer(kind=I4P), public :: Ng = 0 Ghost cells number. integer(kind=I4P), public :: Ni = 0 Space dimension. type( conservative_compressible ), public, allocatable :: U (:) Integrand (state) variables. type( eos_compressible ), public :: eos Equation of state. class(interpolator_object), public, allocatable :: interpolator WENO interpolator. procedure( reconstruct_interfaces_ ), public, pointer :: reconstruct_interfaces => reconstruct_interfaces_characteristic Reconstruct interface states. procedure( riemann_solver_ ), public, pointer :: riemann_solver => riemann_solver_llf Actual Riemann Problem solver. integer(kind=I4P), public :: weno_order = 0 WENO reconstruction order. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Operator + . private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Operator = . private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => euler_assign_real Operator euler = real . private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, steps_max, t_max, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. integer(kind=I4P), intent(in) :: steps_max Maximun number of time steps. real(kind=R8P), intent(in) :: t_max Maximum integration time. real(kind=R8P), intent(in) :: t Time. real(kind=R8P), intent(in) :: CFL CFL value. Return Value real(kind=R8P) Time step. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, U) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(inout) :: U (1-self%Ng:) Conservative variables. procedure, public, pass(self) :: initialize Initialize field. private subroutine initialize (self, Ni, Dx, BC_L, BC_R, initial_state, eos, weno_order, weno_variables, riemann_solver_scheme) Initialize field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. integer(kind=I4P), intent(in) :: Ni Space dimension. real(kind=R8P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. type( primitive_compressible ), intent(in) :: initial_state (1:) Initial state of primitive variables. type( eos_compressible ), intent(in) :: eos Equation of state. integer(kind=I4P), intent(in), optional :: weno_order WENO reconstruction order. character(len=*), intent(in), optional :: weno_variables Variables on which WENO reconstruction is done. character(len=*), intent(in), optional :: riemann_solver_scheme Riemann solver scheme. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Operator * . private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Operator euler * real . private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: local_error => euler_local_error Operator ||euler-euler|| . private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self, is_primitive) result(state) Output the Euler field state. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. logical, intent(in), optional :: is_primitive Output in primitive variables. Return Value real(kind=R8P),\n  allocatable, (:,:) Euler state vector. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Operator real * euler . private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, private, pass(self) :: reconstruct_interfaces_characteristic Reconstruct (charc.) interface states. private subroutine reconstruct_interfaces_characteristic (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. procedure, private, pass(self) :: reconstruct_interfaces_conservative Reconstruct (cons.) interface states. private subroutine reconstruct_interfaces_conservative (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. procedure, private, pass(self) :: reconstruct_interfaces_primitive Reconstruct (prim.) interface states. private subroutine reconstruct_interfaces_primitive (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. procedure, private, pass(self) :: riemann_solver_exact Exact Riemann Problem solver. private subroutine riemann_solver_exact (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of exact (Newton iterative) algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: riemann_solver_hllc HLLC Riemann Problem solver. private subroutine riemann_solver_hllc (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of HLLC algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: riemann_solver_llf LLF Riemann Problem solver. private subroutine riemann_solver_llf (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of LLF algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: riemann_solver_pvl PVL Riemann Problem solver. private subroutine riemann_solver_pvl (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of PVL algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, private, pass(self) :: riemann_solver_roe Roe Riemann Problem solver. private subroutine riemann_solver_roe (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of Roe algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. procedure, public, pass(lhs) :: sub => sub_euler Operator - . private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. real(kind=R8P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. Source Code type , extends ( integrand ) :: euler_1d !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an !< ideal (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). integer ( I4P ) :: weno_order = 0 !< WENO reconstruction order. integer ( I4P ) :: Ni = 0 !< Space dimension. integer ( I4P ) :: Ng = 0 !< Ghost cells number. real ( R8P ) :: Dx = 0._R8P !< Space step. type ( eos_compressible ) :: eos !< Equation of state. type ( conservative_compressible ), allocatable :: U (:) !< Integrand (state) variables. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. procedure ( reconstruct_interfaces_ ), pointer :: reconstruct_interfaces => & reconstruct_interfaces_characteristic !< Reconstruct interface states. procedure ( riemann_solver_ ), pointer :: riemann_solver => riemann_solver_llf !< Actual Riemann Problem solver. contains ! auxiliary methods procedure , pass ( self ) :: initialize !< Initialize field. procedure , pass ( self ) :: destroy !< Destroy field. procedure , pass ( self ) :: output !< Extract Euler field. procedure , pass ( self ) :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ) :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ) :: local_error => euler_local_error !< Operator `||euler-euler||`. procedure , pass ( lhs ) :: integrand_multiply_integrand => euler_multiply_euler !< Operator `*`. procedure , pass ( lhs ) :: integrand_multiply_real => euler_multiply_real !< Operator `euler * real`. procedure , pass ( rhs ) :: real_multiply_integrand => real_multiply_euler !< Operator `real * euler`. procedure , pass ( lhs ) :: add => add_euler !< Operator `+`. procedure , pass ( lhs ) :: sub => sub_euler !< Operator `-`. procedure , pass ( lhs ) :: assign_integrand => euler_assign_euler !< Operator `=`. procedure , pass ( lhs ) :: assign_real => euler_assign_real !< Operator `euler = real`. ! private methods procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_characteristic !< Reconstruct (charc.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_conservative !< Reconstruct (cons.) interface states. procedure , pass ( self ), private :: reconstruct_interfaces_primitive !< Reconstruct (prim.) interface states. procedure , pass ( self ), private :: riemann_solver_exact !< Exact Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_hllc !< HLLC Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_llf !< LLF Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_pvl !< PVL Riemann Problem solver. procedure , pass ( self ), private :: riemann_solver_roe !< Roe Riemann Problem solver. endtype euler_1d","tags":"","loc":"type/euler_1d.html","title":"euler_1d – FORESEER "},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function array_interface(self) result(array_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of conservative. Description Return serialized array of conservative.","tags":"","loc":"interface/array_interface.html","title":"array_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private pure subroutine assignment_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assignment_interface.html","title":"assignment_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine compute_fluxes_interface(self, eos, normal, fluxes) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. Description Compute conservative fluxes.","tags":"","loc":"interface/compute_fluxes_interface.html","title":"compute_fluxes_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function cons_operator_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Description Operator cons.op.real .","tags":"","loc":"interface/cons_operator_real.html","title":"cons_operator_real – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. Description Destroy conservative.","tags":"","loc":"interface/destroy_interface.html","title":"destroy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine initialize_interface(self, initial_state) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. Description Initialize conservative.","tags":"","loc":"interface/initialize_interface.html","title":"initialize_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function pressure_interface(self, eos) result(pressure_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. Description Return pressure value.","tags":"","loc":"interface/pressure_interface.html","title":"pressure_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function real_operator_cons(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Description Operator real.op.cons .","tags":"","loc":"interface/real_operator_cons.html","title":"real_operator_cons – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Description Symmetric operator cons.op.cons .","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private function unary_operator(self) result(operator_result) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. Description Unary operator .op.cons .","tags":"","loc":"interface/unary_operator.html","title":"unary_operator – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function velocity_interface(self) result(velocity_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Description Return velocity vector.","tags":"","loc":"interface/velocity_interface.html","title":"velocity_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private pure subroutine assignment_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assignment_interface~2.html","title":"assignment_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function density_interface(self, energy, pressure, speed_of_sound, temperature) result(density_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. Description Return density.","tags":"","loc":"interface/density_interface.html","title":"density_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface~2.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function energy_interface(self, density, pressure, temperature) result(energy_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. Description Return specific internal energy.","tags":"","loc":"interface/energy_interface.html","title":"energy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function pressure_interface(self, density, energy, temperature) result(pressure_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. Description Return pressure.","tags":"","loc":"interface/pressure_interface~2.html","title":"pressure_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function scalar_interface(self) result(scalar_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. Description Return a scalar real value by only self data.","tags":"","loc":"interface/scalar_interface.html","title":"scalar_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function speed_of_sound_interface(self, density, pressure) result(speed_of_sound_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. Description Return speed of sound.","tags":"","loc":"interface/speed_of_sound_interface.html","title":"speed_of_sound_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function temperature_interface(self, density, energy, pressure) result(temperature_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Description Return temperature.","tags":"","loc":"interface/temperature_interface.html","title":"temperature_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function array_interface(self) result(array_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of primitive. Description Return serialized array of primitive.","tags":"","loc":"interface/array_interface~2.html","title":"array_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private pure subroutine assignment_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assignment_interface~3.html","title":"assignment_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface~3.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. Description Destroy primitive.","tags":"","loc":"interface/destroy_interface~2.html","title":"destroy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function energy_interface(self, eos) result(energy_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. Description Return energy value.","tags":"","loc":"interface/energy_interface~2.html","title":"energy_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private subroutine initialize_interface(self, initial_state) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. Description Initialize primitive.","tags":"","loc":"interface/initialize_interface~2.html","title":"initialize_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function momentum_interface(self) result(momentum_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Description Return momentum vector.","tags":"","loc":"interface/momentum_interface.html","title":"momentum_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function prim_operator_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Description Operator prim.op.real .","tags":"","loc":"interface/prim_operator_real.html","title":"prim_operator_real – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function real_operator_prim(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Description Operator real * prim .","tags":"","loc":"interface/real_operator_prim.html","title":"real_operator_prim – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Description Symmetric operator prim.op.prim .","tags":"","loc":"interface/symmetric_operator~2.html","title":"symmetric_operator – FORESEER"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private function unary_operator(self) result(operator_result) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Description Unary operator .op.prim .","tags":"","loc":"interface/unary_operator~2.html","title":"unary_operator – FORESEER"},{"text":"abstract interface private pure subroutine compute_waves_interface(self, eos_left, state_left, eos_right, state_right, normal, waves) Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Description Compute waves pattern.","tags":"","loc":"interface/compute_waves_interface~2.html","title":"compute_waves_interface – FORESEER"},{"text":"abstract interface private pure subroutine solve_interface(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Description Solve Riemann problem.","tags":"","loc":"interface/solve_interface~2.html","title":"solve_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure subroutine compute_waves_interface(self, eos_left, state_left, eos_right, state_right, normal, waves) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Description Compute waves pattern. This compute only the waves pattern, not the fluxes: this is useful for building solvers being hybrid of other solvers.","tags":"","loc":"interface/compute_waves_interface.html","title":"compute_waves_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface~4.html","title":"description_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine initialize_interface(self, config) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Description Initialize solver.","tags":"","loc":"interface/initialize_interface~3.html","title":"initialize_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine solve_interface(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Description Solve Riemann Problem.","tags":"","loc":"interface/solve_interface.html","title":"solve_interface – FORESEER"},{"text":"abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine reconstruct_interfaces_(self, conservative, r_conservative) Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative variables. Description Reconstruct interface states.","tags":"","loc":"interface/reconstruct_interfaces_.html","title":"reconstruct_interfaces_ – FORESEER"},{"text":"abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine riemann_solver_(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Description Riemann Problem solver.","tags":"","loc":"interface/riemann_solver_.html","title":"riemann_solver_ – FORESEER"},{"text":"public elemental function conservative_to_primitive_compressible(conservative, eos) result(primitive_) Return a primitive_compressible state transforming a given conservative_compressible state. Arguments Type Intent Optional Attributes Name type( conservative_compressible ), intent(in) :: conservative Conservative state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( primitive_compressible ) Primitive state. Called By proc~~conservative_to_primitive_compressible~~CalledByGraph proc~conservative_to_primitive_compressible conservative_to_primitive_compressible program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations program~foreseer_test_compressible_transformations->proc~conservative_to_primitive_compressible proc~reconstruct_interfaces_characteristic reconstruct_interfaces_characteristic proc~reconstruct_interfaces_characteristic->proc~conservative_to_primitive_compressible proc~save_time_serie save_time_serie proc~save_time_serie->proc~conservative_to_primitive_compressible proc~output output proc~output->proc~conservative_to_primitive_compressible proc~reconstruct_interfaces_primitive reconstruct_interfaces_primitive proc~reconstruct_interfaces_primitive->proc~conservative_to_primitive_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~save_time_serie var panprocconservative_to_primitive_compressibleCalledByGraph = svgPanZoom('#procconservative_to_primitive_compressibleCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_to_primitive_compressible Source Code elemental function conservative_to_primitive_compressible ( conservative , eos ) result ( primitive_ ) !< Return a [[primitive_compressible]] state transforming a given [[conservative_compressible]] state. type ( conservative_compressible ), intent ( in ) :: conservative !< Conservative state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( primitive_compressible ) :: primitive_ !< Primitive state. primitive_ % density = conservative % density primitive_ % velocity = conservative % velocity () primitive_ % pressure = conservative % pressure ( eos = eos ) endfunction conservative_to_primitive_compressible","tags":"","loc":"proc/conservative_to_primitive_compressible.html","title":"conservative_to_primitive_compressible – FORESEER"},{"text":"public elemental function primitive_to_conservative_compressible(primitive, eos) result(conservative_) Return a conservative_compressible state transforming a given primitive_compressible state. Arguments Type Intent Optional Attributes Name type( primitive_compressible ), intent(in) :: primitive Primitive state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( conservative_compressible ) Conservative state. Called By proc~~primitive_to_conservative_compressible~~CalledByGraph proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~initialize~8 initialize proc~initialize~8->proc~primitive_to_conservative_compressible proc~reconstruct_interfaces_primitive reconstruct_interfaces_primitive proc~reconstruct_interfaces_primitive->proc~primitive_to_conservative_compressible program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations program~foreseer_test_compressible_transformations->proc~primitive_to_conservative_compressible proc~reconstruct_interfaces_characteristic reconstruct_interfaces_characteristic proc~reconstruct_interfaces_characteristic->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_to_conservative_compressible Source Code elemental function primitive_to_conservative_compressible ( primitive , eos ) result ( conservative_ ) !< Return a [[conservative_compressible]] state transforming a given [[primitive_compressible]] state. type ( primitive_compressible ), intent ( in ) :: primitive !< Primitive state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( conservative_compressible ) :: conservative_ !< Conservative state. conservative_ % density = primitive % density conservative_ % momentum = primitive % momentum () conservative_ % energy = primitive % energy ( eos = eos ) endfunction primitive_to_conservative_compressible","tags":"","loc":"proc/primitive_to_conservative_compressible.html","title":"primitive_to_conservative_compressible – FORESEER"},{"text":"private function add(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code add Source Code function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density + rhs % density operator_result % momentum = lhs % momentum + rhs % momentum operator_result % energy = lhs % energy + rhs % energy endselect endselect endfunction add","tags":"","loc":"proc/add.html","title":"add – FORESEER"},{"text":"private pure function array(self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of conservative. Source Code array Source Code pure function array ( self ) result ( array_ ) !< Return serialized array of conservative. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of conservative. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % momentum % x array_ ( 3 ) = self % momentum % y array_ ( 4 ) = self % momentum % z array_ ( 5 ) = self % energy endfunction array","tags":"","loc":"proc/array.html","title":"array – FORESEER"},{"text":"private function cons_divide_real(lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code cons_divide_real Source Code function cons_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons / real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density / rhs operator_result % momentum = lhs % momentum / rhs operator_result % energy = lhs % energy / rhs endselect endfunction cons_divide_real","tags":"","loc":"proc/cons_divide_real.html","title":"cons_divide_real – FORESEER"},{"text":"private function cons_multiply_cons(lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code cons_multiply_cons Source Code function cons_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs % density operator_result % momentum = lhs % momentum * rhs % momentum operator_result % energy = lhs % energy * rhs % energy endselect endselect endfunction cons_multiply_cons","tags":"","loc":"proc/cons_multiply_cons.html","title":"cons_multiply_cons – FORESEER"},{"text":"private function cons_multiply_real(lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code cons_multiply_real Source Code function cons_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `cons * real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs % density * rhs operator_result % momentum = lhs % momentum * rhs operator_result % energy = lhs % energy * rhs endselect endfunction cons_multiply_real","tags":"","loc":"proc/cons_multiply_real.html","title":"cons_multiply_real – FORESEER"},{"text":"private elemental function conservative_compressible_instance(density, momentum, energy) result(instance) Return and instance of conservative_compressible . Note This procedure is used for overloading conservative_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . Called By proc~~conservative_compressible_instance~~CalledByGraph proc~conservative_compressible_instance conservative_compressible_instance interface~conservative_compressible conservative_compressible interface~conservative_compressible->proc~conservative_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_compressible_instance Source Code elemental function conservative_compressible_instance ( density , momentum , energy ) result ( instance ) !< Return and instance of [[conservative_compressible]]. !< !< @note This procedure is used for overloading [[conservative_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ), intent ( in ), optional :: energy !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. type ( conservative_compressible ) :: instance !< Instance of [[conservative_compressible]]. if ( present ( density )) instance % density = density if ( present ( momentum )) instance % momentum = momentum if ( present ( energy )) instance % energy = energy endfunction conservative_compressible_instance","tags":"","loc":"proc/conservative_compressible_instance.html","title":"conservative_compressible_instance – FORESEER"},{"text":"public function conservative_compressible_pointer(to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Note A type-guard check is performed and error stop is raised if necessary. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( conservative_compressible ),\n  pointer Associated pointer. Called By proc~~conservative_compressible_pointer~~CalledByGraph proc~conservative_compressible_pointer conservative_compressible_pointer proc~compute_roe_state compute_roe_state proc~compute_roe_state->proc~conservative_compressible_pointer proc~solve~2 solve proc~solve~2->proc~conservative_compressible_pointer program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible program~foreseer_test_conservative_compressible->proc~conservative_compressible_pointer proc~solve~3 solve proc~solve~3->proc~conservative_compressible_pointer proc~solve~5 solve proc~solve~5->proc~compute_roe_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_compressible_pointer Source Code function conservative_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( conservative_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( conservative_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( conservative_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast conservative_object to conservative_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction conservative_compressible_pointer","tags":"","loc":"proc/conservative_compressible_pointer.html","title":"conservative_compressible_pointer – FORESEER"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~~CallsGraph proc~description description str str proc~description->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'momentum = ' // trim ( str ( n = [ self % momentum % x , self % momentum % y , self % momentum % z ])) // NL desc = desc // prefix_ // 'energy   = ' // trim ( str ( n = self % energy )) endfunction description","tags":"","loc":"proc/description.html","title":"description – FORESEER"},{"text":"private function negative(self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code negative Source Code function negative ( self ) result ( operator_result ) !< Unary operator `- cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = - self % density operator_result % momentum = - self % momentum operator_result % energy = - self % energy endselect endfunction negative","tags":"","loc":"proc/negative.html","title":"negative – FORESEER"},{"text":"private function positive(self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code positive Source Code function positive ( self ) result ( operator_result ) !< Unary operator `+ cons`. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = + self % density operator_result % momentum = + self % momentum operator_result % energy = + self % energy endselect endfunction positive","tags":"","loc":"proc/positive.html","title":"positive – FORESEER"},{"text":"private elemental function pressure(self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. Source Code pressure Source Code elemental function pressure ( self , eos ) result ( pressure_ ) !< Return pressure value. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % velocity () pressure_ = ( eos % g () - 1._R8P ) * ( self % energy - 0.5_R8P * self % density * velocity_ % sq_norm ()) endfunction pressure","tags":"","loc":"proc/pressure.html","title":"pressure – FORESEER"},{"text":"private function real_multiply_cons(lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code real_multiply_cons Source Code function real_multiply_cons ( lhs , rhs ) result ( operator_result ) !< Operator `real * cons`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result % density = lhs * rhs % density operator_result % momentum = lhs * rhs % momentum operator_result % energy = lhs * rhs % energy endselect endfunction real_multiply_cons","tags":"","loc":"proc/real_multiply_cons.html","title":"real_multiply_cons – FORESEER"},{"text":"private function sub(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. Source Code sub Source Code function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. class ( conservative_object ), allocatable :: operator_result !< Operator result. allocate ( conservative_compressible :: operator_result ) select type ( operator_result ) class is ( conservative_compressible ) operator_result = lhs select type ( rhs ) class is ( conservative_compressible ) operator_result % density = lhs % density - rhs % density operator_result % momentum = lhs % momentum - rhs % momentum operator_result % energy = lhs % energy - rhs % energy endselect endselect endfunction sub","tags":"","loc":"proc/sub.html","title":"sub – FORESEER"},{"text":"private elemental function velocity(self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code velocity Source Code elemental function velocity ( self ) result ( velocity_ ) !< Return velocity vector. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % momentum / self % density endfunction velocity","tags":"","loc":"proc/velocity.html","title":"velocity – FORESEER"},{"text":"private subroutine compute_fluxes(self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. Source Code compute_fluxes Source Code subroutine compute_fluxes ( self , eos , normal , fluxes ) !< Compute conservative fluxes. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. real ( R8P ) :: velocity_normal_ !< Velocity component parallel to given normal. select type ( fluxes ) class is ( conservative_compressible ) pressure_ = self % pressure ( eos = eos ) velocity_ = self % velocity () velocity_normal_ = velocity_ . dot . normal fluxes % density = self % momentum . dot . normal fluxes % momentum = self % density * velocity_ * velocity_normal_ + pressure_ * normal fluxes % energy = ( self % energy + pressure_ ) * velocity_normal_ endselect endsubroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes.html","title":"compute_fluxes – FORESEER"},{"text":"private elemental subroutine compute_fluxes_from_primitive(self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. Source Code compute_fluxes_from_primitive Source Code elemental subroutine compute_fluxes_from_primitive ( self , eos , p , r , u , normal ) !< Compute conservative fluxes from primitives at interface. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: p !< Pressure at interface. real ( R8P ), intent ( in ) :: r !< Density at interface. real ( R8P ), intent ( in ) :: u !< Velocity (normal component) at interface. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. self % density = r * u self % momentum = ( r * u * u + p ) * normal self % energy = ( r * eos % energy ( density = r , pressure = p ) + r * u * u * 0.5_R8P + p ) * u endsubroutine compute_fluxes_from_primitive","tags":"","loc":"proc/compute_fluxes_from_primitive.html","title":"compute_fluxes_from_primitive – FORESEER"},{"text":"private pure subroutine cons_assign_cons(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Source Code cons_assign_cons Source Code pure subroutine cons_assign_cons ( lhs , rhs ) !< Operator `=`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( conservative_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( conservative_compressible ) lhs % density = rhs % density lhs % momentum = rhs % momentum lhs % energy = rhs % energy endselect endsubroutine cons_assign_cons","tags":"","loc":"proc/cons_assign_cons.html","title":"cons_assign_cons – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. type ( conservative_compressible ) :: fresh !< Fresh instance of conservative object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FORESEER"},{"text":"private subroutine initialize(self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. Source Code initialize Source Code subroutine initialize ( self , initial_state ) !< Initialize conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( conservative_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( conservative_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – FORESEER"},{"text":"public interface conservative_compressible Overload conservative_compressible name with its constructor. Calls interface~~conservative_compressible~~CallsGraph interface~conservative_compressible conservative_compressible proc~conservative_compressible_instance conservative_compressible_instance interface~conservative_compressible->proc~conservative_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures conservative_compressible_instance Module Procedures private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible .","tags":"","loc":"interface/conservative_compressible.html","title":"conservative_compressible – FORESEER"},{"text":"private elemental function R(self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. Source Code R Source Code elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % R_ endfunction R","tags":"","loc":"proc/r.html","title":"R – FORESEER"},{"text":"private elemental function cp(self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. Source Code cp Source Code elemental function cp ( self ) result ( cp_ ) !< Return specific heat at constant pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cp_ !< `cp` value. cp_ = self % cp_ endfunction cp","tags":"","loc":"proc/cp.html","title":"cp – FORESEER"},{"text":"private elemental function cv(self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. Source Code cv Source Code elemental function cv ( self ) result ( cv_ ) !< Return specific heat at constant volume. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cv_ !< `cv` value. cv_ = self % cv_ endfunction cv","tags":"","loc":"proc/cv.html","title":"cv – FORESEER"},{"text":"private elemental function delta(self) result(delta_) Return (gamma - 1) / 2 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) (gamma - 1) / 2 value. Source Code delta Source Code elemental function delta ( self ) result ( delta_ ) !< Return `(gamma - 1) / 2`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: delta_ !< `(gamma - 1) / 2` value. delta_ = self % delta_ endfunction delta","tags":"","loc":"proc/delta.html","title":"delta – FORESEER"},{"text":"private elemental function density(self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. Source Code density Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % g_ - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R_ * temperature ) endif endfunction density","tags":"","loc":"proc/density.html","title":"density – FORESEER"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~2~~CallsGraph proc~description~2 description str str proc~description~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description","tags":"","loc":"proc/description~2.html","title":"description – FORESEER"},{"text":"private elemental function energy(self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. Source Code energy Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % g_ - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R_ * temperature ) endif endfunction density pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % g_ - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy","tags":"","loc":"proc/energy.html","title":"energy – FORESEER"},{"text":"private elemental function eos_compressible_instance(cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Note This procedure is used for overloading eos_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Called By proc~~eos_compressible_instance~~CalledByGraph proc~eos_compressible_instance eos_compressible_instance interface~eos_compressible eos_compressible interface~eos_compressible->proc~eos_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code eos_compressible_instance Source Code elemental function eos_compressible_instance ( cp , cv , gam , R ) result ( instance ) !< Return and instance of [[eos_compressible]]. !< !< @note This procedure is used for overloading [[eos_compressible]] name. real ( R8P ), intent ( in ), optional :: cp !< Specific heat at constant pressure `cp` value. real ( R8P ), intent ( in ), optional :: cv !< Specific heat at constant volume `cv` value. real ( R8P ), intent ( in ), optional :: gam !< Specific heats ratio `gamma=cp/cv` value. real ( R8P ), intent ( in ), optional :: R !< Fluid constant `R=cp-cv` value. type ( eos_compressible ) :: instance !< Instance of [[eos_compressible]]. if ( present ( cp ). and . present ( cv )) then instance % cp_ = cp instance % cv_ = cv elseif ( present ( gam ). and . present ( R )) then instance % cv_ = R / ( gam - 1._R8P ) instance % cp_ = gam * instance % cv_ elseif ( present ( gam ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp / gam elseif ( present ( gam ). and . present ( cv )) then instance % cp_ = gam * cv instance % cv_ = cv elseif ( present ( R ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp - R elseif ( present ( R ). and . present ( cv )) then instance % cp_ = cv + R instance % cv_ = cv endif call instance % compute_derivate endfunction eos_compressible_instance","tags":"","loc":"proc/eos_compressible_instance.html","title":"eos_compressible_instance – FORESEER"},{"text":"public function eos_compressible_pointer(to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Note A type-guard check is performed and error stop is raised if necessary. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( eos_compressible ),\n  pointer Associated pointer. Called By proc~~eos_compressible_pointer~~CalledByGraph proc~eos_compressible_pointer eos_compressible_pointer proc~compute_roe_state compute_roe_state proc~compute_roe_state->proc~eos_compressible_pointer proc~solve~5 solve proc~solve~5->proc~compute_roe_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code eos_compressible_pointer Source Code function eos_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( eos_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( eos_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( eos_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast eos_object to eos_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction eos_compressible_pointer","tags":"","loc":"proc/eos_compressible_pointer.html","title":"eos_compressible_pointer – FORESEER"},{"text":"private elemental function eta(self) result(eta_) Return 2 * gamma / (gamma - 1) . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) 2 * gamma / (gamma - 1) value. Source Code eta Source Code elemental function eta ( self ) result ( eta_ ) !< Return `2 * gamma / (gamma - 1)`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: eta_ !< `2 * gamma / (gamma - 1)` value. eta_ = self % eta_ endfunction eta","tags":"","loc":"proc/eta.html","title":"eta – FORESEER"},{"text":"private elemental function g(self) result(g_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. Source Code g Source Code elemental function g ( self ) result ( g_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: g_ !< Specific heats ratio value. g_ = self % g_ endfunction g","tags":"","loc":"proc/g.html","title":"g – FORESEER"},{"text":"private elemental function gm1(self) result(gm1_) Return gamma - 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma - 1 value. Source Code gm1 Source Code elemental function gm1 ( self ) result ( gm1_ ) !< Return `gamma - 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gm1_ !< `gamma - 1` value. gm1_ = self % gm1_ endfunction gm1","tags":"","loc":"proc/gm1.html","title":"gm1 – FORESEER"},{"text":"private elemental function gp1(self) result(gp1_) Return gamma + 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma + 1 value. Source Code gp1 Source Code elemental function gp1 ( self ) result ( gp1_ ) !< Return `gamma + 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gp1_ !< `gamma + 1` value. gp1_ = self % gp1_ endfunction gp1","tags":"","loc":"proc/gp1.html","title":"gp1 – FORESEER"},{"text":"private elemental function pressure(self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. Source Code pressure Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % g_ - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R_ * temperature ) endif endfunction density pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % g_ - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy elemental function eta ( self ) result ( eta_ ) !< Return `2 * gamma / (gamma - 1)`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: eta_ !< `2 * gamma / (gamma - 1)` value. eta_ = self % eta_ endfunction eta elemental function g ( self ) result ( g_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: g_ !< Specific heats ratio value. g_ = self % g_ endfunction g elemental function gm1 ( self ) result ( gm1_ ) !< Return `gamma - 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gm1_ !< `gamma - 1` value. gm1_ = self % gm1_ endfunction gm1 elemental function gp1 ( self ) result ( gp1_ ) !< Return `gamma + 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gp1_ !< `gamma + 1` value. gp1_ = self % gp1_ endfunction gp1 elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % g_ - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R_ * temperature endif endfunction pressure","tags":"","loc":"proc/pressure~2.html","title":"pressure – FORESEER"},{"text":"private elemental function speed_of_sound(self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. Source Code speed_of_sound Source Code elemental function density ( self , energy , pressure , speed_of_sound , temperature ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: speed_of_sound !< Speed of sound value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: density_ !< Density value. density_ = 0._R8P if ( present ( energy ). and . present ( pressure )) then density_ = pressure / (( self % g_ - 1._R8P ) * energy ) elseif ( present ( pressure ). and . present ( speed_of_sound )) then density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) elseif ( present ( pressure ). and . present ( temperature )) then density_ = pressure / ( self % R_ * temperature ) endif endfunction density pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description elemental function energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % g_ - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction energy elemental function eta ( self ) result ( eta_ ) !< Return `2 * gamma / (gamma - 1)`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: eta_ !< `2 * gamma / (gamma - 1)` value. eta_ = self % eta_ endfunction eta elemental function g ( self ) result ( g_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: g_ !< Specific heats ratio value. g_ = self % g_ endfunction g elemental function gm1 ( self ) result ( gm1_ ) !< Return `gamma - 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gm1_ !< `gamma - 1` value. gm1_ = self % gm1_ endfunction gm1 elemental function gp1 ( self ) result ( gp1_ ) !< Return `gamma + 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gp1_ !< `gamma + 1` value. gp1_ = self % gp1_ endfunction gp1 elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % g_ - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R_ * temperature endif endfunction pressure elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % R_ endfunction R elemental function speed_of_sound ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. speed_of_sound_ = sqrt ( self % g_ * pressure / density ) endfunction speed_of_sound","tags":"","loc":"proc/speed_of_sound.html","title":"speed_of_sound – FORESEER"},{"text":"private elemental function temperature(self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Source Code temperature Source Code elemental function temperature ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. temperature_ = 0._R8P if ( present ( density ). and . present ( pressure )) then temperature_ = pressure / ( self % R_ * density ) elseif ( present ( energy )) then temperature_ = energy / self % cv () endif endfunction temperature","tags":"","loc":"proc/temperature.html","title":"temperature – FORESEER"},{"text":"private elemental subroutine compute_derivate(self) Compute derivate quantities (from cp and cv ). Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: self Equation of state. Source Code compute_derivate Source Code elemental subroutine compute_derivate ( self ) !< Compute derivate quantities (from `cp` and `cv`). class ( eos_compressible ), intent ( inout ) :: self !< Equation of state. self % g_ = self % cp_ / self % cv_ self % R_ = self % cp_ - self % cv_ self % gm1_ = self % g_ - 1._R8P self % gp1_ = self % g_ + 1._R8P self % delta_ = ( self % g_ - 1._R8P ) * 0.5_R8P self % eta_ = 2._R8P * self % g_ / ( self % g_ - 1._R8P ) endsubroutine compute_derivate","tags":"","loc":"proc/compute_derivate.html","title":"compute_derivate – FORESEER"},{"text":"private pure subroutine eos_assign_eos(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. Source Code eos_assign_eos Source Code pure subroutine eos_assign_eos ( lhs , rhs ) !< Operator `=`. class ( eos_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( eos_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( eos_compressible ) lhs % cp_ = rhs % cp_ lhs % cv_ = rhs % cv_ lhs % g_ = rhs % g_ lhs % R_ = rhs % R_ lhs % delta_ = rhs % delta_ lhs % eta_ = rhs % eta_ lhs % gm1_ = rhs % gm1_ lhs % gp1_ = rhs % gp1_ endselect endsubroutine eos_assign_eos","tags":"","loc":"proc/eos_assign_eos.html","title":"eos_assign_eos – FORESEER"},{"text":"public interface eos_compressible Overload eos_compressible name with its constructor. Calls interface~~eos_compressible~~CallsGraph interface~eos_compressible eos_compressible proc~eos_compressible_instance eos_compressible_instance interface~eos_compressible->proc~eos_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures eos_compressible_instance Module Procedures private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible .","tags":"","loc":"interface/eos_compressible.html","title":"eos_compressible – FORESEER"},{"text":"private function add(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code add Source Code function add ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density + rhs % density operator_result % velocity = lhs % velocity + rhs % velocity operator_result % pressure = lhs % pressure + rhs % pressure endselect endselect endfunction add","tags":"","loc":"proc/add~2.html","title":"add – FORESEER"},{"text":"private pure function array(self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of primitive. Source Code array Source Code pure function array ( self ) result ( array_ ) !< Return serialized array of primitive. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of primitive. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endfunction array","tags":"","loc":"proc/array~2.html","title":"array – FORESEER"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~3~~CallsGraph proc~description~3 description str str proc~description~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endfunction description","tags":"","loc":"proc/description~3.html","title":"description – FORESEER"},{"text":"private elemental function energy(self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. Source Code energy Source Code elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % g () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy","tags":"","loc":"proc/energy~2.html","title":"energy – FORESEER"},{"text":"private pure function left_eigenvectors(self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. Source Code left_eigenvectors Source Code pure function left_eigenvectors ( self , eos ) result ( eig ) !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_a !< `g*p/a`. gp = eos % g () * self % pressure gp_a = gp / eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0._R8P ; eig ( 1 , 2 ) = - gp_a ; eig ( 1 , 3 ) = 1._R8P eig ( 2 , 1 ) = gp / self % density ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - 1._R8P eig ( 3 , 1 ) = 0._R8P ; eig ( 3 , 2 ) = gp_a ; eig ( 3 , 3 ) = 1._R8P endfunction left_eigenvectors","tags":"","loc":"proc/left_eigenvectors.html","title":"left_eigenvectors – FORESEER"},{"text":"private elemental function momentum(self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Source Code momentum Source Code elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum","tags":"","loc":"proc/momentum.html","title":"momentum – FORESEER"},{"text":"private function negative(self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code negative Source Code function negative ( self ) result ( operator_result ) !< Unary operator `- prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = - self % density operator_result % velocity = - self % velocity operator_result % pressure = - self % pressure endselect endfunction negative","tags":"","loc":"proc/negative~2.html","title":"negative – FORESEER"},{"text":"private function positive(self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code positive Source Code function positive ( self ) result ( operator_result ) !< Unary operator `+ prim`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = + self % density operator_result % velocity = + self % velocity operator_result % pressure = + self % pressure endselect endfunction positive","tags":"","loc":"proc/positive~2.html","title":"positive – FORESEER"},{"text":"private function prim_divide_real(lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code prim_divide_real Source Code function prim_divide_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim / real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density / rhs operator_result % velocity = lhs % velocity / rhs operator_result % pressure = lhs % pressure / rhs endselect endfunction prim_divide_real","tags":"","loc":"proc/prim_divide_real.html","title":"prim_divide_real – FORESEER"},{"text":"private function prim_multiply_prim(lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code prim_multiply_prim Source Code function prim_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `*`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs % density operator_result % velocity = lhs % velocity * rhs % velocity operator_result % pressure = lhs % pressure * rhs % pressure endselect endselect endfunction prim_multiply_prim","tags":"","loc":"proc/prim_multiply_prim.html","title":"prim_multiply_prim – FORESEER"},{"text":"private function prim_multiply_real(lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code prim_multiply_real Source Code function prim_multiply_real ( lhs , rhs ) result ( operator_result ) !< Operator `prim * real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs % density * rhs operator_result % velocity = lhs % velocity * rhs operator_result % pressure = lhs % pressure * rhs endselect endfunction prim_multiply_real","tags":"","loc":"proc/prim_multiply_real.html","title":"prim_multiply_real – FORESEER"},{"text":"private elemental function primitive_compressible_instance(density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Note This procedure is used for overloading primitive_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . Called By proc~~primitive_compressible_instance~~CalledByGraph proc~primitive_compressible_instance primitive_compressible_instance interface~primitive_compressible primitive_compressible interface~primitive_compressible->proc~primitive_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_compressible_instance Source Code elemental function primitive_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[primitive_compressible]]. !< !< @note This procedure is used for overloading [[primitive_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density, `rho`. type ( vector ), intent ( in ), optional :: velocity !< Velocity, `v`. real ( R8P ), intent ( in ), optional :: pressure !< Pressure, `p`. type ( primitive_compressible ) :: instance !< Instance of [[primitive_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure endfunction primitive_compressible_instance","tags":"","loc":"proc/primitive_compressible_instance.html","title":"primitive_compressible_instance – FORESEER"},{"text":"public function primitive_compressible_pointer(to, error_message) result(pointer_) Return primitive_compressible pointer associated to primitive_object or its extensions until primitive_compressible included. Note A type-guard check is performed and error stop is raised if necessary. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( primitive_compressible ),\n  pointer Associated pointer. Called By proc~~primitive_compressible_pointer~~CalledByGraph proc~primitive_compressible_pointer primitive_compressible_pointer program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible program~foreseer_test_primitive_compressible->proc~primitive_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_compressible_pointer Source Code function primitive_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[primitive_compressible]] pointer associated to [[primitive_object]] or its extensions until !< [[primitive_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( primitive_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( primitive_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( primitive_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast primitive_object to primitive_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction primitive_compressible_pointer","tags":"","loc":"proc/primitive_compressible_pointer.html","title":"primitive_compressible_pointer – FORESEER"},{"text":"private function real_multiply_prim(lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code real_multiply_prim Source Code function real_multiply_prim ( lhs , rhs ) result ( operator_result ) !< Operator `real * prim`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result % density = lhs * rhs % density operator_result % velocity = lhs * rhs % velocity operator_result % pressure = lhs * rhs % pressure endselect endfunction real_multiply_prim","tags":"","loc":"proc/real_multiply_prim.html","title":"real_multiply_prim – FORESEER"},{"text":"private pure function right_eigenvectors(self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. Source Code right_eigenvectors Source Code pure function right_eigenvectors ( self , eos ) result ( eig ) !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_inv !< `1/(g*p)`. real ( R8P ) :: a !< Speed of sound, `sqrt(g*p/r)`. gp = eos % g () * self % pressure gp_inv = 1._R8P / gp a = eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0.5_R8P * self % density * gp_inv ; eig ( 1 , 2 ) = self % density * gp_inv ; eig ( 1 , 3 ) = eig ( 1 , 1 ) eig ( 2 , 1 ) = - 0.5_R8P * a * gp_inv ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - eig ( 2 , 1 ) eig ( 3 , 1 ) = 0.5_R8P ; eig ( 3 , 2 ) = 0._R8P ; eig ( 3 , 3 ) = eig ( 3 , 1 ) endfunction right_eigenvectors","tags":"","loc":"proc/right_eigenvectors.html","title":"right_eigenvectors – FORESEER"},{"text":"private function sub(lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Source Code sub Source Code function sub ( lhs , rhs ) result ( operator_result ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. class ( primitive_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible :: operator_result ) select type ( operator_result ) class is ( primitive_compressible ) operator_result = lhs select type ( rhs ) class is ( primitive_compressible ) operator_result % density = lhs % density - rhs % density operator_result % velocity = lhs % velocity - rhs % velocity operator_result % pressure = lhs % pressure - rhs % pressure endselect endselect endfunction sub","tags":"","loc":"proc/sub~2.html","title":"sub – FORESEER"},{"text":"private elemental subroutine destroy(self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FORESEER"},{"text":"private subroutine initialize(self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. Source Code initialize Source Code subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible ) self = initial_state endselect else call self % destroy endif endsubroutine initialize","tags":"","loc":"proc/initialize~2.html","title":"initialize – FORESEER"},{"text":"private pure subroutine prim_assign_prim(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Source Code prim_assign_prim Source Code pure subroutine prim_assign_prim ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( primitive_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure endselect endsubroutine prim_assign_prim","tags":"","loc":"proc/prim_assign_prim.html","title":"prim_assign_prim – FORESEER"},{"text":"public interface primitive_compressible Overload primitive_compressible name with its constructor. Calls interface~~primitive_compressible~~CallsGraph interface~primitive_compressible primitive_compressible proc~primitive_compressible_instance primitive_compressible_instance interface~primitive_compressible->proc~primitive_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures primitive_compressible_instance Module Procedures private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible .","tags":"","loc":"interface/primitive_compressible.html","title":"primitive_compressible – FORESEER"},{"text":"private pure subroutine compute_waves(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves Source Code pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. class ( riemann_solver_compressible_exact ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. type ( conservative_compressible ) :: fluxes !< Fluxes of the Riemann Problem solution. call self % solve ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal , & fluxes = fluxes ) waves ( 1 ) = self % S_1 waves ( 2 ) = self % S_2 waves ( 3 ) = self % u23 waves ( 4 ) = self % S_3 waves ( 5 ) = self % S_4 endsubroutine compute_waves","tags":"","loc":"proc/compute_waves.html","title":"compute_waves – FORESEER"},{"text":"private subroutine initialize(self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Calls proc~~initialize~3~~CallsGraph proc~initialize~3 initialize cton cton proc~initialize~3->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_exact ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local variable. config_ = '1.e-10' ; if ( present ( config )) config_ = config self % tolerance = cton ( config_ , knd = 1._R8P ) endsubroutine initialize","tags":"","loc":"proc/initialize~3.html","title":"initialize – FORESEER"},{"text":"private pure subroutine solve(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code solve Source Code pure subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_exact ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: dum , alfa , beta !< Dummies coefficients. real ( R8P ) :: p_2 , p_3 !< Pessure of state 2 and 3. real ( R8P ) :: dp2 , dp3 !< Derivate of pessure (dp/du) of state 2 and 3. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) ! initiale u23 speed if ( self % p_1 < self % p_4 ) then dum = 0.5_R8P * self % eos_4 % gm1 () / self % eos_4 % g () ! (gamma - 1) / (gamma * 2) else dum = 0.5_R8P * self % eos_1 % gm1 () / self % eos_1 % g () ! (gamma - 1) / (gamma * 2) endif alfa = ( self % p_1 / self % p_4 ) ** dum beta = alfa * self % eos_1 % delta () / self % a_1 + self % eos_4 % delta () / self % a_4 self % u23 = ( alfa - 1.0_R8P ) / beta + & 0.5_R8P * ( self % u_1 + self % u_4 ) + & 0.5_R8P * ( self % u_1 - self % u_4 ) * ( alfa * self % eos_1 % delta () / self % a_1 - self % eos_4 % delta () / self % a_4 ) / beta Newton : do call self % compute_states23_from_u23 ( p_2 = p_2 , p_3 = p_3 ) ! evaluate the Newton-Rapson convergence if ( abs ( 1.0_R8P - ( p_2 / p_3 )) >= self % tolerance ) then dp2 = - 1._R8P * self % eos_1 % g () * p_2 / self % a_2 dp3 = 1._R8P * self % eos_4 % g () * p_3 / self % a_3 self % u23 = self % u23 - (( p_2 - p_3 ) / ( dp2 - dp3 )) else self % p23 = p_2 ! p_2 ~= p_3 exit Newton endif enddo Newton call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve","tags":"","loc":"proc/solve.html","title":"solve – FORESEER"},{"text":"private pure subroutine compute_waves(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead\n of a non linear fan one. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves Source Code pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_hllc ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves","tags":"","loc":"proc/compute_waves~2.html","title":"compute_waves – FORESEER"},{"text":"private subroutine initialize(self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Source Code initialize Source Code subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_hllc ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local variable. config_ = 'up23' ; if ( present ( config )) config_ = config call self % solver_pvl % initialize ( config = config_ ) endsubroutine initialize","tags":"","loc":"proc/initialize~4.html","title":"initialize – FORESEER"},{"text":"private subroutine solve(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Calls proc~~solve~2~~CallsGraph proc~solve~2 solve proc~conservative_compressible_pointer conservative_compressible_pointer proc~solve~2->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code solve Source Code subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_hllc ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ) :: state23 !< Intermediate states. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: u23 !< Maximum wave speed estimation. state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) associate ( r_1 => self % solver_pvl % r_1 , u_1 => self % solver_pvl % u_1 , p_1 => self % solver_pvl % p_1 , g_1 => self % solver_pvl % eos_1 % g (), & r_4 => self % solver_pvl % r_4 , u_4 => self % solver_pvl % u_4 , p_4 => self % solver_pvl % p_4 , g_4 => self % solver_pvl % eos_4 % g (), & s_1 => self % solver_pvl % s_1 , s_4 => self % solver_pvl % s_4 , & E_1 => state_left_ % energy / state_left_ % density , E_4 => state_right_ % energy / state_right_ % density ) u23 = ( r_4 * u_4 * ( s_4 - u_4 ) - r_1 * u_1 * ( s_1 - u_1 ) + p_1 - p_4 ) / & ( r_4 * ( s_4 - u_4 ) - r_1 * ( s_1 - u_1 )) select case ( minloc ([ - s_1 , s_1 * u23 , u23 * s_4 , s_4 ], dim = 1 )) case ( 1 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes ) case ( 2 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes ) state23 % density = r_1 * ( s_1 - u_1 ) / ( s_1 - u23 ) state23 % momentum = state23 % density * u23 * normal state23 % energy = state23 % density * ( E_1 + ( u23 - u_1 ) * ( u23 + p_1 / ( r_1 * ( s_1 - u_1 )))) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + s_1 * ( state23 - state_left_ ) endselect case ( 3 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes ) state23 % density = r_4 * ( s_4 - u_4 ) / ( s_4 - u23 ) state23 % momentum = state23 % density * u23 * normal state23 % energy = state23 % density * ( E_4 + ( u23 - u_4 ) * ( u23 + p_4 / ( r_4 * ( s_4 - u_4 )))) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + s_4 * ( state23 - state_right_ ) endselect case ( 4 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes ) endselect endassociate endsubroutine solve","tags":"","loc":"proc/solve~2.html","title":"solve – FORESEER"},{"text":"private pure subroutine compute_waves(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead\n of a non linear fan one. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves Source Code pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves","tags":"","loc":"proc/compute_waves~3.html","title":"compute_waves – FORESEER"},{"text":"private subroutine initialize(self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Source Code initialize Source Code subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local variable. config_ = 'up23' ; if ( present ( config )) config_ = config call self % solver_pvl % initialize ( config = config_ ) endsubroutine initialize","tags":"","loc":"proc/initialize~5.html","title":"initialize – FORESEER"},{"text":"private subroutine solve(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Calls proc~~solve~3~~CallsGraph proc~solve~3 solve proc~conservative_compressible_pointer conservative_compressible_pointer proc~solve~3->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code solve Source Code subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on (local) Lax-Friedrichs (known also as Rusanov) algorithm. class ( riemann_solver_compressible_llf ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( conservative_compressible ) :: fluxes_left !< Fluxes of left state. type ( conservative_compressible ) :: fluxes_right !< Fluxes of right state. type ( conservative_compressible ) :: fluxes_ !< Fluxes, local variable. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: lmax !< Maximum wave speed estimation. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) lmax = maxval ( abs ( waves )) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) select type ( fluxes ) type is ( conservative_compressible ) #ifdef __GFORTRAN__ fluxes = 0.5_R8P * ( fluxes_left + fluxes_right - ( lmax * ( state_right_ - state_left_ ))) #else ! Intel Fortran has issue in resolving the equation with multiple operators... it must be split fluxes_ = state_right_ - state_left_ fluxes_ = lmax * fluxes_ fluxes = fluxes_left + fluxes_right fluxes = fluxes - fluxes_ fluxes = 0.5_R8P * fluxes #endif endselect endsubroutine solve","tags":"","loc":"proc/solve~3.html","title":"solve – FORESEER"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~4~~CallsGraph proc~description~4 description str str proc~description~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'r_1 = ' // trim ( str ( n = self % r_1 )) // NL desc = desc // prefix_ // 'u_1 = ' // trim ( str ( n = self % u_1 )) // NL desc = desc // prefix_ // 'p_1 = ' // trim ( str ( n = self % p_1 )) // NL desc = desc // prefix_ // 'a_1 = ' // trim ( str ( n = self % a_1 )) // NL desc = desc // prefix_ // 'r_4 = ' // trim ( str ( n = self % r_4 )) // NL desc = desc // prefix_ // 'u_4 = ' // trim ( str ( n = self % u_4 )) // NL desc = desc // prefix_ // 'p_4 = ' // trim ( str ( n = self % p_4 )) // NL desc = desc // prefix_ // 'a_4 = ' // trim ( str ( n = self % a_4 )) // NL desc = desc // prefix_ // 'u23 = ' // trim ( str ( n = self % u23 )) // NL desc = desc // prefix_ // 'p23 = ' // trim ( str ( n = self % p23 )) // NL desc = desc // prefix_ // 'r_2 = ' // trim ( str ( n = self % r_2 )) // NL desc = desc // prefix_ // 'a_2 = ' // trim ( str ( n = self % a_2 )) // NL desc = desc // prefix_ // 'r_3 = ' // trim ( str ( n = self % r_3 )) // NL desc = desc // prefix_ // 'a_3 = ' // trim ( str ( n = self % a_3 )) // NL desc = desc // prefix_ // 's_1 = ' // trim ( str ( n = self % s_1 )) // NL desc = desc // prefix_ // 's_2 = ' // trim ( str ( n = self % s_2 )) // NL desc = desc // prefix_ // 's_3 = ' // trim ( str ( n = self % s_3 )) // NL desc = desc // prefix_ // 's_4 = ' // trim ( str ( n = self % s_4 )) endfunction description","tags":"","loc":"proc/description~4.html","title":"description – FORESEER"},{"text":"private elemental subroutine compute_fluxes(self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Sampling the pattern, the interface states are computed. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . Source Code compute_fluxes Source Code elemental subroutine compute_fluxes ( self , eos_left , eos_right , normal , fluxes ) !< Compute fluxes at interface `x=xo`. !< !< Sampling the pattern, the interface states are computed. class ( riemann_solver_compressible_object ), intent ( in ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes at interface `x=xo`. real ( R8P ) :: a !< Speed of sound at interface `x=xo`. real ( R8P ) :: p !< Pressure at interface `x=xo`. real ( R8P ) :: r !< Desnity at interface `x=xo`. call fluxes % destroy associate ( s1 => self % s_1 , s2 => self % s_2 , u23 => self % u23 , s3 => self % s_3 , s4 => self % s_4 , & g1 => self % eos_1 % g (), d1 => self % eos_1 % delta (), e1 => self % eos_1 % eta (), & g4 => self % eos_4 % g (), d4 => self % eos_4 % delta (), e4 => self % eos_4 % eta (), & p1 => self % p_1 , r1 => self % r_1 , u1 => self % u_1 , a1 => self % a_1 , & p4 => self % p_4 , r4 => self % r_4 , u4 => self % u_4 , a4 => self % a_4 , & p23 => self % p23 , r2 => self % r_2 , r3 => self % r_3 ) select type ( fluxes ) class is ( conservative_compressible ) select case ( minloc ([ - s1 , s1 * s2 , s2 * u23 , u23 * s3 , s3 * s4 , s4 ], dim = 1 )) case ( 1 ) ! left supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p1 , r = r1 , u = u1 , normal = normal ) case ( 2 ) ! left transonic a = ( a1 + u1 * d1 ) / ( 1._R8P + d1 ) p = p1 * ( a / a1 ) ** e1 r = eos_left % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p , r = r , u = a , normal = normal ) case ( 3 ) ! left subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_left , p = p23 , r = r2 , u = u23 , normal = normal ) case ( 4 ) ! right subsonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p23 , r = r3 , u = u23 , normal = normal ) case ( 5 ) ! right transonic a = ( a4 - u4 * d4 ) / ( 1._R8P + d4 ) p = p4 * ( a / a4 ) ** e4 r = eos_right % density ( pressure = p , speed_of_sound = a ) call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p , r = r , u =- a , normal = normal ) case ( 6 ) ! right supersonic call fluxes % compute_fluxes_from_primitive ( eos = eos_right , p = p4 , r = r4 , u = u4 , normal = normal ) endselect endselect endassociate endsubroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~2.html","title":"compute_fluxes – FORESEER"},{"text":"private elemental subroutine compute_post_rarefaction(eos, sgn, u0, p0, a0, ux, rx, px, ax, s0, sx) Compute an unknown state x from a known state 0 when the two states are separated by a rarefaction, given the velocity ux . The sgn dummy argument indicates if the rarefaction propagates on u-a (sgn=-1) or u+a (sgn=1) . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: sgn Sign for distinguishing left (-1) from right (1) wave. real(kind=R8P), intent(in) :: u0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: p0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: a0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: ux Known speed of unknown state. real(kind=R8P), intent(out) :: rx Unknown pressure and density. real(kind=R8P), intent(out) :: px Unknown pressure and density. real(kind=R8P), intent(out) :: ax Unknown pressure and density. real(kind=R8P), intent(out) :: s0 Wave speeds (head and back fronts). real(kind=R8P), intent(out) :: sx Wave speeds (head and back fronts). Called By proc~~compute_post_rarefaction~~CalledByGraph proc~compute_post_rarefaction compute_post_rarefaction proc~compute_states23_from_u23 compute_states23_from_u23 proc~compute_states23_from_u23->proc~compute_post_rarefaction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_post_rarefaction Source Code elemental subroutine compute_post_rarefaction ( eos , sgn , u0 , p0 , a0 , ux , rx , px , ax , s0 , sx ) !< Compute an unknown state `x` from a known state `0` when the two states are separated by a rarefaction, given the velocity !< `ux`. !< !< The `sgn` dummy argument indicates if the rarefaction propagates on `u-a (sgn=-1)` or `u+a (sgn=1)`. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: sgn !< Sign for distinguishing *left* (-1) from *right* (1) wave. real ( R8P ), intent ( in ) :: u0 , p0 , a0 !< Known state (speed, pressure and speed of sound). real ( R8P ), intent ( in ) :: ux !< Known speed of unknown state. real ( R8P ), intent ( out ) :: rx , px , ax !< Unknown pressure and density. real ( R8P ), intent ( out ) :: s0 , sx !< Wave speeds (head and back fronts). ax = a0 + sgn * eos % delta () * ( ux - u0 ) ! unknown speed of sound px = p0 * (( ax / a0 ) ** ( eos % eta ())) ! unknown pressure rx = eos % density ( pressure = px , speed_of_sound = ax ) ! unknown density s0 = u0 + sgn * a0 ! left wave speed sx = ux + sgn * ax ! right wave speed endsubroutine compute_post_rarefaction","tags":"","loc":"proc/compute_post_rarefaction.html","title":"compute_post_rarefaction – FORESEER"},{"text":"private elemental subroutine compute_post_shock(eos, sgn, u0, p0, a0, ux, rx, px, ax, ss) Computing an unknown state x from a known state 0 when the two states are separated by a shock, given the velocity ux . The sgn dummy argument indicates if the shock propagates on u-a (sgn=-1) or u+a (sgn=1) . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: sgn Sign for distinguishing left (-1) from right (1) wave. real(kind=R8P), intent(in) :: u0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: p0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: a0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: ux Unknown speed. real(kind=R8P), intent(out) :: rx Unknown state (density, pressure and speed of sound). real(kind=R8P), intent(out) :: px Unknown state (density, pressure and speed of sound). real(kind=R8P), intent(out) :: ax Unknown state (density, pressure and speed of sound). real(kind=R8P), intent(out) :: ss Shock wave speed. Called By proc~~compute_post_shock~~CalledByGraph proc~compute_post_shock compute_post_shock proc~compute_states23_from_u23 compute_states23_from_u23 proc~compute_states23_from_u23->proc~compute_post_shock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_post_shock Source Code elemental subroutine compute_post_shock ( eos , sgn , u0 , p0 , a0 , ux , rx , px , ax , ss ) !< Computing an unknown state `x` from a known state `0` when the two states are separated by a shock, given the velocity !< `ux`. !< !< The `sgn` dummy argument indicates if the shock propagates on `u-a (sgn=-1)` or `u+a (sgn=1)`. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: sgn !< Sign for distinguishing *left* (-1) from *right* (1) wave. real ( R8P ), intent ( in ) :: u0 , p0 , a0 !< Known state (speed, pressure and speed of sound). real ( R8P ), intent ( in ) :: ux !< Unknown speed. real ( R8P ), intent ( out ) :: rx , px , ax !< Unknown state (density, pressure and speed of sound). real ( R8P ), intent ( out ) :: ss !< Shock wave speed. real ( R8P ) :: M0 !< Relative Mach number of known state. real ( R8P ) :: x !< Dummy variable. x = 0.25_R8P * eos % gp1 () * ( ux - u0 ) / a0 ! dummy variable M0 = x + sgn * sqrt ( 1.0_R8P + x * x ) ! relative Mach number of known state x = 1._R8P + 2._R8P * eos % g () * ( M0 * M0 - 1._R8P ) / eos % gp1 () ! dummy variable (pressure ratio px/p0) ax = a0 * sqrt (( eos % gp1 () + eos % gm1 () * x ) / ( eos % gp1 () + eos % gm1 () / x )) ! unknown speed of sound px = p0 * x ! unknown pressure rx = eos % density ( pressure = px , speed_of_sound = ax ) ! unknown density ss = u0 + a0 * M0 ! shock wave speed endsubroutine compute_post_shock","tags":"","loc":"proc/compute_post_shock.html","title":"compute_post_shock – FORESEER"},{"text":"private elemental subroutine compute_states23_from_u23(self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Note the pressure of interstates, that should be equal, are returned into separate arguments for allowing a convergence\n checking , namely if the approximation of u23 is exact the output is p_2=p_3=p23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. Calls proc~~compute_states23_from_u23~~CallsGraph proc~compute_states23_from_u23 compute_states23_from_u23 proc~compute_post_rarefaction compute_post_rarefaction proc~compute_states23_from_u23->proc~compute_post_rarefaction proc~compute_post_shock compute_post_shock proc~compute_states23_from_u23->proc~compute_post_shock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_states23_from_u23 Source Code elemental subroutine compute_states23_from_u23 ( self , p_2 , p_3 ) !< Compute interstates 2 and 3 given (an approximation of) veloctiy `S=u23`. !< !< @Note the pressure of interstates, that should be equal, are returned into separate arguments for allowing a *convergence !< checking*, namely if the approximation of `u23` is exact the output is `p_2=p_3=p23`. class ( riemann_solver_compressible_object ), intent ( inout ) :: self !< Solver. real ( R8P ), intent ( out ) :: p_2 !< Pressure of state 2. real ( R8P ), intent ( out ) :: p_3 !< Pressure of state 3. ! left wave if ( abs ( self % u23 - self % u_1 ) <= ZeroR8 ) then call compute_post_rarefaction ( eos = self % eos_1 , sgn =- 1._R8P , & u0 = self % u_1 , p0 = self % p_1 , a0 = self % a_1 , ux = self % u23 , & rx = self % r_2 , px = p_2 , ax = self % a_2 , s0 = self % S_1 , sx = self % S_2 ) else if ( self % u23 < self % u_1 ) then call compute_post_shock ( eos = self % eos_1 , sgn =- 1._R8P , & u0 = self % u_1 , p0 = self % p_1 , a0 = self % a_1 , ux = self % u23 , & rx = self % r_2 , px = p_2 , ax = self % a_2 , ss = self % S_1 ) self % S_2 = self % S_1 else call compute_post_rarefaction ( eos = self % eos_1 , sgn =- 1._R8P , & u0 = self % u_1 , p0 = self % p_1 , a0 = self % a_1 , ux = self % u23 , & rx = self % r_2 , px = p_2 , ax = self % a_2 , s0 = self % S_1 , sx = self % S_2 ) endif endif ! right wave if ( abs ( self % u23 - self % u_4 ) <= ZeroR8 ) then call compute_post_rarefaction ( eos = self % eos_4 , sgn = 1._R8P , & u0 = self % u_4 , p0 = self % p_4 , a0 = self % a_4 , ux = self % u23 , & rx = self % r_3 , px = p_3 , ax = self % a_3 , s0 = self % S_4 , sx = self % S_3 ) else if ( self % u23 > self % u_4 ) then call compute_post_shock ( eos = self % eos_4 , sgn = 1._R8P , & u0 = self % u_4 , p0 = self % p_4 , a0 = self % a_4 , ux = self % u23 , & rx = self % r_3 , px = p_3 , ax = self % a_3 , ss = self % S_4 ) self % S_3 = self % S_4 else call compute_post_rarefaction ( eos = self % eos_4 , sgn = 1._R8P , & u0 = self % u_4 , p0 = self % p_4 , a0 = self % a_4 , ux = self % u23 , & rx = self % r_3 , px = p_3 , ax = self % a_3 , s0 = self % S_4 , sx = self % S_3 ) endif endif endsubroutine compute_states23_from_u23","tags":"","loc":"proc/compute_states23_from_u23.html","title":"compute_states23_from_u23 – FORESEER"},{"text":"private elemental subroutine set_states14(self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. Source Code set_states14 Source Code elemental subroutine set_states14 ( self , eos_left , state_left , eos_right , state_right , normal ) !< Set states 1 and 4. class ( riemann_solver_compressible_object ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. select type ( eos_left ) class is ( eos_compressible ) self % eos_1 = eos_left endselect select type ( state_left ) class is ( conservative_compressible ) self % u_1 = state_left % velocity (). dot . normal self % p_1 = state_left % pressure ( eos = eos_left ) self % r_1 = state_left % density self % a_1 = eos_left % speed_of_sound ( density = state_left % density , pressure = self % p_1 ) endselect select type ( eos_right ) class is ( eos_compressible ) self % eos_4 = eos_right endselect select type ( state_right ) class is ( conservative_compressible ) self % u_4 = state_right % velocity (). dot . normal self % p_4 = state_right % pressure ( eos = eos_right ) self % r_4 = state_right % density self % a_4 = eos_right % speed_of_sound ( density = state_right % density , pressure = self % p_4 ) endselect endsubroutine set_states14","tags":"","loc":"proc/set_states14.html","title":"set_states14 – FORESEER"},{"text":"private elemental subroutine compute_u23(self) Compute interstates velocity. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. Source Code compute_u23 Source Code elemental subroutine compute_u23 ( self ) !< Compute interstates velocity. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. self % u23 = 0.5_R8P * ( self % u_1 + self % u_4 ) - 2.0_R8P * ( self % p_4 - self % p_1 ) / (( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 )) endsubroutine compute_u23","tags":"","loc":"proc/compute_u23.html","title":"compute_u23 – FORESEER"},{"text":"private elemental subroutine compute_up23(self) Compute interstates velocity and pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. Source Code compute_up23 Source Code elemental subroutine compute_up23 ( self ) !< Compute interstates velocity and pressure. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. real ( R8P ) :: ram !< Mean value of `r * a`. ram = 0.25_R8P * ( self % r_1 + self % r_4 ) * ( self % a_1 + self % a_4 ) self % u23 = 0.5_R8P * (( self % u_1 + self % u_4 ) - ( self % p_4 - self % p_1 ) / ram ) self % p23 = 0.5_R8P * (( self % p_1 + self % p_4 ) - ( self % u_4 - self % u_1 ) * ram ) endsubroutine compute_up23","tags":"","loc":"proc/compute_up23.html","title":"compute_up23 – FORESEER"},{"text":"private pure subroutine compute_waves(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead\n of a non linear fan one. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves Source Code pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % compute_waves_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves","tags":"","loc":"proc/compute_waves~4.html","title":"compute_waves – FORESEER"},{"text":"private pure subroutine compute_waves_u23(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Use Primitive Variables Linearization algorithm by means of only u23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves_u23 Source Code pure subroutine compute_waves_u23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. real ( R8P ) :: x !< Dummy variable. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_u23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock x = 0.25_R8P * ( self % eos_1 % g () + 1._R8P ) * ( self % u23 - self % u_1 ) / self % a_1 self % s_1 = self % u_1 + self % a_1 * ( x - sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock x = 0.25_R8P * ( self % eos_4 % g () + 1._R8P ) * ( self % u23 - self % u_4 ) / self % a_4 self % s_4 = self % u_4 + self % a_4 * ( x + sqrt ( 1.0_R8P + x * x )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_u23","tags":"","loc":"proc/compute_waves_u23.html","title":"compute_waves_u23 – FORESEER"},{"text":"private pure subroutine compute_waves_up23(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Use Primitive Variables Linearization algorithm by means of only up23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves_up23 Source Code pure subroutine compute_waves_up23 ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves speed `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % compute_up23 ! compute left state if ( self % u23 < self % u_1 ) then ! shock self % s_1 = self % u_1 - self % a_1 * sqrt ( 1._R8P + 0.5_R8P * ( self % eos_1 % g () + 1._R8P ) / & self % eos_1 % g () * ( self % p23 / self % p_1 - 1._R8P )) else ! rarefaction self % s_1 = self % u_1 - self % a_1 endif ! compute right state if ( self % u23 > self % u_4 ) then ! shock self % s_4 = self % u_4 + self % a_4 * sqrt ( 1._R8P + 0.5_R8P * ( self % eos_4 % g () + 1._R8P ) / & self % eos_4 % g () * ( self % p23 / self % p_4 - 1._R8P )) else ! rarefaction self % s_4 = self % u_4 + self % a_4 endif waves ( 1 ) = self % s_1 waves ( 2 ) = self % s_1 waves ( 3 ) = self % u23 waves ( 4 ) = self % s_4 waves ( 5 ) = self % s_4 endsubroutine compute_waves_up23","tags":"","loc":"proc/compute_waves_up23.html","title":"compute_waves_up23 – FORESEER"},{"text":"private subroutine initialize(self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Source Code initialize Source Code subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. character ( len = :), allocatable :: config_ !< Configuration for solver algorithm, local var. self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 config_ = '' ; if ( present ( config )) config_ = config select case ( config_ ) case ( 'u23' ) self % compute_waves_ => compute_waves_u23 self % solve_ => solve_u23 case ( 'up23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 case ( 'upr23' ) self % compute_waves_ => compute_waves_up23 self % solve_ => solve_up23 endselect endsubroutine initialize","tags":"","loc":"proc/initialize~6.html","title":"initialize – FORESEER"},{"text":"private pure subroutine solve(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code solve Source Code pure subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. call self % solve_ ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , fluxes = fluxes ) endsubroutine solve","tags":"","loc":"proc/solve~4.html","title":"solve – FORESEER"},{"text":"private pure subroutine solve_u23(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem by u23 algorithm. Use Primitive Variables Linearization algorithm by means of only u23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code solve_u23 Source Code pure subroutine solve_u23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem by `u23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `u23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_u23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_u23","tags":"","loc":"proc/solve_u23.html","title":"solve_u23 – FORESEER"},{"text":"private pure subroutine solve_up23(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem up23 algorithm. Use Primitive Variables Linearization algorithm by means of only up23 approximation. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Riemann pattern. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code solve_up23 Source Code pure subroutine solve_up23 ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann problem `up23` algorithm. !< !< Use Primitive Variables Linearization algorithm by means of only `up23` approximation. class ( riemann_solver_compressible_pvl ), intent ( inout ) :: self !< Riemann pattern. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. call self % compute_waves_up23 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) call self % compute_fluxes ( eos_left = eos_left , eos_right = eos_right , normal = normal , fluxes = fluxes ) endsubroutine solve_up23","tags":"","loc":"proc/solve_up23.html","title":"solve_up23 – FORESEER"},{"text":"private subroutine compute_roe_state(eos_left, state_left, eos_right, state_right, r_d, r_u, r_e, r_a) Evaluate the intermediate state from the known states U1,U4 using the Roe linearization. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. real(kind=R8P), intent(out) :: r_d Roe intermediate state density. type(vector), intent(out) :: r_u Roe intermediate state velocity vector.. real(kind=R8P), intent(out) :: r_e Roe intermediate state enthalpy. real(kind=R8P), intent(out) :: r_a Roe intermediate state sound speed. Calls proc~~compute_roe_state~~CallsGraph proc~compute_roe_state compute_roe_state proc~eos_compressible_pointer eos_compressible_pointer proc~compute_roe_state->proc~eos_compressible_pointer proc~conservative_compressible_pointer conservative_compressible_pointer proc~compute_roe_state->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~compute_roe_state~~CalledByGraph proc~compute_roe_state compute_roe_state proc~solve~5 solve proc~solve~5->proc~compute_roe_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_roe_state Source Code subroutine compute_roe_state ( eos_left , state_left , eos_right , state_right , r_d , r_u , r_e , r_a ) !< Evaluate the intermediate state from the known states U1,U4 using the Roe linearization. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. real ( R8P ), intent ( out ) :: r_d !< Roe intermediate state density. type ( vector ), intent ( out ) :: r_u !< Roe intermediate state velocity vector.. real ( R8P ), intent ( out ) :: r_e !< Roe intermediate state enthalpy. real ( R8P ), intent ( out ) :: r_a !< Roe intermediate state sound speed. real ( R8P ) :: x , omx !< x = sqrt(r1)/(sqrt(r1)+sqrt(r4)),  omx = 1-x real ( R8P ) :: cp , cv !< Roe intermediate state Cp and Cv. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( eos_compressible ), pointer :: eos_left_ !< Left Riemann state, local variable. type ( eos_compressible ), pointer :: eos_right_ !< Right Riemann state, local variable. state_left_ => conservative_compressible_pointer ( to = state_left ) state_right_ => conservative_compressible_pointer ( to = state_right ) eos_left_ => eos_compressible_pointer ( to = eos_left ) eos_right_ => eos_compressible_pointer ( to = eos_right ) x = sqrt ( state_left_ % density ) / ( sqrt ( state_left_ % density ) + sqrt ( state_right_ % density )) ; omx = 1._R8P - x r_d = sqrt ( state_left_ % density * state_right_ % density ) r_u % x = state_left_ % momentum % x / state_left_ % density * x + state_right_ % momentum % x / state_right_ % density * omx r_u % y = state_left_ % momentum % y / state_left_ % density * x + state_right_ % momentum % y / state_right_ % density * omx r_u % z = state_left_ % momentum % z / state_left_ % density * x + state_right_ % momentum % z / state_right_ % density * omx r_e = ( state_left_ % energy + state_left_ % pressure ( eos_left )) / state_left_ % density * x + & ( state_right_ % energy + state_right_ % pressure ( eos_right )) / state_right_ % density * omx cp = eos_left_ % cp_ * x + eos_right_ % cp_ * omx cv = eos_left_ % cv_ * x + eos_right_ % cv_ * omx r_a = sqrt (( cp / cv - 1._R8P ) * ( r_e - 0.5_R8P * r_u % sq_norm ())) endsubroutine compute_roe_state","tags":"","loc":"proc/compute_roe_state.html","title":"compute_roe_state – FORESEER"},{"text":"private pure subroutine compute_waves(self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead\n of a non linear fan one. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. Source Code compute_waves Source Code pure subroutine compute_waves ( self , eos_left , state_left , eos_right , state_right , normal , waves ) !< Compute waves pattern. !< !< The PVL approximation is based on a 3 waves pattern where the acoustic waves are reduced to a single linear wave instead !< of a non linear fan one. class ( riemann_solver_compressible_roe ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. real ( R8P ), intent ( out ) :: waves ( 1 :) !< Waves pattern. call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) endsubroutine compute_waves","tags":"","loc":"proc/compute_waves~5.html","title":"compute_waves – FORESEER"},{"text":"private subroutine initialize(self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. Source Code initialize Source Code subroutine initialize ( self , config ) !< Initialize solver. class ( riemann_solver_compressible_roe ), intent ( inout ) :: self !< Solver. character ( len =* ), intent ( in ), optional :: config !< Configuration for solver algorithm. call self % solver_pvl % initialize ( config = 'u23' ) endsubroutine initialize","tags":"","loc":"proc/initialize~7.html","title":"initialize – FORESEER"},{"text":"private subroutine solve(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Approximate Riemann Solver based on Roe (with Harten-Hyman entropy fix) algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Calls proc~~solve~5~~CallsGraph proc~solve~5 solve proc~compute_roe_state compute_roe_state proc~solve~5->proc~compute_roe_state proc~eos_compressible_pointer eos_compressible_pointer proc~compute_roe_state->proc~eos_compressible_pointer proc~conservative_compressible_pointer conservative_compressible_pointer proc~compute_roe_state->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code solve Source Code subroutine solve ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Solve Riemann Problem. !< !< Approximate Riemann Solver based on Roe (with Harten-Hyman entropy fix) algorithm. class ( riemann_solver_compressible_roe ), intent ( inout ) :: self !< Solver. class ( eos_object ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_object ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_object ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_object ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( conservative_compressible ), pointer :: state_left_ !< Left Riemann state, local variable. type ( conservative_compressible ), pointer :: state_right_ !< Right Riemann state, local variable. type ( conservative_compressible ) :: fluxes_left !< Fluxes of left state. type ( conservative_compressible ) :: fluxes_right !< Fluxes of right state. type ( conservative_compressible ) :: state23 !< Intermediate states. real ( R8P ) :: r_d !< Roe intermediate state density. type ( vector ) :: r_u !< Roe intermediate state velocity vector.. real ( R8P ) :: r_e !< Roe intermediate state enthalpy. real ( R8P ) :: r_a !< Roe intermediate state sound speed. real ( R8P ) :: waves ( 1 : 5 ) !< Waves speed pattern. real ( R8P ) :: lmax !< Maximum wave speed estimation. type ( vector ) :: vec_a !< Vector of sound speeds, local variable. type ( vector ) :: vec_r !< Vector of densities, local variable. type ( vector ) :: vec_m !< Vector of momentums, local variable. type ( vector ) :: vec_e !< Vector of energies, local variable. real ( R8P ) :: Dr !< Density difference  Dr = r4-r1. real ( R8P ) :: Du !< Velocity difference Du = u4-u1. real ( R8P ) :: Dp !< Pressure difference Dp = p4-p1. real ( R8P ) :: aa1 , aa2 , aa3 !< Wawes amplitudes Roe's estimation. real ( R8P ) :: ll1 , ll2 , ll3 !< Wawes speeds Roe's estimation. real ( R8P ) :: ls1 , ls3 !< Wawes speeds Roe's estimation with entropy fix of Harten-Hyman. real ( R8P ) :: p_2 , p_3 !< Pessure of state 2 and 3. real ( R8P ) :: u23 !< Maximum wave speed estimation. call self % set_states14 ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , normal = normal ) call self % solver_pvl % compute_waves ( eos_left = eos_left , state_left = state_left , eos_right = eos_right , state_right = state_right , & normal = normal , waves = waves ) associate ( r_1 => self % solver_pvl % r_1 , u_1 => self % solver_pvl % u_1 , p_1 => self % solver_pvl % p_1 , & r_4 => self % solver_pvl % r_4 , u_4 => self % solver_pvl % u_4 , p_4 => self % solver_pvl % p_4 , & s_1 => self % s_1 , s_2 => self % s_2 , s_3 => self % s_3 , s_4 => self % s_4 , u23 => self % u23 ) s_1 = waves ( 1 ) u23 = waves ( 3 ) s_4 = waves ( 5 ) call self % compute_states23_from_u23 ( p_2 = p_2 , p_3 = p_3 ) select case ( minloc ([ - s_1 , s_1 * s_2 , s_2 * u23 , u23 * s_3 , s_3 * s_4 , s_4 ], dim = 1 )) case ( 1 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) case ( 2 ) call compute_roe_state ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , & r_d = r_d , r_u = r_u , r_e = r_e , r_a = r_a ) Du = u_4 - u_1 Dp = p_4 - p_1 aa1 = 0.5_R8P * ( Dp - r_d * r_a * Du ) / ( r_a * r_a ) ll1 = ( r_u . dot . normal ) - r_a ls1 = s_1 * ( s_2 - ll1 ) / ( s_2 - s_1 ) call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) state23 % density = aa1 state23 % momentum = aa1 * ll1 * normal state23 % energy = aa1 * ( r_e - ( r_u . dot . normal ) * r_a ) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + ls1 * state23 endselect case ( 3 , 4 ) call compute_roe_state ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , & r_d = r_d , r_u = r_u , r_e = r_e , r_a = r_a ) Dr = r_4 - r_1 Du = u_4 - u_1 Dp = p_4 - p_1 aa1 = 0.5_R8P * ( Dp - r_d * r_a * Du ) / ( r_a * r_a ) aa2 = Dr - Dp / ( r_a * r_a ) aa3 = 0.5_R8P * ( Dp + r_d * r_a * Du ) / ( r_a * r_a ) ll1 = ( r_u . dot . normal ) - r_d ll2 = ( r_u . dot . normal ) ll3 = ( r_u . dot . normal ) + r_d call state_left % compute_fluxes ( eos = eos_left , normal = normal , fluxes = fluxes_left ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) vec_a % x = abs ( ll1 ) ; vec_a % y = abs ( ll2 ) ; vec_a % z = abs ( ll3 ) vec_r % x = aa1 ; vec_r % y = aa2 ; vec_r % z = aa3 vec_m % x = aa1 * ll1 ; vec_m % y = aa2 * ll2 ; vec_m % z = aa3 * ll3 vec_e % x = aa1 * ( r_e - ( r_u . dot . normal ) * r_a ); vec_e % y = aa2 * 0.5_R8P * ll2 * ll2 vec_e % x = aa3 * ( r_e - ( r_u . dot . normal ) * r_a ) state23 % density = vec_a . dot . vec_r state23 % momentum = ( vec_a . dot . vec_m ) * normal state23 % energy = vec_a . dot . vec_e select type ( fluxes ) type is ( conservative_compressible ) fluxes = 0.5_R8P * ( fluxes_left + fluxes_right - state23 ) endselect case ( 5 ) call compute_roe_state ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , & r_d = r_d , r_u = r_u , r_e = r_e , r_a = r_a ) Du = u_4 - u_1 Dp = p_4 - p_1 aa3 = 0.5_R8P * ( Dp - r_d * r_a * Du ) / ( r_a * r_a ) ll3 = ( r_u . dot . normal ) - r_a ls3 = s_4 * ( ll3 - s_3 ) / ( s_4 - s_3 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) state23 % density = aa3 state23 % momentum = aa3 * ll3 * normal state23 % energy = aa3 * ( r_e - ( r_u . dot . normal ) * r_a ) select type ( fluxes ) type is ( conservative_compressible ) fluxes = fluxes + ls3 * state23 endselect case ( 6 ) call state_right % compute_fluxes ( eos = eos_right , normal = normal , fluxes = fluxes_right ) endselect endassociate endsubroutine solve","tags":"","loc":"proc/solve~5.html","title":"solve – FORESEER"},{"text":"private function add_euler(lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code add_euler Source Code function add_euler ( lhs , rhs ) result ( opr ) !< Add two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) + rhs % U ( i ) enddo endselect endselect endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – FORESEER"},{"text":"private pure function compute_dt(self, steps_max, t_max, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. integer(kind=I4P), intent(in) :: steps_max Maximun number of time steps. real(kind=R8P), intent(in) :: t_max Maximum integration time. real(kind=R8P), intent(in) :: t Time. real(kind=R8P), intent(in) :: CFL CFL value. Return Value real(kind=R8P) Time step. Source Code compute_dt Source Code pure function compute_dt ( self , steps_max , t_max , t , CFL ) result ( Dt ) !< Compute the current time step by means of CFL condition. class ( euler_1d ), intent ( in ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: steps_max !< Maximun number of time steps. real ( R8P ), intent ( in ) :: t_max !< Maximum integration time. real ( R8P ), intent ( in ) :: t !< Time. real ( R8P ), intent ( in ) :: CFL !< CFL value. real ( R8P ) :: Dt !< Time step. type ( vector ) :: u !< Velocity vector. real ( R8P ) :: a !< Speed of sound. real ( R8P ) :: vmax !< Maximum propagation speed of signals. integer ( I4P ) :: i !< Counter. associate ( Ni => self % Ni , Dx => self % Dx ) vmax = 0._R8P do i = 1 , Ni u = self % U ( i )% velocity () a = self % eos % speed_of_sound ( density = self % U ( i )% density , pressure = self % U ( i )% pressure ( eos = self % eos )) vmax = max ( vmax , u % normL2 () + a ) enddo Dt = Dx * CFL / vmax if ( steps_max <= 0 . and . t_max > 0._R8P ) then if (( t + Dt ) > t_max ) Dt = t_max - t endif endassociate endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – FORESEER"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. real(kind=R8P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. Source Code dEuler_dt Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !< Time derivative of Euler field, the residuals function. class ( euler_1d ), intent ( in ) :: self !< Euler field. real ( R8P ), intent ( in ), optional :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. type ( conservative_compressible ) :: U ( 1 - self % Ng : self % Ni + self % Ng ) !< Conservative variables. type ( conservative_compressible ) :: UR ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed conservative variables. type ( conservative_compressible ) :: F ( 0 : self % Ni ) !< Fluxes of conservative variables. integer ( I4P ) :: i !< Counter. do i = 1 , self % Ni U ( i ) = self % U ( i ) enddo call self % impose_boundary_conditions ( U = U ) call self % reconstruct_interfaces ( conservative = U , r_conservative = UR ) do i = 0 , self % Ni call self % riemann_solver ( eos_left = self % eos , state_left = UR ( 2 , i ), & eos_right = self % eos , state_right = UR ( 1 , i + 1 ), normal = ex , fluxes = F ( i )) enddo allocate ( euler_1d :: dState_dt ) select type ( dState_dt ) class is ( euler_1d ) dState_dt = self do i = 1 , self % Ni dState_dt % U ( i ) = ( F ( i - 1 ) - F ( i )) / self % Dx enddo endselect endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – FORESEER"},{"text":"private function euler_local_error(lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. Source Code euler_local_error Source Code function euler_local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. real ( R8P ) :: error !< Error estimation. real ( R8P ), allocatable :: U_lhs (:) !< Serialized conservative variables. real ( R8P ), allocatable :: U_rhs (:) !< Serialized conservative variables. integer ( I4P ) :: i !< Space counter. integer ( I4P ) :: v !< Variables counter. select type ( rhs ) class is ( euler_1d ) error = 0._R8P do i = 1 , lhs % Ni U_lhs = lhs % U ( i )% array () U_rhs = rhs % U ( i )% array () do v = 1 , size ( U_lhs , dim = 1 ) error = error + ( U_lhs ( v ) - U_rhs ( v )) ** 2 / U_lhs ( v ) ** 2 enddo enddo error = sqrt ( error ) endselect endfunction euler_local_error","tags":"","loc":"proc/euler_local_error.html","title":"euler_local_error – FORESEER"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_euler Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by another one. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) * rhs % U ( i ) enddo endselect endselect endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – FORESEER"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_real Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !< Multiply an Euler field by a real scalar. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs do i = 1 , lhs % Ni opr % U ( i ) = rhs * lhs % U ( i ) enddo endselect endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – FORESEER"},{"text":"private pure function output(self, is_primitive) result(state) Output the Euler field state. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. logical, intent(in), optional :: is_primitive Output in primitive variables. Return Value real(kind=R8P),\n  allocatable,(:,:) Euler state vector. Calls proc~~output~~CallsGraph proc~output output proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~output->proc~conservative_to_primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code output Source Code pure function output ( self , is_primitive ) result ( state ) !< Output the Euler field state. class ( euler_1d ), intent ( in ) :: self !< Euler field. logical , intent ( in ), optional :: is_primitive !< Output in primitive variables. real ( R8P ), allocatable :: state (:,:) !< Euler state vector. real ( R8P ), allocatable :: state_ (:) !< Euler state vector, local variable. logical :: is_primitive_ !< Output in primitive variables, local variable. type ( primitive_compressible ) :: primitive !< Primitive state. integer ( I4P ) :: i !< Counter. is_primitive_ = . false . ; if ( present ( is_primitive )) is_primitive_ = is_primitive if ( is_primitive_ ) then allocate ( state ( 1 : size ( primitive % array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni primitive = conservative_to_primitive_compressible ( conservative = self % U ( i ), eos = self % eos ) state_ = primitive % array () enddo else allocate ( state ( 1 : size ( self % U ( 1 )% array (), dim = 1 ), 1 : self % Ni )) do i = 1 , self % Ni state_ = self % U ( i )% array () state (:, i ) = state_ enddo endif endfunction output","tags":"","loc":"proc/output.html","title":"output – FORESEER"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code real_multiply_euler Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !< Multiply a real scalar by an Euler field. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( euler_1d ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = rhs do i = 1 , rhs % Ni opr % U ( i ) = lhs * rhs % U ( i ) enddo endselect endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – FORESEER"},{"text":"private function sub_euler(lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code sub_euler Source Code function sub_euler ( lhs , rhs ) result ( opr ) !< Subtract two Euler fields. class ( euler_1d ), intent ( in ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I4P ) :: i !< Counter. allocate ( euler_1d :: opr ) select type ( opr ) class is ( euler_1d ) opr = lhs select type ( rhs ) class is ( euler_1d ) do i = 1 , lhs % Ni opr % U ( i ) = lhs % U ( i ) - rhs % U ( i ) enddo endselect endselect endfunction sub_euler","tags":"","loc":"proc/sub_euler.html","title":"sub_euler – FORESEER"},{"text":"private pure subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. Source Code destroy Source Code pure subroutine destroy ( self ) !< Destroy field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. self % weno_order = 0 self % Ni = 0 self % Ng = 0 self % Dx = 0._R8P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) if ( allocated ( self % interpolator )) deallocate ( self % interpolator ) endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FORESEER"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Source Code euler_assign_euler Source Code subroutine euler_assign_euler ( lhs , rhs ) !< Assign one Euler field to another. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. class ( integrand ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. select type ( rhs ) class is ( euler_1d ) lhs % weno_order = rhs % weno_order lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Dx = rhs % Dx lhs % eos = rhs % eos if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Ni )) select type ( rhs ) class is ( euler_1d ) if ( allocated ( rhs % U )) then do i = 1 , lhs % Ni lhs % U ( i ) = rhs % U ( i ) enddo endif endselect endif if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R if ( allocated ( rhs % interpolator )) then if ( allocated ( lhs % interpolator )) deallocate ( lhs % interpolator ) allocate ( lhs % interpolator , source = rhs % interpolator ) endif if ( associated ( rhs % reconstruct_interfaces )) lhs % reconstruct_interfaces => rhs % reconstruct_interfaces if ( associated ( rhs % riemann_solver )) lhs % riemann_solver => rhs % riemann_solver endselect endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – FORESEER"},{"text":"private subroutine euler_assign_real(lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Source Code euler_assign_real Source Code subroutine euler_assign_real ( lhs , rhs ) !< Assign one real to an Euler field. class ( euler_1d ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: i !< Counter. if ( allocated ( lhs % U )) then do i = 1 , lhs % Ni lhs % U ( i )% density = rhs lhs % U ( i )% momentum = rhs lhs % U ( i )% energy = rhs enddo endif endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – FORESEER"},{"text":"private pure subroutine impose_boundary_conditions(self, U) Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(inout) :: U (1-self%Ng:) Conservative variables. Source Code impose_boundary_conditions Source Code pure subroutine impose_boundary_conditions ( self , U ) !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( inout ) :: U ( 1 - self % Ng :) !< Conservative variables. ! type(primitive_compressible), intent(inout) :: P(1-self%Ng:) !< Primitive variables. integer ( I4P ) :: i !< Space counter. select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 ! P(i) = P(-i+1) U ( i ) = U ( - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 ! P(i)%density  =   P(-i+1)%density ! P(i)%velocity = - P(-i+1)%velocity ! P(i)%pressure =   P(-i+1)%pressure U ( i )% density = U ( - i + 1 )% density U ( i )% momentum = - U ( - i + 1 )% momentum U ( i )% energy = U ( - i + 1 )% energy enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i) = P(self%Ni-(i-self%Ni-1)) U ( i ) = U ( self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng ! P(i)%density  =   P(self%Ni-(i-self%Ni-1))%density ! P(i)%velocity = - P(self%Ni-(i-self%Ni-1))%velocity ! P(i)%pressure =   P(self%Ni-(i-self%Ni-1))%pressure U ( i )% density = U ( self % Ni - ( i - self % Ni - 1 ))% density U ( i )% momentum = - U ( self % Ni - ( i - self % Ni - 1 ))% momentum U ( i )% energy = U ( self % Ni - ( i - self % Ni - 1 ))% energy enddo endselect endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – FORESEER"},{"text":"private subroutine initialize(self, Ni, Dx, BC_L, BC_R, initial_state, eos, weno_order, weno_variables, riemann_solver_scheme) Initialize field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. integer(kind=I4P), intent(in) :: Ni Space dimension. real(kind=R8P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. type( primitive_compressible ), intent(in) :: initial_state (1:) Initial state of primitive variables. type( eos_compressible ), intent(in) :: eos Equation of state. integer(kind=I4P), intent(in), optional :: weno_order WENO reconstruction order. character(len=*), intent(in), optional :: weno_variables Variables on which WENO reconstruction is done. character(len=*), intent(in), optional :: riemann_solver_scheme Riemann solver scheme. Calls proc~~initialize~8~~CallsGraph proc~initialize~8 initialize proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~initialize~8->proc~primitive_to_conservative_compressible wenoof_create wenoof_create proc~initialize~8->wenoof_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , Ni , Dx , BC_L , BC_R , initial_state , eos , weno_order , weno_variables , riemann_solver_scheme ) !< Initialize field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: Ni !< Space dimension. real ( R8P ), intent ( in ) :: Dx !< Space step. character ( * ), intent ( in ) :: BC_L !< Left boundary condition type. character ( * ), intent ( in ) :: BC_R !< Right boundary condition type. type ( primitive_compressible ), intent ( in ) :: initial_state ( 1 :) !< Initial state of primitive variables. type ( eos_compressible ), intent ( in ) :: eos !< Equation of state. integer ( I4P ), intent ( in ), optional :: weno_order !< WENO reconstruction order. character ( * ), intent ( in ), optional :: weno_variables !< Variables on which WENO reconstruction is done. character ( * ), intent ( in ), optional :: riemann_solver_scheme !< Riemann solver scheme. character (:), allocatable :: weno_variables_ !< WENO Variables, local variable. character (:), allocatable :: riemann_solver_scheme_ !< Riemann solver scheme, local variable. integer ( I4P ) :: i !< Space couner. call self % destroy self % weno_order = 1 ; if ( present ( weno_order )) self % weno_order = weno_order self % Ni = Ni self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = Dx self % eos = eos if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 - self % Ng : self % Ni + self % Ng )) do i = 1 , Ni self % U ( i ) = primitive_to_conservative_compressible ( primitive = initial_state ( i ), eos = eos ) enddo self % BC_L = BC_L self % BC_R = BC_R if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = self % interpolator ) weno_variables_ = 'characteristic' if ( present ( weno_variables )) weno_variables_ = trim ( adjustl ( weno_variables )) select case ( weno_variables_ ) case ( 'characteristic' ) self % reconstruct_interfaces => reconstruct_interfaces_characteristic case ( 'conservative' ) self % reconstruct_interfaces => reconstruct_interfaces_conservative case ( 'primitive' ) self % reconstruct_interfaces => reconstruct_interfaces_primitive case default write ( stderr , '(A)' ) 'error: WENO reconstruction variables set \"' // weno_variables_ // '\" unknown!' stop endselect riemann_solver_scheme_ = 'llf' if ( present ( riemann_solver_scheme )) riemann_solver_scheme_ = trim ( adjustl ( riemann_solver_scheme )) select case ( riemann_solver_scheme_ ) case ( 'exact' ) self % riemann_solver => riemann_solver_exact case ( 'hllc' ) self % riemann_solver => riemann_solver_hllc case ( 'llf' ) self % riemann_solver => riemann_solver_llf case ( 'pvl' ) self % riemann_solver => riemann_solver_pvl case ( 'roe' ) self % riemann_solver => riemann_solver_roe case default write ( stderr , '(A)' ) 'error: Riemann Solver scheme \"' // riemann_solver_scheme_ // '\" unknown!' stop endselect endsubroutine initialize","tags":"","loc":"proc/initialize~8.html","title":"initialize – FORESEER"},{"text":"private subroutine reconstruct_interfaces_characteristic(self, conservative, r_conservative) Reconstruct interfaces states. The reconstruction is done in pseudo characteristic variables. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. Calls proc~~reconstruct_interfaces_characteristic~~CallsGraph proc~reconstruct_interfaces_characteristic reconstruct_interfaces_characteristic proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~reconstruct_interfaces_characteristic->proc~conservative_to_primitive_compressible wenoof_create wenoof_create proc~reconstruct_interfaces_characteristic->wenoof_create proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~reconstruct_interfaces_characteristic->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code reconstruct_interfaces_characteristic Source Code subroutine reconstruct_interfaces_characteristic ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in pseudo characteristic variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. type ( primitive_compressible ) :: Pm ( 1 : 2 ) !< Mean of primitive variables. real ( R8P ) :: LPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R8P ) :: RPm ( 1 : 3 , 1 : 3 , 1 : 2 ) !< Mean right eigenvectors matrix. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. real ( R8P ) :: buffer ( 1 : 3 ) !< Dummy buffer. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 ! compute pseudo charteristic variables do f = 1 , 2 Pm ( f ) = 0.5_R8P * ( primitive ( i + f - 2 ) + primitive ( i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = Pm ( f )% left_eigenvectors ( eos = self % eos ) RPm (:, :, f ) = Pm ( f )% right_eigenvectors ( eos = self % eos ) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , 3 C ( f , j - i , v ) = dot_product ( LPm ( v , :, f ), [ primitive ( j )% density , primitive ( j )% velocity % x , primitive ( j )% pressure ]) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , 3 buffer ( v ) = dot_product ( RPm ( v , :, f ), CR ( f , :)) enddo r_primitive ( f , i )% density = buffer ( 1 ) r_primitive ( f , i )% velocity = buffer ( 2 ) * ex r_primitive ( f , i )% pressure = buffer ( 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_characteristic","tags":"","loc":"proc/reconstruct_interfaces_characteristic.html","title":"reconstruct_interfaces_characteristic – FORESEER"},{"text":"private subroutine reconstruct_interfaces_conservative(self, conservative, r_conservative) Reconstruct interfaces states. The reconstruction is done in conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. Calls proc~~reconstruct_interfaces_conservative~~CallsGraph proc~reconstruct_interfaces_conservative reconstruct_interfaces_conservative wenoof_create wenoof_create proc~reconstruct_interfaces_conservative->wenoof_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code reconstruct_interfaces_conservative Source Code subroutine reconstruct_interfaces_conservative ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in conservative variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. real ( R8P ), allocatable :: U (:) !< Serialized conservative variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng U = conservative ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = U ( 1 ) C ( f , j - i , 2 ) = U ( 2 ) C ( f , j - i , 3 ) = U ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_conservative ( f , i )% density = CR ( f , 1 ) r_conservative ( f , i )% momentum = CR ( f , 2 ) * ex r_conservative ( f , i )% energy = CR ( f , 3 ) enddo enddo endselect endsubroutine reconstruct_interfaces_conservative","tags":"","loc":"proc/reconstruct_interfaces_conservative.html","title":"reconstruct_interfaces_conservative – FORESEER"},{"text":"private subroutine reconstruct_interfaces_primitive(self, conservative, r_conservative) Reconstruct interfaces states. The reconstruction is done in primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. Calls proc~~reconstruct_interfaces_primitive~~CallsGraph proc~reconstruct_interfaces_primitive reconstruct_interfaces_primitive proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~reconstruct_interfaces_primitive->proc~conservative_to_primitive_compressible wenoof_create wenoof_create proc~reconstruct_interfaces_primitive->wenoof_create proc~primitive_to_conservative_compressible primitive_to_conservative_compressible proc~reconstruct_interfaces_primitive->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code reconstruct_interfaces_primitive Source Code subroutine reconstruct_interfaces_primitive ( self , conservative , r_conservative ) !< Reconstruct interfaces states. !< !< The reconstruction is done in primitive variables. class ( euler_1d ), intent ( in ) :: self !< Euler field. type ( conservative_compressible ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. type ( conservative_compressible ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. type ( primitive_compressible ) :: primitive ( 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. type ( primitive_compressible ) :: r_primitive ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R8P ), allocatable :: P (:) !< Serialized primitive variables. real ( R8P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : 3 ) !< Pseudo characteristic variables. real ( R8P ) :: CR ( 1 : 2 , 1 : 3 ) !< Pseudo characteristic reconst. integer ( I4P ) :: i !< Counter. integer ( I4P ) :: j !< Counter. integer ( I4P ) :: f !< Counter. integer ( I4P ) :: v !< Counter. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction call wenoof_create ( interpolator_type = 'reconstructor-JS' , & S = self % Ng , & interpolator = interpolator ) do i = 1 - self % Ng , self % Ni + self % Ng primitive ( i ) = conservative_to_primitive_compressible ( conservative = conservative ( i ), eos = self % eos ) enddo do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng P = primitive ( j )% array () do f = 1 , 2 C ( f , j - i , 1 ) = P ( 1 ) C ( f , j - i , 2 ) = P ( 2 ) C ( f , j - i , 3 ) = P ( 5 ) enddo enddo do v = 1 , 3 call interpolator % interpolate ( stencil = C (:, :, v ), interpolation = CR (:, v )) enddo do f = 1 , 2 r_primitive ( f , i )% density = CR ( f , 1 ) r_primitive ( f , i )% velocity = CR ( f , 2 ) * ex r_primitive ( f , i )% pressure = CR ( f , 3 ) enddo enddo do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 1 , i ), eos = self % eos ) r_conservative ( 2 , i ) = primitive_to_conservative_compressible ( primitive = r_primitive ( 2 , i ), eos = self % eos ) enddo endselect endsubroutine reconstruct_interfaces_primitive","tags":"","loc":"proc/reconstruct_interfaces_primitive.html","title":"reconstruct_interfaces_primitive – FORESEER"},{"text":"private subroutine riemann_solver_exact(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of exact (Newton iterative) algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code riemann_solver_exact Source Code subroutine riemann_solver_exact ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of exact (Newton iterative) algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_exact ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_exact","tags":"","loc":"proc/riemann_solver_exact.html","title":"riemann_solver_exact – FORESEER"},{"text":"private subroutine riemann_solver_hllc(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of HLLC algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code riemann_solver_hllc Source Code subroutine riemann_solver_hllc ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of HLLC algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_hllc ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_hllc","tags":"","loc":"proc/riemann_solver_hllc.html","title":"riemann_solver_hllc – FORESEER"},{"text":"private subroutine riemann_solver_llf(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of LLF algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code riemann_solver_llf Source Code subroutine riemann_solver_llf ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of LLF algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_llf","tags":"","loc":"proc/riemann_solver_llf.html","title":"riemann_solver_llf – FORESEER"},{"text":"private subroutine riemann_solver_pvl(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of PVL algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code riemann_solver_pvl Source Code subroutine riemann_solver_pvl ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of PVL algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_pvl","tags":"","loc":"proc/riemann_solver_pvl.html","title":"riemann_solver_pvl – FORESEER"},{"text":"private subroutine riemann_solver_roe(self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of Roe algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Source Code riemann_solver_roe Source Code subroutine riemann_solver_roe ( self , eos_left , state_left , eos_right , state_right , normal , fluxes ) !< Riemann Problem solver by means of Roe algorithm. class ( euler_1d ), intent ( in ) :: self !< Euler field. class ( eos_compressible ), intent ( in ) :: eos_left !< Equation of state for left state. class ( conservative_compressible ), intent ( in ) :: state_left !< Left Riemann state. class ( eos_compressible ), intent ( in ) :: eos_right !< Equation of state for right state. class ( conservative_compressible ), intent ( in ) :: state_right !< Right Riemann state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_compressible ), intent ( inout ) :: fluxes !< Fluxes of the Riemann Problem solution. type ( riemann_solver_compressible_roe ) :: riemann_solver !< Riemann solver. call riemann_solver % solve ( eos_left = eos_left , state_left = state_left , & eos_right = eos_right , state_right = state_right , normal = ex , fluxes = fluxes ) endsubroutine riemann_solver_roe","tags":"","loc":"proc/riemann_solver_roe.html","title":"riemann_solver_roe – FORESEER"},{"text":"subroutine initialize(riemann_solver_scheme) Initialize the test. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: riemann_solver_scheme Riemann Problem solver scheme. Called By proc~~initialize~9~~CalledByGraph proc~initialize~9 initialize program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~initialize~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , Ni , Dx , BC_L , BC_R , initial_state , eos , weno_order , weno_variables , riemann_solver_scheme ) !< Initialize field. class ( euler_1d ), intent ( inout ) :: self !< Euler field. integer ( I4P ), intent ( in ) :: Ni !< Space dimension. real ( R8P ), intent ( in ) :: Dx !< Space step. character ( * ), intent ( in ) :: BC_L !< Left boundary condition type. character ( * ), intent ( in ) :: BC_R !< Right boundary condition type. type ( primitive_compressible ), intent ( in ) :: initial_state ( 1 :) !< Initial state of primitive variables. type ( eos_compressible ), intent ( in ) :: eos !< Equation of state. integer ( I4P ), intent ( in ), optional :: weno_order !< WENO reconstruction order. character ( * ), intent ( in ), optional :: weno_variables !< Variables on which WENO reconstruction is done. character ( * ), intent ( in ), optional :: riemann_solver_scheme !< Riemann solver scheme. character (:), allocatable :: weno_variables_ !< WENO Variables, local variable. character (:), allocatable :: riemann_solver_scheme_ !< Riemann solver scheme, local variable. integer ( I4P ) :: i !< Space couner. call self % destroy self % weno_order = 1 ; if ( present ( weno_order )) self % weno_order = weno_order self % Ni = Ni self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = Dx self % eos = eos if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 - self % Ng : self % Ni + self % Ng )) do i = 1 , Ni self % U ( i ) = primitive_to_conservative_compressible ( primitive = initial_state ( i ), eos = eos ) enddo self % BC_L = BC_L self % BC_R = BC_R if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = 'reconstructor-JS' , S = self % Ng , interpolator = self % interpolator ) weno_variables_ = 'characteristic' if ( present ( weno_variables )) weno_variables_ = trim ( adjustl ( weno_variables )) select case ( weno_variables_ ) case ( 'characteristic' ) self % reconstruct_interfaces => reconstruct_interfaces_characteristic case ( 'conservative' ) self % reconstruct_interfaces => reconstruct_interfaces_conservative case ( 'primitive' ) self % reconstruct_interfaces => reconstruct_interfaces_primitive case default write ( stderr , '(A)' ) 'error: WENO reconstruction variables set \"' // weno_variables_ // '\" unknown!' stop endselect riemann_solver_scheme_ = 'llf' if ( present ( riemann_solver_scheme )) riemann_solver_scheme_ = trim ( adjustl ( riemann_solver_scheme )) select case ( riemann_solver_scheme_ ) case ( 'exact' ) self % riemann_solver => riemann_solver_exact case ( 'hllc' ) self % riemann_solver => riemann_solver_hllc case ( 'llf' ) self % riemann_solver => riemann_solver_llf case ( 'pvl' ) self % riemann_solver => riemann_solver_pvl case ( 'roe' ) self % riemann_solver => riemann_solver_roe case default write ( stderr , '(A)' ) 'error: Riemann Solver scheme \"' // riemann_solver_scheme_ // '\" unknown!' stop endselect endsubroutine initialize","tags":"","loc":"proc/initialize~9.html","title":"initialize – FORESEER"},{"text":"subroutine parse_command_line_interface() Parse Command Line Interface (CLI). Arguments None Calls proc~~parse_command_line_interface~~CallsGraph proc~parse_command_line_interface parse_command_line_interface cton cton proc~parse_command_line_interface->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~parse_command_line_interface~~CalledByGraph proc~parse_command_line_interface parse_command_line_interface program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~parse_command_line_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parse_command_line_interface Source Code subroutine parse_command_line_interface () !< Parse Command Line Interface (CLI). type ( command_line_interface ) :: cli !< Command line interface handler. character ( 99 ) :: riemann_solver_scheme !< Riemann Problem solver scheme. integer ( I4P ) :: error !< Error handler. character ( len = :), allocatable :: buffer !< String buffer. call cli % init ( description = 'FORESEER test: shock tube tester, 1D Euler equations' , & examples = [ \"foreseer_test_shock_tube         \" , & \"foreseer_test_shock_tube --tserie\" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '60' ) call cli % add ( switch = '--t-max' , help = 'Maximum integration time' , required = . false ., act = 'store' , def = '0.' ) call cli % add ( switch = '--riemann' , help = 'Riemann Problem solver' , required = . false ., act = 'store' , def = 'all' , & choices = 'all,exact,hllc,llf,pvl,roe' ) call cli % add ( switch = '--s-scheme' , help = 'Space intergation scheme' , required = . false ., act = 'store' , def = 'weno-char-1' , & choices = 'weno-char-1,weno-char-3,weno-char-5,weno-char-7,weno-char-9,weno-char-11,weno-char-13,weno-char-15,weno-char-17,' // & 'weno-cons-1,weno-cons-3,weno-cons-5,weno-cons-7,weno-cons-9,weno-cons-11,weno-cons-13,weno-cons-15,weno-cons-17,' // & 'weno-prim-1,weno-prim-3,weno-prim-5,weno-prim-7,weno-prim-9,weno-prim-11,weno-prim-13,weno-prim-15,weno-prim-17' ) call cli % add ( switch = '--t-scheme' , help = 'Time intergation scheme' , required = . false ., act = 'store' , def = 'tvd-rk-1' , & choices = 'tvd-rk-1,tvd-rk-2,tvd-rk-3,tvd-rk-5' ) call cli % add ( switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.7' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-max' , val = t_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--riemann' , val = riemann_solver_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--s-scheme' , val = s_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-scheme' , val = t_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--cfl' , val = CFL , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop if ( t_max > 0._R8P ) steps_max = 0 buffer = trim ( adjustl ( s_scheme )) select case ( buffer ( 6 : 9 )) case ( 'char' ) weno_variables = 'characteristic' case ( 'cons' ) weno_variables = 'conservative' case ( 'prim' ) weno_variables = 'primitive' endselect weno_order = cton ( buffer ( 11 :), knd = 1_I4P ) select case ( trim ( adjustl ( t_scheme ))) case ( 'tvd-rk-1' ) rk_stages_number = 1 case ( 'tvd-rk-2' ) rk_stages_number = 2 case ( 'tvd-rk-3' ) rk_stages_number = 3 case ( 'tvd-rk-5' ) rk_stages_number = 5 endselect if ( trim ( adjustl ( riemann_solver_scheme )) == 'all' ) then riemann_solver_schemes = [ 'exact' , 'hllc ' , 'llf  ' , 'pvl  ' , 'roe  ' ] else riemann_solver_schemes = [ trim ( adjustl ( riemann_solver_scheme ))] endif endsubroutine parse_command_line_interface","tags":"","loc":"proc/parse_command_line_interface.html","title":"parse_command_line_interface – FORESEER"},{"text":"subroutine save_time_serie(filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R8P), intent(in) :: t Current integration time. Calls proc~~save_time_serie~~CallsGraph proc~save_time_serie save_time_serie str str proc~save_time_serie->str proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~save_time_serie->proc~conservative_to_primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~~CalledByGraph proc~save_time_serie save_time_serie program~foreseer_test_shock_tube foreseer_test_shock_tube program~foreseer_test_shock_tube->proc~save_time_serie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_time_serie Source Code subroutine save_time_serie ( filename , finish , t ) !< Save time-serie results. character ( * ), intent ( in ), optional :: filename !< Output filename. logical , intent ( in ), optional :: finish !< Flag for triggering the file closing. real ( R8P ), intent ( in ) :: t !< Current integration time. integer ( I4P ), save :: tsfile !< File unit for saving time serie results. type ( primitive_compressible ) :: primitive !< Primitive variables. integer ( I4P ) :: i !< Counter. if ( time_serie ) then if ( present ( filename )) then open ( newunit = tsfile , file = filename ) endif write ( tsfile , '(A)' ) 'VARIABLES = \"x\" \"rho\" \"u\" \"p\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni primitive = conservative_to_primitive_compressible ( conservative = domain % U ( i ), eos = domain % eos ) write ( tsfile , '(4' // '(' // FR8P // ',1X))' ) x ( i ), primitive % density , primitive % velocity % x , primitive % pressure enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – FORESEER"},{"text":"Uses: foreseer_compressible_transformations foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_compressible foreseer_eos_object foreseer_primitive_compressible foreseer_primitive_object foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_object module~~foreseer~~UsesGraph module~foreseer foreseer module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object foreseer_conservative_object module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible penf penf penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object vecfor vecfor vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panmoduleforeseerUsesGraph = svgPanZoom('#moduleforeseerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER, FOrtran RiEmann SolvErs EnviRonment. Used By module~~foreseer~~UsedByGraph module~foreseer foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/foreseer.html","title":"foreseer – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_primitive_compressible foreseer_eos_object penf vecfor module~~foreseer_compressible_transformations~~UsesGraph module~foreseer_compressible_transformations foreseer_compressible_transformations penf penf penf->module~foreseer_compressible_transformations module~foreseer_primitive_compressible foreseer_primitive_compressible penf->module~foreseer_primitive_compressible module~foreseer_conservative_compressible foreseer_conservative_compressible penf->module~foreseer_conservative_compressible module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object module~foreseer_primitive_object foreseer_primitive_object penf->module~foreseer_primitive_object module~foreseer_conservative_object foreseer_conservative_object penf->module~foreseer_conservative_object module~foreseer_primitive_compressible->module~foreseer_compressible_transformations vecfor vecfor vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_object vecfor->module~foreseer_conservative_object module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_eos_object->module~foreseer_conservative_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_conservative_compressible module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible var panmoduleforeseer_compressible_transformationsUsesGraph = svgPanZoom('#moduleforeseer_compressible_transformationsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define compressible variables transformations of FORESEER library. Used By module~~foreseer_compressible_transformations~~UsedByGraph module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer foreseer module~foreseer_compressible_transformations->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_compressible_transformationsUsedByGraph = svgPanZoom('#moduleforeseer_compressible_transformationsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions conservative_to_primitive_compressible primitive_to_conservative_compressible Functions public elemental function conservative_to_primitive_compressible (conservative, eos) result(primitive_) Return a primitive_compressible state transforming a given conservative_compressible state. Arguments Type Intent Optional Attributes Name type( conservative_compressible ), intent(in) :: conservative Conservative state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( primitive_compressible ) Primitive state. public elemental function primitive_to_conservative_compressible (primitive, eos) result(conservative_) Return a conservative_compressible state transforming a given primitive_compressible state. Arguments Type Intent Optional Attributes Name type( primitive_compressible ), intent(in) :: primitive Primitive state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( conservative_compressible ) Conservative state.","tags":"","loc":"module/foreseer_compressible_transformations.html","title":"foreseer_compressible_transformations – FORESEER"},{"text":"Uses: iso_fortran_env foreseer_conservative_object foreseer_eos_object penf vecfor module~~foreseer_conservative_compressible~~UsesGraph module~foreseer_conservative_compressible foreseer_conservative_compressible penf penf penf->module~foreseer_conservative_compressible module~foreseer_conservative_object foreseer_conservative_object penf->module~foreseer_conservative_object module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible vecfor vecfor vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract conservative compressible state of a Riemann Problem for FORESEER library. Used By module~~foreseer_conservative_compressible~~UsedByGraph module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer_conservative_compressible->module~foreseer module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_conservative_compressibleUsedByGraph = svgPanZoom('#moduleforeseer_conservative_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces conservative_compressible Derived Types conservative_compressible Functions add array cons_divide_real cons_multiply_cons cons_multiply_real conservative_compressible_instance conservative_compressible_pointer description negative positive pressure real_multiply_cons sub velocity Subroutines compute_fluxes compute_fluxes_from_primitive cons_assign_cons destroy initialize Interfaces public interface conservative_compressible Overload conservative_compressible name with its constructor. private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . Derived Types type, public, extends( conservative_object ) :: conservative_compressible Convervative compressible object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: energy = 0._R8P Energy, rho * E , rho being the density and E the specific energy. type(vector), public :: momentum Momentum, rho * v , rho being the density and v the velocity vector. Constructor Overload conservative_compressible name with its constructor. private elemental function conservative_compressible_instance (density, momentum, energy) Return and instance of conservative_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . procedure, public, pass(self) :: array Return serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . procedure, public, pass(self) :: compute_fluxes Compute conservative fluxes. procedure, public, pass(self) :: compute_fluxes_from_primitive Compute conservative fluxes from primitives at interface. procedure, public, pass(lhs) :: cons_assign_cons Operator = . procedure, public, pass(lhs) :: cons_divide_real Operator cons / real . procedure, public, pass(lhs) :: cons_multiply_cons Operator * . procedure, public, pass(lhs) :: cons_multiply_real Operator cons * real . procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: destroy Destroy conservative. procedure, public, pass(self) :: initialize Initialize conservative. procedure, public, pass(self) :: negative Unary operator - cons . generic, public :: operator(*) => cons_multiply_cons, cons_multiply_real, real_multiply_cons Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => cons_divide_real Overload / . procedure, public, pass(self) :: positive Unary operator + cons . procedure, public, pass(self) :: pressure Return pressure value. procedure, public, pass(rhs) :: real_multiply_cons Operator real * cons . procedure, public, pass(lhs) :: sub Operator - . procedure, public, pass(self) :: velocity Return velocity vector. Functions private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private pure function array (self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. private function cons_divide_real (lhs, rhs) result(operator_result) Operator cons / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_cons (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function cons_multiply_real (lhs, rhs) result(operator_result) Operator cons * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private elemental function conservative_compressible_instance (density, momentum, energy) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: momentum Momentum, rho * v , rho being the density and v the velocity vector. real(kind=R8P), intent(in), optional :: energy Energy, rho * E , rho being the density and E the specific energy. Return Value type( conservative_compressible ) Instance of conservative_compressible . public function conservative_compressible_pointer (to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( conservative_compressible ),\n  pointer Associated pointer. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private function negative (self) result(operator_result) Unary operator - cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + cons . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. private elemental function pressure (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. private function real_multiply_cons (lhs, rhs) result(operator_result) Operator real * cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. private elemental function velocity (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Subroutines private subroutine compute_fluxes (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. private elemental subroutine compute_fluxes_from_primitive (self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. private pure subroutine cons_assign_cons (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. private elemental subroutine destroy (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. private subroutine initialize (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state.","tags":"","loc":"module/foreseer_conservative_compressible.html","title":"foreseer_conservative_compressible – FORESEER"},{"text":"Uses: foreseer_eos_object penf vecfor module~~foreseer_conservative_object~~UsesGraph module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_conservative_object vecfor vecfor vecfor->module~foreseer_conservative_object penf penf penf->module~foreseer_conservative_object penf->module~foreseer_eos_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract conservative state of a Riemann Problem for FORESEER library. Used By module~~foreseer_conservative_object~~UsedByGraph module~foreseer_conservative_object foreseer_conservative_object module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer foreseer module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_riemann_solver_compressible_exact->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible->module~foreseer module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_euler_1d->program~foreseer_test_shock_tube module~foreseer_compressible_transformations->module~foreseer var panmoduleforeseer_conservative_objectUsedByGraph = svgPanZoom('#moduleforeseer_conservative_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces array_interface assignment_interface compute_fluxes_interface cons_operator_real description_interface destroy_interface initialize_interface pressure_interface real_operator_cons symmetric_operator unary_operator velocity_interface Derived Types conservative_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function array_interface (self) result(array_) Return serialized array of conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of conservative. abstract interface Abstract interfaces of deferred methods of conservative_object . private pure subroutine assignment_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine compute_fluxes_interface (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. abstract interface Abstract interfaces of deferred methods of conservative_object . private function cons_operator_real (lhs, rhs) result(operator_result) Operator cons.op.real . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental subroutine destroy_interface (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine initialize_interface (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self Conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function pressure_interface (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. abstract interface Abstract interfaces of deferred methods of conservative_object . private function real_operator_cons (lhs, rhs) result(operator_result) Operator real.op.cons . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private function symmetric_operator (lhs, rhs) result(operator_result) Symmetric operator cons.op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: lhs Left hand side. class( conservative_object ), intent(in) :: rhs Right hand side. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private function unary_operator (self) result(operator_result) Unary operator .op.cons . Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value class( conservative_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function velocity_interface (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Derived Types type, public, abstract :: conservative_object Convervative object class. Type-Bound Procedures procedure(symmetric_operator), public, pass(lhs) :: add Operator + . procedure(array_interface), public, pass(self) :: array Return serialized array of conservative. generic, public :: assignment(=) => cons_assign_cons Overload = . procedure(compute_fluxes_interface), public, pass(self) :: compute_fluxes Compute conservative fluxes. procedure(assignment_interface), public, pass(lhs) :: cons_assign_cons Operator = . procedure(cons_operator_real), public, pass(lhs) :: cons_divide_real Operator cons / real . procedure(symmetric_operator), public, pass(lhs) :: cons_multiply_cons Operator * . procedure(cons_operator_real), public, pass(lhs) :: cons_multiply_real Operator cons * real . procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(destroy_interface), public, pass(self) :: destroy Destroy conservative. procedure(initialize_interface), public, pass(self) :: initialize Initialize conservative. procedure(unary_operator), public, pass(self) :: negative Unary operator - cons . generic, public :: operator(*) => cons_multiply_cons, cons_multiply_real, real_multiply_cons Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => cons_divide_real Overload / . procedure(unary_operator), public, pass(self) :: positive Unary operator + cons . procedure(pressure_interface), public, pass(self) :: pressure Return pressure value. procedure(real_operator_cons), public, pass(rhs) :: real_multiply_cons Operator real * cons . procedure(symmetric_operator), public, pass(lhs) :: sub Operator - . procedure(velocity_interface), public, pass(self) :: velocity Return velocity vector.","tags":"","loc":"module/foreseer_conservative_object.html","title":"foreseer_conservative_object – FORESEER"},{"text":"Uses: iso_fortran_env foreseer_eos_object penf module~~foreseer_eos_compressible~~UsesGraph module~foreseer_eos_compressible foreseer_eos_compressible penf penf penf->module~foreseer_eos_compressible module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_eos_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the equation of state (EOS) of ideal compressible fluid for FORESEER library. Used By module~~foreseer_eos_compressible~~UsedByGraph module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_euler_1d->program~foreseer_test_shock_tube module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_riemann_solver_compressible_exact->module~foreseer var panmoduleforeseer_eos_compressibleUsedByGraph = svgPanZoom('#moduleforeseer_eos_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces eos_compressible Derived Types eos_compressible Functions R cp cv delta density description energy eos_compressible_instance eos_compressible_pointer eta g gm1 gp1 pressure speed_of_sound temperature Subroutines compute_derivate eos_assign_eos Interfaces public interface eos_compressible Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Derived Types type, public, extends( eos_object ) :: eos_compressible Equation of state (EOS) of ideal compressible object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: R_ = 0._R8P Fluid constant R = cp - cv . real(kind=R8P), public :: cp_ = 0._R8P Specific heat at constant pressure cp . real(kind=R8P), public :: cv_ = 0._R8P Specific heat at constant volume cv . real(kind=R8P), public :: delta_ = 0._R8P (gamma - 1) / 2 . real(kind=R8P), public :: eta_ = 0._R8P 2 * gamma / (gamma - 1) . real(kind=R8P), public :: g_ = 0._R8P Specific heats ratio gamma = cp / cv . real(kind=R8P), public :: gm1_ = 0._R8P gamma - 1 . real(kind=R8P), public :: gp1_ = 0._R8P gamma + 1 . Constructor Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) Return and instance of eos_compressible . Type-Bound Procedures procedure, public, pass(self) :: R Return fluid constant R=cp-cv . generic, public :: assignment(=) => eos_assign_eos Overload = . procedure, public, pass(self) :: compute_derivate Compute derivate quantities (from cp and cv ). procedure, public, pass(self) :: cp Return specific heat at constant pressure. procedure, public, pass(self) :: cv Return specific heat at constant volume. procedure, public, pass(self) :: delta Return (gamma - 1) / 2 . procedure, public, pass(self) :: density Return density. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: energy Return specific internal energy. procedure, public, pass(lhs) :: eos_assign_eos Operator = . procedure, public, pass(self) :: eta Return 2 * gamma / (gamma - 1) . procedure, public, pass(self) :: g Return specific heats ratio gamma=cp/cv . procedure, public, pass(self) :: gm1 Return gamma - 1 . procedure, public, pass(self) :: gp1 Return gamma + 1 . procedure, public, pass(self) :: pressure Return pressure. procedure, public, pass(self) :: speed_of_sound Return speed of sound. procedure, public, pass(self) :: temperature Return temperature. Functions private elemental function R (self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. private elemental function cp (self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. private elemental function cv (self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. private elemental function delta (self) result(delta_) Return (gamma - 1) / 2 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) (gamma - 1) / 2 value. private elemental function density (self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function energy (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . public function eos_compressible_pointer (to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( eos_compressible ),\n  pointer Associated pointer. private elemental function eta (self) result(eta_) Return 2 * gamma / (gamma - 1) . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) 2 * gamma / (gamma - 1) value. private elemental function g (self) result(g_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. private elemental function gm1 (self) result(gm1_) Return gamma - 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma - 1 value. private elemental function gp1 (self) result(gp1_) Return gamma + 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma + 1 value. private elemental function pressure (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. private elemental function speed_of_sound (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. private elemental function temperature (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Subroutines private elemental subroutine compute_derivate (self) Compute derivate quantities (from cp and cv ). Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: self Equation of state. private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/foreseer_eos_compressible.html","title":"foreseer_eos_compressible – FORESEER"},{"text":"Uses: penf module~~foreseer_eos_object~~UsesGraph module~foreseer_eos_object foreseer_eos_object penf penf penf->module~foreseer_eos_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract equation of state (EOS) for FORESEER library. Used By module~~foreseer_eos_object~~UsedByGraph module~foreseer_eos_object foreseer_eos_object module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_primitive_object foreseer_primitive_object module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer foreseer module~foreseer_eos_object->module~foreseer module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer module~foreseer_riemann_solver_compressible_exact->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_compressible->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_eos_objectUsedByGraph = svgPanZoom('#moduleforeseer_eos_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces assignment_interface density_interface description_interface energy_interface pressure_interface scalar_interface speed_of_sound_interface temperature_interface Derived Types eos_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of eos_object . private pure subroutine assignment_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function density_interface (self, energy, pressure, speed_of_sound, temperature) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: speed_of_sound Speed of sound value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Density value. abstract interface Abstract interfaces of deferred methods of eos_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function energy_interface (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function pressure_interface (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function scalar_interface (self) result(scalar_) Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function speed_of_sound_interface (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function temperature_interface (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Derived Types type, public, abstract :: eos_object Equation of State (EOS) object class. Type-Bound Procedures procedure(scalar_interface), public, pass(self) :: R Return fluid constant R=cp-cv . generic, public :: assignment(=) => eos_assign_eos Overload = . procedure(scalar_interface), public, pass(self) :: cp Return specific heat at constant pressure. procedure(scalar_interface), public, pass(self) :: cv Return specific heat at constant volume. procedure(scalar_interface), public, pass(self) :: delta Return (gamma - 1) / 2 . procedure(density_interface), public, pass(self) :: density Return density. procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(energy_interface), public, pass(self) :: energy Return specific internal energy. procedure(assignment_interface), public, pass(lhs) :: eos_assign_eos Operator = . procedure(scalar_interface), public, pass(self) :: eta Return 2 * gamma / (gamma - 1) . procedure(scalar_interface), public, pass(self) :: g Return specific heats ratio gamma=cp/cv . procedure(scalar_interface), public, pass(self) :: gm1 Return gamma - 1 . procedure(scalar_interface), public, pass(self) :: gp1 Return gamma + 1 . procedure(pressure_interface), public, pass(self) :: pressure Return pressure. procedure(speed_of_sound_interface), public, pass(self) :: speed_of_sound Return speed of sound. procedure(temperature_interface), public, pass(self) :: temperature Return temperature.","tags":"","loc":"module/foreseer_eos_object.html","title":"foreseer_eos_object – FORESEER"},{"text":"Uses: iso_fortran_env foreseer_primitive_object foreseer_eos_object penf vecfor module~~foreseer_primitive_compressible~~UsesGraph module~foreseer_primitive_compressible foreseer_primitive_compressible penf penf penf->module~foreseer_primitive_compressible module~foreseer_primitive_object foreseer_primitive_object penf->module~foreseer_primitive_object module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible vecfor vecfor vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_primitive_object module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_primitive_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract primitive compressible state of a Riemann Problem for FORESEER library. Used By module~~foreseer_primitive_compressible~~UsedByGraph module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_compressible_transformations->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_primitive_compressibleUsedByGraph = svgPanZoom('#moduleforeseer_primitive_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces primitive_compressible Derived Types primitive_compressible Functions add array description energy left_eigenvectors momentum negative positive prim_divide_real prim_multiply_prim prim_multiply_real primitive_compressible_instance primitive_compressible_pointer real_multiply_prim right_eigenvectors sub Subroutines destroy initialize prim_assign_prim Interfaces public interface primitive_compressible Overload primitive_compressible name with its constructor. private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . Derived Types type, public, extends( primitive_object ) :: primitive_compressible Convervative compressible object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor Overload primitive_compressible name with its constructor. private elemental function primitive_compressible_instance (density, velocity, pressure) Return and instance of primitive_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . procedure, public, pass(self) :: array Return serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: destroy Destroy primitive. procedure, public, pass(self) :: energy Return energy value. procedure, public, pass(self) :: initialize Initialize primitive. procedure, public, pass(self) :: left_eigenvectors Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . procedure, public, pass(self) :: momentum Return momentum vector. procedure, public, pass(self) :: negative Unary operator - prim . generic, public :: operator(*) => prim_multiply_prim, prim_multiply_real, real_multiply_prim Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => prim_divide_real Overload / . procedure, public, pass(self) :: positive Unary operator + prim . procedure, public, pass(lhs) :: prim_assign_prim Operator = . procedure, public, pass(lhs) :: prim_divide_real Operator prim / real . procedure, public, pass(lhs) :: prim_multiply_prim Operator * . procedure, public, pass(lhs) :: prim_multiply_real Operator prim * real . procedure, public, pass(rhs) :: real_multiply_prim Operator real * prim . procedure, public, pass(self) :: right_eigenvectors Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . procedure, public, pass(lhs) :: sub Operator - . Functions private function add (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private pure function array (self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. private pure function left_eigenvectors (self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. private function negative (self) result(operator_result) Unary operator - prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. private function positive (self) result(operator_result) Unary operator + prim . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_divide_real (lhs, rhs) result(operator_result) Operator prim / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_prim (lhs, rhs) result(operator_result) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private function prim_multiply_real (lhs, rhs) result(operator_result) Operator prim * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private elemental function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density, rho . type(vector), intent(in), optional :: velocity Velocity, v . real(kind=R8P), intent(in), optional :: pressure Pressure, p . Return Value type( primitive_compressible ) Instance of primitive_compressible . public function primitive_compressible_pointer (to, error_message) result(pointer_) Return primitive_compressible pointer associated to primitive_object or its extensions until primitive_compressible included. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( primitive_compressible ),\n  pointer Associated pointer. private function real_multiply_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. private pure function right_eigenvectors (self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. private function sub (lhs, rhs) result(operator_result) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. Subroutines private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. private pure subroutine prim_assign_prim (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/foreseer_primitive_compressible.html","title":"foreseer_primitive_compressible – FORESEER"},{"text":"Uses: foreseer_eos_object penf vecfor module~~foreseer_primitive_object~~UsesGraph module~foreseer_primitive_object foreseer_primitive_object module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_primitive_object vecfor vecfor vecfor->module~foreseer_primitive_object penf penf penf->module~foreseer_primitive_object penf->module~foreseer_eos_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract primitive state of a Riemann Problem for FORESEER library. Used By module~~foreseer_primitive_object~~UsedByGraph module~foreseer_primitive_object foreseer_primitive_object module~foreseer_primitive_compressible foreseer_primitive_compressible module~foreseer_primitive_object->module~foreseer_primitive_compressible module~foreseer foreseer module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_compressible_transformations foreseer_compressible_transformations module~foreseer_primitive_compressible->module~foreseer_compressible_transformations program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_compressible_transformations->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_primitive_objectUsedByGraph = svgPanZoom('#moduleforeseer_primitive_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces array_interface assignment_interface description_interface destroy_interface energy_interface initialize_interface momentum_interface prim_operator_real real_operator_prim symmetric_operator unary_operator Derived Types primitive_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function array_interface (self) result(array_) Return serialized array of primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of primitive. abstract interface Abstract interfaces of deferred methods of primitive_object . private pure subroutine assignment_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of primitive_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental subroutine destroy_interface (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function energy_interface (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. abstract interface Abstract interfaces of deferred methods of primitive_object . private subroutine initialize_interface (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function momentum_interface (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. abstract interface Abstract interfaces of deferred methods of primitive_object . private function prim_operator_real (lhs, rhs) result(operator_result) Operator prim.op.real . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of primitive_object . private function real_operator_prim (lhs, rhs) result(operator_result) Operator real * prim . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of primitive_object . private function symmetric_operator (lhs, rhs) result(operator_result) Symmetric operator prim.op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: lhs Left hand side. class( primitive_object ), intent(in) :: rhs Right hand side. Return Value class( primitive_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of primitive_object . private function unary_operator (self) result(operator_result) Unary operator .op.prim . Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value class( primitive_object ),\n  allocatable Operator result. Derived Types type, public, abstract :: primitive_object Convervative object class. Type-Bound Procedures procedure(symmetric_operator), public, pass(lhs) :: add Operator + . procedure(array_interface), public, pass(self) :: array Return serialized array of primitive. generic, public :: assignment(=) => prim_assign_prim Overload = . procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(destroy_interface), public, pass(self) :: destroy Destroy primitive. procedure(energy_interface), public, pass(self) :: energy Return energy value. procedure(initialize_interface), public, pass(self) :: initialize Initialize primitive. procedure(momentum_interface), public, pass(self) :: momentum Return momentum vector. procedure(unary_operator), public, pass(self) :: negative Unary operator - prim . generic, public :: operator(*) => prim_multiply_prim, prim_multiply_real, real_multiply_prim Overload * . generic, public :: operator(+) => add, positive Overload + . generic, public :: operator(-) => sub, negative Overload - . generic, public :: operator(/) => prim_divide_real Overload / . procedure(unary_operator), public, pass(self) :: positive Unary operator + prim . procedure(assignment_interface), public, pass(lhs) :: prim_assign_prim Operator = . procedure(prim_operator_real), public, pass(lhs) :: prim_divide_real Operator prim / real . procedure(symmetric_operator), public, pass(lhs) :: prim_multiply_prim Operator * . procedure(prim_operator_real), public, pass(lhs) :: prim_multiply_real Operator prim * real . procedure(real_operator_prim), public, pass(rhs) :: real_multiply_prim Operator real * prim . procedure(symmetric_operator), public, pass(lhs) :: sub Operator - .","tags":"","loc":"module/foreseer_primitive_object.html","title":"foreseer_primitive_object – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_object foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_exact~~UsesGraph module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_compressible penf penf penf->module~foreseer_riemann_solver_compressible_exact penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_object module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_eos_compressible var panmoduleforeseer_riemann_solver_compressible_exactUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_exactUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the exact (Newton-iterative) Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_compressible_exact~~UsedByGraph module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer foreseer module~foreseer_riemann_solver_compressible_exact->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_exactUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_exactUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types riemann_solver_compressible_exact Subroutines compute_waves initialize solve Derived Types type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_exact Exact (Newton-iterative) Riemann Solver. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. real(kind=R8P), public :: tolerance = 1.e-10_R8P Tolerance on Newton convergence. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . procedure, public, pass(self) :: compute_waves Compute waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure, public, pass(self) :: solve Solve Riemann Problem. Subroutines private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. private pure subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_exact ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_riemann_solver_compressible_exact.html","title":"foreseer_riemann_solver_compressible_exact – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_object foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_hllc~~UsesGraph module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_compressible penf penf penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_object module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_eos_compressible var panmoduleforeseer_riemann_solver_compressible_hllcUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_hllcUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the HLLC Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_compressible_hllc~~UsedByGraph module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_hllcUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_hllcUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types riemann_solver_compressible_hllc Subroutines compute_waves initialize solve Derived Types type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_hllc HLLC (Harten, Lax, Van Leer, Toro) Riemann Solver. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . procedure, public, pass(self) :: compute_waves Compute waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure, public, pass(self) :: solve Solve Riemann Problem. Subroutines private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_hllc ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_riemann_solver_compressible_hllc.html","title":"foreseer_riemann_solver_compressible_hllc – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_object foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_llf~~UsesGraph module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_compressible penf penf penf->module~foreseer_riemann_solver_compressible_llf penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_object module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_eos_compressible var panmoduleforeseer_riemann_solver_compressible_llfUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_llfUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the Local Lax-Friedrichs (known also as Rusanov) Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_compressible_llf~~UsedByGraph module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_llfUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_llfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types riemann_solver_compressible_llf Subroutines compute_waves initialize solve Derived Types type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_llf Local Lax-Friedrichs (known also as Rusanov) Riemann Solver. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . procedure, public, pass(self) :: compute_waves Compute waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure, public, pass(self) :: solve Solve Riemann Problem. Subroutines private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_llf ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_riemann_solver_compressible_llf.html","title":"foreseer_riemann_solver_compressible_llf – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_compressible foreseer_eos_object foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_object~~UsesGraph module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible penf penf penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_object penf->module~foreseer_eos_compressible penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panmoduleforeseer_riemann_solver_compressible_objectUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the Riemann solver for ideal compressible fluid for FORESEER library. Used By module~~foreseer_riemann_solver_compressible_object~~UsedByGraph module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_objectUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types riemann_solver_compressible_object Functions description Subroutines compute_fluxes compute_post_rarefaction compute_post_shock compute_states23_from_u23 set_states14 Derived Types type, public, abstract, extends( riemann_solver_object ) :: riemann_solver_compressible_object Riemann solver for ideal compressible fluid object class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . procedure(compute_waves_interface), public, pass(self) :: compute_waves Compute waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. procedure(initialize_interface), public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure(solve_interface), public, pass(self) :: solve Solve Riemann Problem. Functions private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private elemental subroutine compute_fluxes (self, eos_left, eos_right, normal, fluxes) Compute fluxes at interface x=xo . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(in) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes at interface x=xo . private elemental subroutine compute_post_rarefaction (eos, sgn, u0, p0, a0, ux, rx, px, ax, s0, sx) Compute an unknown state x from a known state 0 when the two states are separated by a rarefaction, given the velocity ux . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: sgn Sign for distinguishing left (-1) from right (1) wave. real(kind=R8P), intent(in) :: u0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: p0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: a0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: ux Known speed of unknown state. real(kind=R8P), intent(out) :: rx Unknown pressure and density. real(kind=R8P), intent(out) :: px Unknown pressure and density. real(kind=R8P), intent(out) :: ax Unknown pressure and density. real(kind=R8P), intent(out) :: s0 Wave speeds (head and back fronts). real(kind=R8P), intent(out) :: sx Wave speeds (head and back fronts). private elemental subroutine compute_post_shock (eos, sgn, u0, p0, a0, ux, rx, px, ax, ss) Computing an unknown state x from a known state 0 when the two states are separated by a shock, given the velocity ux . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: sgn Sign for distinguishing left (-1) from right (1) wave. real(kind=R8P), intent(in) :: u0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: p0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: a0 Known state (speed, pressure and speed of sound). real(kind=R8P), intent(in) :: ux Unknown speed. real(kind=R8P), intent(out) :: rx Unknown state (density, pressure and speed of sound). real(kind=R8P), intent(out) :: px Unknown state (density, pressure and speed of sound). real(kind=R8P), intent(out) :: ax Unknown state (density, pressure and speed of sound). real(kind=R8P), intent(out) :: ss Shock wave speed. private elemental subroutine compute_states23_from_u23 (self, p_2, p_3) Compute interstates 2 and 3 given (an approximation of) veloctiy S=u23 . Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. real(kind=R8P), intent(out) :: p_2 Pressure of state 2. real(kind=R8P), intent(out) :: p_3 Pressure of state 3. private elemental subroutine set_states14 (self, eos_left, state_left, eos_right, state_right, normal) Set states 1 and 4. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given.","tags":"","loc":"module/foreseer_riemann_solver_compressible_object.html","title":"foreseer_riemann_solver_compressible_object – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_object foreseer_riemann_solver_compressible_object foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_pvl~~UsesGraph module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_compressible module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_eos_compressible penf penf penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_eos_compressible module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_conservative_compressible iso_fortran_env->module~foreseer_eos_compressible var panmoduleforeseer_riemann_solver_compressible_pvlUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_pvlUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the Primitive Variables Linearization based Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_compressible_pvl~~UsedByGraph module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_pvlUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_pvlUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_waves_interface solve_interface Derived Types riemann_solver_compressible_pvl Subroutines compute_u23 compute_up23 compute_waves compute_waves_u23 compute_waves_up23 initialize solve solve_u23 solve_up23 Abstract Interfaces abstract interface private pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. abstract interface private pure subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Derived Types type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_pvl Primitive Variables Linearization based Riemann solver. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. procedure( compute_waves_interface ), public, pointer :: compute_waves_ => compute_waves_up23 Compute waves pattern type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. procedure( solve_interface ), public, pointer :: solve_ => solve_up23 Solve Riemann problem. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . procedure, private, pass(self) :: compute_u23 Compute interstates velocity. procedure, private, pass(self) :: compute_up23 Compute interstates velocity and pressure. procedure, public, pass(self) :: compute_waves Compute waves pattern. procedure, private, pass(self) :: compute_waves_u23 Compute waves speed by u23 algorithm. procedure, private, pass(self) :: compute_waves_up23 Compute waves speed by up23 algorithm. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure, public, pass(self) :: solve Solve Riemann Problem. procedure, private, pass(self) :: solve_u23 Compute whole pattern by u23 algorithm. procedure, private, pass(self) :: solve_up23 Compute whole pattern by up23 algorithm. Subroutines private elemental subroutine compute_u23 (self) Compute interstates velocity. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. private elemental subroutine compute_up23 (self) Compute interstates velocity and pressure. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private pure subroutine compute_waves_u23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private pure subroutine compute_waves_up23 (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves speed u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. private pure subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private pure subroutine solve_u23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem by u23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private pure subroutine solve_up23 (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann problem up23 algorithm. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_pvl ), intent(inout) :: self Riemann pattern. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_riemann_solver_compressible_pvl.html","title":"foreseer_riemann_solver_compressible_pvl – FORESEER"},{"text":"Uses: foreseer_conservative_compressible foreseer_conservative_object foreseer_eos_compressible foreseer_eos_object foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_object penf vecfor module~~foreseer_riemann_solver_compressible_roe~~UsesGraph module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_compressible foreseer_conservative_compressible module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_compressible foreseer_eos_compressible module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object penf penf penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_object penf->module~foreseer_eos_compressible module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl vecfor vecfor vecfor->module~foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panmoduleforeseer_riemann_solver_compressible_roeUsesGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_roeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the Roe (with the Harten-Hyman entropy fix) Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_compressible_roe~~UsedByGraph module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_compressible_roeUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_compressible_roeUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types riemann_solver_compressible_roe Subroutines compute_roe_state compute_waves initialize solve Derived Types type, public, extends( riemann_solver_compressible_object ) :: riemann_solver_compressible_roe Roe (with the Harten-Hyman entropy fix) Riemann Solver. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: a_1 = 0._R8P Speed of sound of state 1. real(kind=R8P), public :: a_2 = 0._R8P Speed of sound of state 2. real(kind=R8P), public :: a_3 = 0._R8P Speed of sound of state 3. real(kind=R8P), public :: a_4 = 0._R8P Speed of sound of state 4. type( eos_compressible ), public :: eos_1 Equation of state 1. type( eos_compressible ), public :: eos_4 Equation of state 4. real(kind=R8P), public :: p23 = 0._R8P Pressure of intermediate states. real(kind=R8P), public :: p_1 = 0._R8P Pressure of state 1. real(kind=R8P), public :: p_4 = 0._R8P Pressure of state 4. real(kind=R8P), public :: r_1 = 0._R8P Density of state 1. real(kind=R8P), public :: r_2 = 0._R8P Density of state 2. real(kind=R8P), public :: r_3 = 0._R8P Density of state 3. real(kind=R8P), public :: r_4 = 0._R8P Density of state 4. real(kind=R8P), public :: s_1 = 0._R8P Left-front of left wave. real(kind=R8P), public :: s_2 = 0._R8P Right-front of left wave. real(kind=R8P), public :: s_3 = 0._R8P Left-front of right wave. real(kind=R8P), public :: s_4 = 0._R8P Right-front of right wave. type( riemann_solver_compressible_pvl ), public :: solver_pvl PVL Riemann solver. real(kind=R8P), public :: u23 = 0._R8P Velocity (normal) of intermediate states. real(kind=R8P), public :: u_1 = 0._R8P Velocity (normal) of state 1. real(kind=R8P), public :: u_4 = 0._R8P Velocity (normal) of state 4. Type-Bound Procedures procedure, public, pass(self) :: compute_fluxes Compute fluxes at interface x=xo . procedure, public, nopass :: compute_roe_state Compute intermediate state. procedure, public, pass(self) :: compute_states23_from_u23 Compute interstates 2 and 3 given veloctiy S=u23 . procedure, public, pass(self) :: compute_waves Compute waves pattern. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: initialize Initialize solver. procedure, public, pass(self) :: set_states14 Set states 1 and 4. procedure, public, pass(self) :: solve Solve Riemann Problem. Subroutines private subroutine compute_roe_state (eos_left, state_left, eos_right, state_right, r_d, r_u, r_e, r_a) Evaluate the intermediate state from the known states U1,U4 using the Roe linearization. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. real(kind=R8P), intent(out) :: r_d Roe intermediate state density. type(vector), intent(out) :: r_u Roe intermediate state velocity vector.. real(kind=R8P), intent(out) :: r_e Roe intermediate state enthalpy. real(kind=R8P), intent(out) :: r_a Roe intermediate state sound speed. private pure subroutine compute_waves (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. private subroutine initialize (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. private subroutine solve (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_compressible_roe ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_riemann_solver_compressible_roe.html","title":"foreseer_riemann_solver_compressible_roe – FORESEER"},{"text":"Uses: foreseer_conservative_object foreseer_eos_object penf vecfor module~~foreseer_riemann_solver_object~~UsesGraph module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer_eos_object foreseer_eos_object module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object foreseer_conservative_object module~foreseer_eos_object->module~foreseer_conservative_object vecfor vecfor vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_conservative_object module~foreseer_conservative_object->module~foreseer_riemann_solver_object penf penf penf->module~foreseer_riemann_solver_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract Riemann solver of FORESEER library. Used By module~~foreseer_riemann_solver_object~~UsedByGraph module~foreseer_riemann_solver_object foreseer_riemann_solver_object module~foreseer foreseer module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer->program~foreseer_test_compressible_transformations module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer->program~foreseer_test_riemann_solver_compressible_llf program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer->program~foreseer_test_riemann_solver_compressible_roe program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer->program~foreseer_test_conservative_compressible program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer->program~foreseer_test_shock_tube program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer->program~foreseer_test_eos_compressible program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer->program~foreseer_test_primitive_compressible program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_euler_1d->program~foreseer_test_shock_tube var panmoduleforeseer_riemann_solver_objectUsedByGraph = svgPanZoom('#moduleforeseer_riemann_solver_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_waves_interface description_interface initialize_interface solve_interface Derived Types riemann_solver_object Abstract Interfaces abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure subroutine compute_waves_interface (self, eos_left, state_left, eos_right, state_right, normal, waves) Compute waves pattern. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. real(kind=R8P), intent(out) :: waves (1:) Waves pattern. abstract interface Abstract interfaces of riemann_solver_object deferred methods. private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(in) :: self Solver. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine initialize_interface (self, config) Initialize solver. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. character(len=*), intent(in), optional :: config Configuration for solver algorithm. abstract interface Abstract interfaces of riemann_solver_object deferred methods. private subroutine solve_interface (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Solve Riemann Problem. Arguments Type Intent Optional Attributes Name class( riemann_solver_object ), intent(inout) :: self Solver. class( eos_object ), intent(in) :: eos_left Equation of state for left state. class( conservative_object ), intent(in) :: state_left Left Riemann state. class( eos_object ), intent(in) :: eos_right Equation of state for right state. class( conservative_object ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Derived Types type, public, abstract :: riemann_solver_object Abstract Riemann Solver. Type-Bound Procedures procedure(compute_waves_interface), public, pass(self) :: compute_waves Compute waves pattern. procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(initialize_interface), public, pass(self) :: initialize Initialize solver. procedure(solve_interface), public, pass(self) :: solve Solve Riemann Problem.","tags":"","loc":"module/foreseer_riemann_solver_object.html","title":"foreseer_riemann_solver_object – FORESEER"},{"text":"Uses: iso_fortran_env foreseer penf foodie vecfor wenoof module~~foreseer_euler_1d~~UsesGraph module~foreseer_euler_1d foreseer_euler_1d foodie foodie foodie->module~foreseer_euler_1d wenoof wenoof wenoof->module~foreseer_euler_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_euler_1d module~foreseer_primitive_compressible foreseer_primitive_compressible iso_fortran_env->module~foreseer_primitive_compressible module~foreseer_eos_compressible foreseer_eos_compressible iso_fortran_env->module~foreseer_eos_compressible module~foreseer_conservative_compressible foreseer_conservative_compressible iso_fortran_env->module~foreseer_conservative_compressible vecfor vecfor vecfor->module~foreseer_euler_1d module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object module~foreseer foreseer module~foreseer->module~foreseer_euler_1d penf penf penf->module~foreseer_euler_1d penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible var panmoduleforeseer_euler_1dUsesGraph = svgPanZoom('#moduleforeseer_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Definition of Euler 1D class for FORESEER test. Used By module~~foreseer_euler_1d~~UsedByGraph module~foreseer_euler_1d foreseer_euler_1d program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer_euler_1d->program~foreseer_test_shock_tube Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces reconstruct_interfaces_ riemann_solver_ Derived Types euler_1d Functions add_euler compute_dt dEuler_dt euler_local_error euler_multiply_euler euler_multiply_real output real_multiply_euler sub_euler Subroutines destroy euler_assign_euler euler_assign_real impose_boundary_conditions initialize reconstruct_interfaces_characteristic reconstruct_interfaces_conservative reconstruct_interfaces_primitive riemann_solver_exact riemann_solver_hllc riemann_solver_llf riemann_solver_pvl riemann_solver_roe Abstract Interfaces abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine reconstruct_interfaces_ (self, conservative, r_conservative) Reconstruct interface states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative variables. abstract interface Abstract interfaces of euler_1d pointer methods. private subroutine riemann_solver_ (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. Derived Types type, public, extends(integrand) :: euler_1d Euler 1D PDEs system field. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: BC_L Left boundary condition type. character(len=:), public, allocatable :: BC_R Right boundary condition type. real(kind=R8P), public :: Dx = 0._R8P Space step. integer(kind=I4P), public :: Ng = 0 Ghost cells number. integer(kind=I4P), public :: Ni = 0 Space dimension. type( conservative_compressible ), public, allocatable :: U (:) Integrand (state) variables. type( eos_compressible ), public :: eos Equation of state. class(interpolator_object), public, allocatable :: interpolator WENO interpolator. procedure( reconstruct_interfaces_ ), public, pointer :: reconstruct_interfaces => reconstruct_interfaces_characteristic Reconstruct interface states. procedure( riemann_solver_ ), public, pointer :: riemann_solver => riemann_solver_llf Actual Riemann Problem solver. integer(kind=I4P), public :: weno_order = 0 WENO reconstruction order. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Operator + . procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Operator = . procedure, public, pass(lhs) :: assign_real => euler_assign_real Operator euler = real . procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: initialize Initialize field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Operator * . procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Operator euler * real . procedure, public, pass(lhs) :: local_error => euler_local_error Operator ||euler-euler|| . procedure, public, pass(self) :: output Extract Euler field. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Operator real * euler . procedure, private, pass(self) :: reconstruct_interfaces_characteristic Reconstruct (charc.) interface states. procedure, private, pass(self) :: reconstruct_interfaces_conservative Reconstruct (cons.) interface states. procedure, private, pass(self) :: reconstruct_interfaces_primitive Reconstruct (prim.) interface states. procedure, private, pass(self) :: riemann_solver_exact Exact Riemann Problem solver. procedure, private, pass(self) :: riemann_solver_hllc HLLC Riemann Problem solver. procedure, private, pass(self) :: riemann_solver_llf LLF Riemann Problem solver. procedure, private, pass(self) :: riemann_solver_pvl PVL Riemann Problem solver. procedure, private, pass(self) :: riemann_solver_roe Roe Riemann Problem solver. procedure, public, pass(lhs) :: sub => sub_euler Operator - . procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. Functions private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function compute_dt (self, steps_max, t_max, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. integer(kind=I4P), intent(in) :: steps_max Maximun number of time steps. real(kind=R8P), intent(in) :: t_max Maximum integration time. real(kind=R8P), intent(in) :: t Time. real(kind=R8P), intent(in) :: CFL CFL value. Return Value real(kind=R8P) Time step. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. real(kind=R8P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R8P) Error estimation. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function output (self, is_primitive) result(state) Output the Euler field state. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. logical, intent(in), optional :: is_primitive Output in primitive variables. Return Value real(kind=R8P),\n  allocatable, (:,:) Euler state vector. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( euler_1d ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Subroutines private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private pure subroutine impose_boundary_conditions (self, U) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(inout) :: U (1-self%Ng:) Conservative variables. private subroutine initialize (self, Ni, Dx, BC_L, BC_R, initial_state, eos, weno_order, weno_variables, riemann_solver_scheme) Initialize field. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(inout) :: self Euler field. integer(kind=I4P), intent(in) :: Ni Space dimension. real(kind=R8P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. type( primitive_compressible ), intent(in) :: initial_state (1:) Initial state of primitive variables. type( eos_compressible ), intent(in) :: eos Equation of state. integer(kind=I4P), intent(in), optional :: weno_order WENO reconstruction order. character(len=*), intent(in), optional :: weno_variables Variables on which WENO reconstruction is done. character(len=*), intent(in), optional :: riemann_solver_scheme Riemann solver scheme. private subroutine reconstruct_interfaces_characteristic (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. private subroutine reconstruct_interfaces_conservative (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. private subroutine reconstruct_interfaces_primitive (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. type( conservative_compressible ), intent(in) :: conservative (1-self%Ng:) Conservative variables. type( conservative_compressible ), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. private subroutine riemann_solver_exact (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of exact (Newton iterative) algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private subroutine riemann_solver_hllc (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of HLLC algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private subroutine riemann_solver_llf (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of LLF algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private subroutine riemann_solver_pvl (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of PVL algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution. private subroutine riemann_solver_roe (self, eos_left, state_left, eos_right, state_right, normal, fluxes) Riemann Problem solver by means of Roe algorithm. Arguments Type Intent Optional Attributes Name class( euler_1d ), intent(in) :: self Euler field. class( eos_compressible ), intent(in) :: eos_left Equation of state for left state. class( conservative_compressible ), intent(in) :: state_left Left Riemann state. class( eos_compressible ), intent(in) :: eos_right Equation of state for right state. class( conservative_compressible ), intent(in) :: state_right Right Riemann state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_compressible ), intent(inout) :: fluxes Fluxes of the Riemann Problem solution.","tags":"","loc":"module/foreseer_euler_1d.html","title":"foreseer_euler_1d – FORESEER"},{"text":"Uses: foreseer penf program~~foreseer_test_compressible_transformations~~UsesGraph program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations module~foreseer foreseer module~foreseer->program~foreseer_test_compressible_transformations penf penf penf->program~foreseer_test_compressible_transformations module~foreseer_compressible_transformations foreseer_compressible_transformations penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc penf->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible penf->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object penf->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object penf->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object module~foreseer_conservative_compressible foreseer_conservative_compressible penf->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible vecfor vecfor vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_compressible_transformationsUsesGraph = svgPanZoom('#programforeseer_test_compressible_transformationsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: compressible variables transformations test. Calls program~~foreseer_test_compressible_transformations~~CallsGraph program~foreseer_test_compressible_transformations foreseer_test_compressible_transformations proc~conservative_to_primitive_compressible conservative_to_primitive_compressible program~foreseer_test_compressible_transformations->proc~conservative_to_primitive_compressible proc~primitive_to_conservative_compressible primitive_to_conservative_compressible program~foreseer_test_compressible_transformations->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos p u Source Code foreseer_test_compressible_transformations Variables Type Attributes Name Initial logical :: are_tests_passed (2) List of passed tests. type( eos_compressible ) :: eos An equation of state. type( primitive_compressible ) :: p A primitive compressible instance. type( conservative_compressible ) :: u A conservative compressible instance. Source Code program foreseer_test_compressible_transformations !< FORESEER test: compressible variables transformations test. use foreseer , only : eos_compressible , conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( primitive_compressible ) :: p !< A primitive compressible instance. type ( conservative_compressible ) :: u !< A conservative compressible instance. logical :: are_tests_passed ( 2 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) p = conservative_to_primitive_compressible ( conservative = u , eos = eos ) are_tests_passed ( 1 ) = ( p % density >= 1._R8P - ZeroR8 ). and .( p % density <= 1._R8P + ZeroR8 ). and . & ( p % velocity >= 0._R8P - ZeroR8 ). and .( p % velocity <= 0._R8P + ZeroR8 ). and . & ( p % pressure >= 1._R8P - ZeroR8 ). and .( p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u to p, is done right? ' , are_tests_passed ( 1 ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) u = primitive_to_conservative_compressible ( primitive = p , eos = eos ) are_tests_passed ( 2 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 2.5_R8P - ZeroR8 ). and .( u % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'p to u, is done right? ' , are_tests_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_compressible_transformations","tags":"","loc":"program/foreseer_test_compressible_transformations.html","title":"foreseer_test_compressible_transformations – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_conservative_compressible~~UsesGraph program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible module~foreseer foreseer module~foreseer->program~foreseer_test_conservative_compressible vecfor vecfor vecfor->program~foreseer_test_conservative_compressible module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_conservative_compressible penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_conservative_compressibleUsesGraph = svgPanZoom('#programforeseer_test_conservative_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: conservative compressible class test. Calls program~~foreseer_test_conservative_compressible~~CallsGraph program~foreseer_test_conservative_compressible foreseer_test_conservative_compressible proc~conservative_compressible_pointer conservative_compressible_pointer program~foreseer_test_conservative_compressible->proc~conservative_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables another_u are_tests_passed eos f u u_pointer u_serialized velocity Source Code foreseer_test_conservative_compressible Variables Type Attributes Name Initial type( conservative_compressible ) :: another_u Another conservative compressible instance. logical :: are_tests_passed (17) List of passed tests. type( eos_compressible ) :: eos An equation of state. type( conservative_compressible ) :: f Conservative fluxes. type( conservative_compressible ) :: u A conservative compressible instance. type( conservative_compressible ), pointer :: u_pointer A conservative compressible pointer. real(kind=R8P), allocatable :: u_serialized (:) Conservative variable serialized. type(vector) :: velocity Velocity vector. Source Code program foreseer_test_conservative_compressible !< FORESEER test: conservative compressible class test. use foreseer , only : eos_compressible , conservative_compressible , conservative_compressible_pointer use penf , only : R8P , ZeroR8 use vecfor , only : ex , vector implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( conservative_compressible ) :: u !< A conservative compressible instance. type ( conservative_compressible ) :: another_u !< Another conservative compressible instance. type ( conservative_compressible ), pointer :: u_pointer !< A conservative compressible pointer. type ( conservative_compressible ) :: f !< Conservative fluxes. type ( vector ) :: velocity !< Velocity vector. real ( R8P ), allocatable :: u_serialized (:) !< Conservative variable serialized. #ifdef __GFORTRAN__ logical :: are_tests_passed ( 17 ) !< List of passed tests. #else logical :: are_tests_passed ( 9 ) !< List of passed tests. #endif are_tests_passed = . false . call u % initialize are_tests_passed ( 1 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'conservative = 0, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) are_tests_passed ( 2 ) = ( u % pressure ( eos = eos ) >= 1._R8P - ZeroR8 ). and .( u % pressure ( eos = eos ) <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%pressure() = 1, is right? ' , are_tests_passed ( 2 ) velocity = u % velocity () are_tests_passed ( 3 ) = ( u % velocity () >= 0._R8P - ZeroR8 ). and .( u % velocity () <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u%velocity() = 0, is right? ' , are_tests_passed ( 3 ) u_serialized = u % array () are_tests_passed ( 4 ) = ( size ( u_serialized , dim = 1 ) == 5 ). and . & ( u_serialized ( 1 ) == 1._R8P ). and . & ( u_serialized ( 2 ) == 0._R8P ). and . & ( u_serialized ( 3 ) == 0._R8P ). and . & ( u_serialized ( 4 ) == 0._R8P ). and . & ( u_serialized ( 5 ) == 2.5_R8P ) print \"(A,L1)\" , 'u => serialized, is done right? ' , are_tests_passed ( 4 ) call u % destroy are_tests_passed ( 5 ) = ( u % density == 0._R8P ). and . & ( u % momentum == 0._R8P ). and . & ( u % energy == 0._R8P ) print \"(A,L1)\" , 'u destroyed, is right? ' , are_tests_passed ( 5 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) call u % compute_fluxes ( eos = eos , normal = ex , fluxes = f ) are_tests_passed ( 6 ) = ( f % density >= 1._R8P - ZeroR8 ). and .( f % density <= 1._R8P + ZeroR8 ). and . & ( f % momentum >= 1.8_R8P - ZeroR8 ). and .( f % momentum <= 1.8_R8P + ZeroR8 ). and . & ( f % energy >= 3.3_R8P - ZeroR8 ). and .( f % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'compute fluxes along X, is done right? ' , are_tests_passed ( 6 ) u = f are_tests_passed ( 7 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 1.8_R8P - ZeroR8 ). and .( u % momentum <= 1.8_R8P + ZeroR8 ). and . & ( u % energy >= 3.3_R8P - ZeroR8 ). and .( u % energy <= 3.3_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = f, is done right? ' , are_tests_passed ( 7 ) u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u_pointer => conservative_compressible_pointer ( to = u ) are_tests_passed ( 8 ) = ( u_pointer % density >= 1._R8P - ZeroR8 ). and .( u_pointer % density <= 1._R8P + ZeroR8 ). and . & ( u_pointer % momentum >= 1._R8P - ZeroR8 ). and .( u_pointer % momentum <= 1._R8P + ZeroR8 ). and . & ( u_pointer % energy >= 2.5_R8P - ZeroR8 ). and .( u_pointer % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u => u, is done right? ' , are_tests_passed ( 8 ) call another_u % initialize ( initial_state = u ) are_tests_passed ( 9 ) = ( another_u % density >= 1._R8P - ZeroR8 ). and .( another_u % density <= 1._R8P + ZeroR8 ). and . & ( another_u % momentum >= 1._R8P - ZeroR8 ). and .( another_u % momentum <= 1._R8P + ZeroR8 ). and . & ( another_u % energy >= 2.5_R8P - ZeroR8 ). and .( another_u % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'antoher_u == u, is right? ' , are_tests_passed ( 9 ) #ifdef __GFORTRAN__ u = conservative_compressible ( density = 1._R8P , momentum = ex , energy = 2.5_R8P ) u = 2._R8P * u are_tests_passed ( 10 ) = ( u % density >= 2._R8P - ZeroR8 ). and .( u % density <= 2._R8P + ZeroR8 ). and . & ( u % momentum >= 2._R8P - ZeroR8 ). and .( u % momentum <= 2._R8P + ZeroR8 ). and . & ( u % energy >= 5._R8P - ZeroR8 ). and .( u % energy <= 5._R8P + ZeroR8 ) print \"(A,L1)\" , '2 * u, is done right? ' , are_tests_passed ( 10 ) u = u * u are_tests_passed ( 11 ) = ( u % density >= 4._R8P - ZeroR8 ). and .( u % density <= 4._R8P + ZeroR8 ). and . & ( u % momentum >= 4._R8P - ZeroR8 ). and .( u % momentum <= 4._R8P + ZeroR8 ). and . & ( u % energy >= 2 5._R8P - ZeroR8 ). and .( u % energy <= 2 5._R8P + ZeroR8 ) print \"(A,L1)\" , 'u * u, is done right? ' , are_tests_passed ( 11 ) u = u + u are_tests_passed ( 12 ) = ( u % density >= 8._R8P - ZeroR8 ). and .( u % density <= 8._R8P + ZeroR8 ). and . & ( u % momentum >= 8._R8P - ZeroR8 ). and .( u % momentum <= 8._R8P + ZeroR8 ). and . & ( u % energy >= 5 0._R8P - ZeroR8 ). and .( u % energy <= 5 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u + u, is done right? ' , are_tests_passed ( 12 ) u = u - u are_tests_passed ( 13 ) = ( u % density >= 0._R8P - ZeroR8 ). and .( u % density <= 0._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 0._R8P - ZeroR8 ). and .( u % energy <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'u - u, is done right? ' , are_tests_passed ( 13 ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) u = - u are_tests_passed ( 14 ) = ( u % density >= - 1._R8P - ZeroR8 ). and .( u % density <= - 1._R8P + ZeroR8 ). and . & ( u % energy >= - 2.5_R8P - ZeroR8 ). and .( u % energy <= - 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = - u, is done right? ' , are_tests_passed ( 14 ) u = + u are_tests_passed ( 15 ) = ( u % density >= - 1._R8P - ZeroR8 ). and .( u % density <= - 1._R8P + ZeroR8 ). and . & ( u % energy >= - 2.5_R8P - ZeroR8 ). and .( u % energy <= - 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u = + u, is done right? ' , are_tests_passed ( 15 ) u = u * 2._R8P are_tests_passed ( 16 ) = ( u % density >= - 2._R8P - ZeroR8 ). and .( u % density <= - 2._R8P + ZeroR8 ). and . & ( u % energy >= - 5._R8P - ZeroR8 ). and .( u % energy <= - 5._R8P + ZeroR8 ) print \"(A,L1)\" , 'u * 2, is done right? ' , are_tests_passed ( 16 ) u = u / 2._R8P are_tests_passed ( 17 ) = ( u % density >= - 1._R8P - ZeroR8 ). and .( u % density <= - 1._R8P + ZeroR8 ). and . & ( u % energy >= - 2.5_R8P - ZeroR8 ). and .( u % energy <= - 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'u / 2, is done right? ' , are_tests_passed ( 17 ) #endif print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_conservative_compressible","tags":"","loc":"program/foreseer_test_conservative_compressible.html","title":"foreseer_test_conservative_compressible – FORESEER"},{"text":"Uses: foreseer penf program~~foreseer_test_eos_compressible~~UsesGraph program~foreseer_test_eos_compressible foreseer_test_eos_compressible module~foreseer foreseer module~foreseer->program~foreseer_test_eos_compressible penf penf penf->program~foreseer_test_eos_compressible module~foreseer_compressible_transformations foreseer_compressible_transformations penf->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc penf->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible penf->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object penf->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object penf->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object module~foreseer_conservative_compressible foreseer_conservative_compressible penf->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible vecfor vecfor vecfor->module~foreseer_compressible_transformations vecfor->module~foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_primitive_compressible vecfor->module~foreseer_riemann_solver_compressible_object vecfor->module~foreseer_conservative_object vecfor->module~foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_conservative_compressible vecfor->module~foreseer_primitive_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_eos_compressibleUsesGraph = svgPanZoom('#programforeseer_test_eos_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: equation of state compressible class test. Variables are_tests_passed eos Source Code foreseer_test_eos_compressible Variables Type Attributes Name Initial logical :: are_tests_passed (14) List of passed tests. type( eos_compressible ) :: eos An equation of state. Source Code program foreseer_test_eos_compressible !< FORESEER test: equation of state compressible class test. use foreseer , only : eos_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. logical :: are_tests_passed ( 14 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) print \"(A)\" , 'EOS description:' print \"(A)\" , eos % description () are_tests_passed ( 1 ) = ( eos % g () >= 1.4_R8P - ZeroR8 ). and .( eos % g () <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%g() = 1.4, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , gam = 1.4_R8P ) are_tests_passed ( 2 ) = ( eos % cv () >= 74 2.86_R8P - ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 2 ) eos = eos_compressible ( cv = 74 2.86_R8P , gam = 1.4_R8P ) are_tests_passed ( 3 ) = ( eos % R () >= 29 7.144_R8P - 1000 * ZeroR8 ). and .( eos % R () <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%R() = 297.144, is right? ' , are_tests_passed ( 3 ) eos = eos_compressible ( cv = 74 2.86_R8P , R = 29 7.144_R8P ) are_tests_passed ( 4 ) = ( eos % cp () >= 104 0.004_R8P - ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 4 ) eos = eos_compressible ( cp = 104 0.004_R8P , R = 29 7.144_R8P ) are_tests_passed ( 5 ) = ( eos % cv () >= 74 2.86_R8P - 1000 * ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 5 ) eos = eos_compressible ( gam = 1.4_R8P , R = 29 7.144_R8P ) are_tests_passed ( 6 ) = ( eos % cp () >= 104 0.004_R8P - 1000 * ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 6 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 7 ) = ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) >= 0.4_R8P - ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) <= 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, energy=1) = 0.4, is right? ' , are_tests_passed ( 7 ) are_tests_passed ( 8 ) = ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) >= 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, temperature=1) = 297.144, is right? ' , are_tests_passed ( 8 ) are_tests_passed ( 9 ) = ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) >= 1._R8P / 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , temperature = 1._R8P ) <= 1._R8P / 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, temperature=1) = 1/297.144, is right? ' , are_tests_passed ( 9 ) are_tests_passed ( 10 ) = ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , energy = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, energy=1) = 1/0.4, is right? ' , are_tests_passed ( 10 ) are_tests_passed ( 11 ) = ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % energy ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(density=1, pressure=1) = 1/0.4, is right? ' , are_tests_passed ( 11 ) are_tests_passed ( 12 ) = ( eos % energy ( temperature = 1._R8P ) >= 74 2.86_R8P - ZeroR8 ). and .& ( eos % energy ( temperature = 1._R8P ) <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%energy(temperature=1) = 742.86, is right? ' , are_tests_passed ( 12 ) are_tests_passed ( 13 ) = ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 29 7.144_R8P - ZeroR8 ). and .& ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 29 7.144_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(density=1, pressure=1) = 1/297.144, is right? ' , are_tests_passed ( 13 ) are_tests_passed ( 14 ) = ( eos % temperature ( energy = 1._R8P ) >= 1._R8P / 74 2.86_R8P - ZeroR8 ). and .& ( eos % temperature ( energy = 1._R8P ) <= 1._R8P / 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(energy=1) = 1/742.86, is right? ' , are_tests_passed ( 14 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_eos_compressible","tags":"","loc":"program/foreseer_test_eos_compressible.html","title":"foreseer_test_eos_compressible – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_primitive_compressible~~UsesGraph program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible module~foreseer foreseer module~foreseer->program~foreseer_test_primitive_compressible vecfor vecfor vecfor->program~foreseer_test_primitive_compressible module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_primitive_compressible penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_primitive_compressibleUsesGraph = svgPanZoom('#programforeseer_test_primitive_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: primitive compressible class test. Calls program~~foreseer_test_primitive_compressible~~CallsGraph program~foreseer_test_primitive_compressible foreseer_test_primitive_compressible proc~primitive_compressible_pointer primitive_compressible_pointer program~foreseer_test_primitive_compressible->proc~primitive_compressible_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables another_p are_tests_passed eos identity l_eigenvectors momentum p p_pointer p_serialized r_eigenvectors Source Code foreseer_test_primitive_compressible Variables Type Attributes Name Initial type( primitive_compressible ) :: another_p A primitive compressible instance. logical :: are_tests_passed (16) List of passed tests. type( eos_compressible ) :: eos An equation of state. real(kind=R8P), allocatable :: identity (:,:) Identity tensor. real(kind=R8P), allocatable :: l_eigenvectors (:,:) Left eigenvectors matrix. type(vector) :: momentum Momentum vector. type( primitive_compressible ) :: p A primitive compressible instance. type( primitive_compressible ), pointer :: p_pointer A primitive compressible pointer. real(kind=R8P), allocatable :: p_serialized (:) Primitive variable serialized. real(kind=R8P), allocatable :: r_eigenvectors (:,:) Right eigenvectors matrix. Source Code program foreseer_test_primitive_compressible !< FORESEER test: primitive compressible class test. use foreseer , only : eos_compressible , primitive_compressible , primitive_compressible_pointer use penf , only : R8P , ZeroR8 use vecfor , only : ex , vector implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( primitive_compressible ) :: p !< A primitive compressible instance. type ( primitive_compressible ) :: another_p !< A primitive compressible instance. type ( primitive_compressible ), pointer :: p_pointer !< A primitive compressible pointer. type ( vector ) :: momentum !< Momentum vector. real ( R8P ), allocatable :: p_serialized (:) !< Primitive variable serialized. real ( R8P ), allocatable :: l_eigenvectors (:,:) !< Left eigenvectors matrix. real ( R8P ), allocatable :: r_eigenvectors (:,:) !< Right eigenvectors matrix. real ( R8P ), allocatable :: identity (:,:) !< Identity tensor. #ifdef __GFORTRAN__ logical :: are_tests_passed ( 16 ) !< List of passed tests. #else logical :: are_tests_passed ( 8 ) !< List of passed tests. #endif are_tests_passed = . false . call p % initialize are_tests_passed ( 1 ) = ( p % density == 0._R8P ). and . & ( p % velocity == 0._R8P ). and . & ( p % pressure == 0._R8P ) print \"(A,L1)\" , 'primitive = 0, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) are_tests_passed ( 2 ) = ( p % energy ( eos = eos ) >= 2.5_R8P - ZeroR8 ). and .( p % energy ( eos = eos ) <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'p%energy() = 2.5, is right? ' , are_tests_passed ( 2 ) momentum = p % momentum () are_tests_passed ( 3 ) = ( p % momentum () >= 0._R8P - ZeroR8 ). and .( p % momentum () <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'p%momentum() = 0, is right? ' , are_tests_passed ( 3 ) p_serialized = p % array () are_tests_passed ( 4 ) = ( size ( p_serialized , dim = 1 ) == 5 ). and . & ( p_serialized ( 1 ) == 1._R8P ). and . & ( p_serialized ( 2 ) == 0._R8P ). and . & ( p_serialized ( 3 ) == 0._R8P ). and . & ( p_serialized ( 4 ) == 0._R8P ). and . & ( p_serialized ( 5 ) == 1._R8P ) print \"(A,L1)\" , 'p => serialized, is done right? ' , are_tests_passed ( 4 ) call p % destroy are_tests_passed ( 5 ) = ( p % density == 0._R8P ). and . & ( p % velocity == 0._R8P ). and . & ( p % pressure == 0._R8P ) print \"(A,L1)\" , 'p destroyed, is right? ' , are_tests_passed ( 5 ) p = primitive_compressible ( density = 1._R8P , velocity = ex , pressure = 1._R8P ) another_p = p are_tests_passed ( 6 ) = ( another_p % density >= 1._R8P - ZeroR8 ). and .( another_p % density <= 1._R8P + ZeroR8 ). and . & ( another_p % velocity >= 1._R8P - ZeroR8 ). and .( another_p % velocity <= 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= 1._R8P - ZeroR8 ). and .( another_p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'another_p = p, is done right? ' , are_tests_passed ( 6 ) p_pointer => primitive_compressible_pointer ( to = p ) are_tests_passed ( 7 ) = ( p_pointer % density >= 1._R8P - ZeroR8 ). and .( p_pointer % density <= 1._R8P + ZeroR8 ). and . & ( p_pointer % velocity >= 1._R8P - ZeroR8 ). and .( p_pointer % velocity <= 1._R8P + ZeroR8 ). and . & ( p_pointer % pressure >= 1._R8P - ZeroR8 ). and .( p_pointer % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'p => p, is done right? ' , are_tests_passed ( 7 ) call another_p % initialize ( initial_state = p ) are_tests_passed ( 8 ) = ( another_p % density >= 1._R8P - ZeroR8 ). and .( another_p % density <= 1._R8P + ZeroR8 ). and . & ( another_p % velocity >= 1._R8P - ZeroR8 ). and .( another_p % velocity <= 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= 1._R8P - ZeroR8 ). and .( another_p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'antoher_p == p, is right? ' , are_tests_passed ( 8 ) #ifdef __GFORTRAN__ p = 2._R8P * p are_tests_passed ( 9 ) = ( p % density >= 2._R8P - ZeroR8 ). and .( p % density <= 2._R8P + ZeroR8 ). and . & ( p % velocity >= 2._R8P - ZeroR8 ). and .( p % velocity <= 2._R8P + ZeroR8 ). and . & ( p % pressure >= 2._R8P - ZeroR8 ). and .( p % pressure <= 2._R8P + ZeroR8 ) print \"(A,L1)\" , '2 * p, is done right? ' , are_tests_passed ( 9 ) p = p * p are_tests_passed ( 10 ) = ( p % density >= 4._R8P - ZeroR8 ). and .( p % density <= 4._R8P + ZeroR8 ). and . & ( p % velocity >= 4._R8P - ZeroR8 ). and .( p % velocity <= 4._R8P + ZeroR8 ). and . & ( p % pressure >= 4._R8P - ZeroR8 ). and .( p % pressure <= 4._R8P + ZeroR8 ) print \"(A,L1)\" , 'p * p, is done right? ' , are_tests_passed ( 10 ) p = p + p are_tests_passed ( 11 ) = ( p % density >= 8._R8P - ZeroR8 ). and .( p % density <= 8._R8P + ZeroR8 ). and . & ( p % velocity >= 8._R8P - ZeroR8 ). and .( p % velocity <= 8._R8P + ZeroR8 ). and . & ( p % pressure >= 8._R8P - ZeroR8 ). and .( p % pressure <= 8._R8P + ZeroR8 ) print \"(A,L1)\" , 'p + p, is done right? ' , are_tests_passed ( 11 ) p = p - p are_tests_passed ( 12 ) = ( p % density >= 0._R8P - ZeroR8 ). and .( p % density <= 0._R8P + ZeroR8 ). and . & ( p % velocity >= 0._R8P - ZeroR8 ). and .( p % velocity <= 0._R8P + ZeroR8 ). and . & ( p % pressure >= 0._R8P - ZeroR8 ). and .( p % pressure <= 0._R8P + ZeroR8 ) print \"(A,L1)\" , 'p - p, is done right? ' , are_tests_passed ( 12 ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) another_p = - p are_tests_passed ( 13 ) = ( another_p % density >= - 1._R8P - ZeroR8 ). and .( another_p % density <= - 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= - 1._R8P - ZeroR8 ). and .( another_p % pressure <= - 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'another_p = - p, is done right? ' , are_tests_passed ( 13 ) another_p = + p are_tests_passed ( 14 ) = ( another_p % density >= 1._R8P - ZeroR8 ). and .( another_p % density <= 1._R8P + ZeroR8 ). and . & ( another_p % pressure >= 1._R8P - ZeroR8 ). and .( another_p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'another_p = + p, is done right? ' , are_tests_passed ( 14 ) p = p * 2._R8P are_tests_passed ( 15 ) = ( p % density >= 2._R8P - ZeroR8 ). and .( p % density <= 2._R8P + ZeroR8 ). and . & ( p % pressure >= 2._R8P - ZeroR8 ). and .( p % pressure <= 2._R8P + ZeroR8 ) print \"(A,L1)\" , 'p * 2, is done right? ' , are_tests_passed ( 15 ) p = p / 2._R8P are_tests_passed ( 16 ) = ( p % density >= 1._R8P - ZeroR8 ). and .( p % density <= 1._R8P + ZeroR8 ). and . & ( p % pressure >= 1._R8P - ZeroR8 ). and .( p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'p / 2, is done right? ' , are_tests_passed ( 16 ) #endif p = primitive_compressible ( density = 1._R8P , velocity = ex , pressure = 1._R8P ) print \"(A)\" , \"Test pretty printing\" print \"(A)\" , p_pointer % description () print \"(A)\" , \"Test eigenvector computing\" l_eigenvectors = p % left_eigenvectors ( eos = eos ) r_eigenvectors = p % right_eigenvectors ( eos = eos ) identity = matmul ( l_eigenvectors , r_eigenvectors ) print \"(A)\" , \"Left\" print \"(3F7.3)\" , l_eigenvectors ( 1 ,:) print \"(3F7.3)\" , l_eigenvectors ( 2 ,:) print \"(3F7.3)\" , l_eigenvectors ( 3 ,:) print \"(A)\" , \"Right\" print \"(3F7.3)\" , r_eigenvectors ( 1 ,:) print \"(3F7.3)\" , r_eigenvectors ( 2 ,:) print \"(3F7.3)\" , r_eigenvectors ( 3 ,:) print \"(A)\" , \"L * R\" print \"(3F7.3)\" , identity ( 1 ,:) print \"(3F7.3)\" , identity ( 2 ,:) print \"(3F7.3)\" , identity ( 3 ,:) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_primitive_compressible","tags":"","loc":"program/foreseer_test_primitive_compressible.html","title":"foreseer_test_primitive_compressible – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_riemann_solver_compressible_hllc~~UsesGraph program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc module~foreseer foreseer module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc vecfor vecfor vecfor->program~foreseer_test_riemann_solver_compressible_hllc module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_riemann_solver_compressible_hllc penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_riemann_solver_compressible_hllcUsesGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_hllcUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: Riemann solver compressible exact (Newton iterative) class test. Calls program~~foreseer_test_riemann_solver_compressible_hllc~~CallsGraph program~foreseer_test_riemann_solver_compressible_hllc foreseer_test_riemann_solver_compressible_hllc str str program~foreseer_test_riemann_solver_compressible_hllc->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos fluxes p23 r_2 r_3 riemann_solver state_left state_right u23 waves Source Code foreseer_test_riemann_solver_compressible_hllc Variables Type Attributes Name Initial logical :: are_tests_passed (1) List of passed tests. type( eos_compressible ) :: eos The equation of state. type( conservative_compressible ) :: fluxes Conservative fluxes. real(kind=R8P), parameter :: p23 = 0.303130000829696655_R8P Exact value of pressure in states 2 and 3. real(kind=R8P), parameter :: r_2 = 0.426319003105163574_R8P Exact value of density in state 2. real(kind=R8P), parameter :: r_3 = 0.265574008226394653_R8P Exact value of density in state 3. type( riemann_solver_compressible_exact ) :: riemann_solver Riemann solver. type( conservative_compressible ) :: state_left Left state. type( conservative_compressible ) :: state_right Right state. real(kind=R8P), parameter :: u23 = 0.927452981472015381_R8P Exact value of velocity in states 2 and 3. real(kind=R8P) :: waves (1:5) Waves pattern. Source Code program foreseer_test_riemann_solver_compressible_hllc !< FORESEER test: Riemann solver compressible exact (Newton iterative) class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_exact use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_exact ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'States pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"10&#94;-15\" tolerance:' call riemann_solver % initialize ( config = '1.e-15' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'States pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_hllc","tags":"","loc":"program/foreseer_test_riemann_solver_compressible_hllc.html","title":"foreseer_test_riemann_solver_compressible_hllc – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_riemann_solver_compressible_hllc~2~~UsesGraph program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc module~foreseer foreseer module~foreseer->program~foreseer_test_riemann_solver_compressible_hllc~2 vecfor vecfor vecfor->program~foreseer_test_riemann_solver_compressible_hllc~2 module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_riemann_solver_compressible_hllc~2 penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_riemann_solver_compressible_hllc2UsesGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_hllc2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: Riemann solver compressible HLLC class test. Calls program~~foreseer_test_riemann_solver_compressible_hllc~2~~CallsGraph program~foreseer_test_riemann_solver_compressible_hllc~2 foreseer_test_riemann_solver_compressible_hllc str str program~foreseer_test_riemann_solver_compressible_hllc~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos fluxes p23 r_2 r_3 riemann_solver state_left state_right u23 waves Source Code foreseer_test_riemann_solver_compressible_hllc Variables Type Attributes Name Initial logical :: are_tests_passed (1) List of passed tests. type( eos_compressible ) :: eos The equation of state. type( conservative_compressible ) :: fluxes Conservative fluxes. real(kind=R8P), parameter :: p23 = 0.303130000829696655_R8P Exact value of pressure in states 2 and 3. real(kind=R8P), parameter :: r_2 = 0.426319003105163574_R8P Exact value of density in state 2. real(kind=R8P), parameter :: r_3 = 0.265574008226394653_R8P Exact value of density in state 3. type( riemann_solver_compressible_hllc ) :: riemann_solver Riemann solver. type( conservative_compressible ) :: state_left Left state. type( conservative_compressible ) :: state_right Right state. real(kind=R8P), parameter :: u23 = 0.927452981472015381_R8P Exact value of velocity in states 2 and 3. real(kind=R8P) :: waves (1:5) Waves pattern. Source Code program foreseer_test_riemann_solver_compressible_hllc !< FORESEER test: Riemann solver compressible HLLC class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_hllc use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_hllc ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_hllc","tags":"","loc":"program/foreseer_test_riemann_solver_compressible_hllc~2.html","title":"foreseer_test_riemann_solver_compressible_hllc – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_riemann_solver_compressible_llf~~UsesGraph program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf module~foreseer foreseer module~foreseer->program~foreseer_test_riemann_solver_compressible_llf vecfor vecfor vecfor->program~foreseer_test_riemann_solver_compressible_llf module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_riemann_solver_compressible_llf penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_riemann_solver_compressible_llfUsesGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_llfUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: Riemann solver compressible LLF class test. Calls program~~foreseer_test_riemann_solver_compressible_llf~~CallsGraph program~foreseer_test_riemann_solver_compressible_llf foreseer_test_riemann_solver_compressible_llf str str program~foreseer_test_riemann_solver_compressible_llf->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos fluxes p23 r_2 r_3 riemann_solver state_left state_right u23 waves Source Code foreseer_test_riemann_solver_compressible_llf Variables Type Attributes Name Initial logical :: are_tests_passed (1) List of passed tests. type( eos_compressible ) :: eos The equation of state. type( conservative_compressible ) :: fluxes Conservative fluxes. real(kind=R8P), parameter :: p23 = 0.303130000829696655_R8P Exact value of pressure in states 2 and 3. real(kind=R8P), parameter :: r_2 = 0.426319003105163574_R8P Exact value of density in state 2. real(kind=R8P), parameter :: r_3 = 0.265574008226394653_R8P Exact value of density in state 3. type( riemann_solver_compressible_llf ) :: riemann_solver Riemann solver. type( conservative_compressible ) :: state_left Left state. type( conservative_compressible ) :: state_right Right state. real(kind=R8P), parameter :: u23 = 0.927452981472015381_R8P Exact value of velocity in states 2 and 3. real(kind=R8P) :: waves (1:5) Waves pattern. Source Code program foreseer_test_riemann_solver_compressible_llf !< FORESEER test: Riemann solver compressible LLF class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_llf use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_llf ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_llf","tags":"","loc":"program/foreseer_test_riemann_solver_compressible_llf.html","title":"foreseer_test_riemann_solver_compressible_llf – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_riemann_solver_compressible_pvl~~UsesGraph program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl module~foreseer foreseer module~foreseer->program~foreseer_test_riemann_solver_compressible_pvl vecfor vecfor vecfor->program~foreseer_test_riemann_solver_compressible_pvl module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_riemann_solver_compressible_pvl penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_riemann_solver_compressible_pvlUsesGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_pvlUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: Riemann solver compressible PVL class test. Calls program~~foreseer_test_riemann_solver_compressible_pvl~~CallsGraph program~foreseer_test_riemann_solver_compressible_pvl foreseer_test_riemann_solver_compressible_pvl str str program~foreseer_test_riemann_solver_compressible_pvl->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos fluxes p23 r_2 r_3 riemann_solver state_left state_right u23 Source Code foreseer_test_riemann_solver_compressible_pvl Variables Type Attributes Name Initial logical :: are_tests_passed (1) List of passed tests. type( eos_compressible ) :: eos The equation of state. type( conservative_compressible ) :: fluxes Conservative fluxes. real(kind=R8P), parameter :: p23 = 0.303130000829696655_R8P Exact value of pressure in states 2 and 3. real(kind=R8P), parameter :: r_2 = 0.426319003105163574_R8P Exact value of density in state 2. real(kind=R8P), parameter :: r_3 = 0.265574008226394653_R8P Exact value of density in state 3. type( riemann_solver_compressible_pvl ) :: riemann_solver Riemann solver. type( conservative_compressible ) :: state_left Left state. type( conservative_compressible ) :: state_right Right state. real(kind=R8P), parameter :: u23 = 0.927452981472015381_R8P Exact value of velocity in states 2 and 3. Source Code program foreseer_test_riemann_solver_compressible_pvl !< FORESEER test: Riemann solver compressible PVL class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_pvl use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_pvl ) :: riemann_solver !< Riemann solver. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Riemann solver internal pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Riemann solver internal pattern:' print '(A)' , riemann_solver % description ( prefix = '  ' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_pvl","tags":"","loc":"program/foreseer_test_riemann_solver_compressible_pvl.html","title":"foreseer_test_riemann_solver_compressible_pvl – FORESEER"},{"text":"Uses: foreseer penf vecfor program~~foreseer_test_riemann_solver_compressible_roe~~UsesGraph program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe module~foreseer foreseer module~foreseer->program~foreseer_test_riemann_solver_compressible_roe vecfor vecfor vecfor->program~foreseer_test_riemann_solver_compressible_roe module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_riemann_solver_compressible_roe penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible var panprogramforeseer_test_riemann_solver_compressible_roeUsesGraph = svgPanZoom('#programforeseer_test_riemann_solver_compressible_roeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: Riemann solver compressible Roe class test. Calls program~~foreseer_test_riemann_solver_compressible_roe~~CallsGraph program~foreseer_test_riemann_solver_compressible_roe foreseer_test_riemann_solver_compressible_roe str str program~foreseer_test_riemann_solver_compressible_roe->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos fluxes p23 r_2 r_3 riemann_solver state_left state_right u23 waves Source Code foreseer_test_riemann_solver_compressible_roe Variables Type Attributes Name Initial logical :: are_tests_passed (1) List of passed tests. type( eos_compressible ) :: eos The equation of state. type( conservative_compressible ) :: fluxes Conservative fluxes. real(kind=R8P), parameter :: p23 = 0.303130000829696655_R8P Exact value of pressure in states 2 and 3. real(kind=R8P), parameter :: r_2 = 0.426319003105163574_R8P Exact value of density in state 2. real(kind=R8P), parameter :: r_3 = 0.265574008226394653_R8P Exact value of density in state 3. type( riemann_solver_compressible_roe ) :: riemann_solver Riemann solver. type( conservative_compressible ) :: state_left Left state. type( conservative_compressible ) :: state_right Right state. real(kind=R8P), parameter :: u23 = 0.927452981472015381_R8P Exact value of velocity in states 2 and 3. real(kind=R8P) :: waves (1:5) Waves pattern. Source Code program foreseer_test_riemann_solver_compressible_roe !< FORESEER test: Riemann solver compressible Roe class test. use foreseer , only : eos_compressible , conservative_compressible , riemann_solver_compressible_roe use penf , only : R8P , str use vecfor , only : ex implicit none type ( eos_compressible ) :: eos !< The equation of state. type ( conservative_compressible ) :: state_left !< Left state. type ( conservative_compressible ) :: state_right !< Right state. type ( conservative_compressible ) :: fluxes !< Conservative fluxes. type ( riemann_solver_compressible_roe ) :: riemann_solver !< Riemann solver. real ( R8P ) :: waves ( 1 : 5 ) !< Waves pattern. real ( R8P ), parameter :: r_2 = 0.426319003105163574_R8P !< Exact value of density in state 2. real ( R8P ), parameter :: r_3 = 0.265574008226394653_R8P !< Exact value of density in state 3. real ( R8P ), parameter :: p23 = 0.303130000829696655_R8P !< Exact value of pressure in states 2 and 3. real ( R8P ), parameter :: u23 = 0.927452981472015381_R8P !< Exact value of velocity in states 2 and 3. logical :: are_tests_passed ( 1 ) !< List of passed tests. are_tests_passed = . true . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) state_left = conservative_compressible ( density = 1._R8P , energy = 1._R8P * eos % energy ( density = 1._R8P , pressure = 1._R8P ) ) state_right = conservative_compressible ( density = 0.125_R8P , energy = 0.125_R8P * eos % energy ( density = 0.125_R8P , pressure = 0.1_R8P )) print '(A)' , 'Test solution with \"u23\" algorithm:' call riemann_solver % initialize ( config = 'u23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) print '(A)' , 'Test solution with \"up23\" algorithm:' call riemann_solver % initialize ( config = 'up23' ) call riemann_solver % solve ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , fluxes = fluxes ) print '(A)' , 'Fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) call fluxes % compute_fluxes_from_primitive ( eos = eos , p = p23 , r = r_2 , u = u23 , normal = ex ) print '(A)' , 'Exact fluxes at interface:' print '(A)' , fluxes % description ( prefix = '  ' ) print '(A)' , 'Exact intemediate states:' print '(A)' , '  r_2 = ' // str ( n = r_2 ) print '(A)' , '  r_3 = ' // str ( n = r_3 ) print '(A)' , '  p23 = ' // str ( n = p23 ) print '(A)' , '  u23 = ' // str ( n = u23 ) call riemann_solver % compute_waves ( eos_left = eos , state_left = state_left , eos_right = eos , state_right = state_right , normal = ex , & waves = waves ) print '(A)' , 'Waves pattern:' print '(A)' , '  S1 = ' // str ( n = waves ( 1 )) print '(A)' , '  S2 = ' // str ( n = waves ( 2 )) print '(A)' , '  S  = ' // str ( n = waves ( 3 )) print '(A)' , '  S3 = ' // str ( n = waves ( 4 )) print '(A)' , '  S4 = ' // str ( n = waves ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram foreseer_test_riemann_solver_compressible_roe","tags":"","loc":"program/foreseer_test_riemann_solver_compressible_roe.html","title":"foreseer_test_riemann_solver_compressible_roe – FORESEER"},{"text":"Uses: flap foodie foreseer foreseer_euler_1d penf vecfor program~~foreseer_test_shock_tube~~UsesGraph program~foreseer_test_shock_tube foreseer_test_shock_tube module~foreseer foreseer module~foreseer->program~foreseer_test_shock_tube module~foreseer_euler_1d foreseer_euler_1d module~foreseer->module~foreseer_euler_1d module~foreseer_euler_1d->program~foreseer_test_shock_tube vecfor vecfor vecfor->program~foreseer_test_shock_tube vecfor->module~foreseer_euler_1d module~foreseer_compressible_transformations foreseer_compressible_transformations vecfor->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_roe foreseer_riemann_solver_compressible_roe vecfor->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_hllc foreseer_riemann_solver_compressible_hllc vecfor->module~foreseer_riemann_solver_compressible_hllc module~foreseer_primitive_compressible foreseer_primitive_compressible vecfor->module~foreseer_primitive_compressible module~foreseer_riemann_solver_compressible_object foreseer_riemann_solver_compressible_object vecfor->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object foreseer_conservative_object vecfor->module~foreseer_conservative_object module~foreseer_riemann_solver_compressible_pvl foreseer_riemann_solver_compressible_pvl vecfor->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object foreseer_riemann_solver_object vecfor->module~foreseer_riemann_solver_object module~foreseer_riemann_solver_compressible_llf foreseer_riemann_solver_compressible_llf vecfor->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_exact foreseer_riemann_solver_compressible_exact vecfor->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_compressible foreseer_conservative_compressible vecfor->module~foreseer_conservative_compressible module~foreseer_primitive_object foreseer_primitive_object vecfor->module~foreseer_primitive_object penf penf penf->program~foreseer_test_shock_tube penf->module~foreseer_euler_1d penf->module~foreseer_compressible_transformations penf->module~foreseer_riemann_solver_compressible_roe penf->module~foreseer_riemann_solver_compressible_hllc penf->module~foreseer_primitive_compressible penf->module~foreseer_riemann_solver_compressible_object penf->module~foreseer_conservative_object penf->module~foreseer_riemann_solver_compressible_pvl penf->module~foreseer_riemann_solver_object penf->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_compressible foreseer_eos_compressible penf->module~foreseer_eos_compressible penf->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object foreseer_eos_object penf->module~foreseer_eos_object penf->module~foreseer_conservative_compressible penf->module~foreseer_primitive_object flap flap flap->program~foreseer_test_shock_tube foodie foodie foodie->program~foreseer_test_shock_tube foodie->module~foreseer_euler_1d module~foreseer_compressible_transformations->module~foreseer module~foreseer_riemann_solver_compressible_roe->module~foreseer module~foreseer_riemann_solver_compressible_hllc->module~foreseer module~foreseer_primitive_compressible->module~foreseer module~foreseer_primitive_compressible->module~foreseer_compressible_transformations module~foreseer_riemann_solver_compressible_object->module~foreseer module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_object->module~foreseer_riemann_solver_object module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_conservative_object->module~foreseer_conservative_compressible module~foreseer_riemann_solver_compressible_pvl->module~foreseer module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_compressible_pvl->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_object->module~foreseer module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_riemann_solver_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_riemann_solver_compressible_llf->module~foreseer module~foreseer_eos_compressible->module~foreseer module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_riemann_solver_compressible_exact->module~foreseer module~foreseer_eos_object->module~foreseer module~foreseer_eos_object->module~foreseer_compressible_transformations module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_roe module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_hllc module~foreseer_eos_object->module~foreseer_primitive_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_object module~foreseer_eos_object->module~foreseer_conservative_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_pvl module~foreseer_eos_object->module~foreseer_riemann_solver_object module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_llf module~foreseer_eos_object->module~foreseer_eos_compressible module~foreseer_eos_object->module~foreseer_riemann_solver_compressible_exact module~foreseer_eos_object->module~foreseer_conservative_compressible module~foreseer_eos_object->module~foreseer_primitive_object module~foreseer_conservative_compressible->module~foreseer module~foreseer_conservative_compressible->module~foreseer_compressible_transformations module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_roe module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_hllc module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_object module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_pvl module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_llf module~foreseer_conservative_compressible->module~foreseer_riemann_solver_compressible_exact module~foreseer_primitive_object->module~foreseer module~foreseer_primitive_object->module~foreseer_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~foreseer_euler_1d iso_fortran_env->module~foreseer_primitive_compressible iso_fortran_env->module~foreseer_eos_compressible iso_fortran_env->module~foreseer_conservative_compressible wenoof wenoof wenoof->module~foreseer_euler_1d var panprogramforeseer_test_shock_tubeUsesGraph = svgPanZoom('#programforeseer_test_shock_tubeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FORESEER test: shock tube tester, 1D Euler equation. Calls program~~foreseer_test_shock_tube~~CallsGraph program~foreseer_test_shock_tube foreseer_test_shock_tube str str program~foreseer_test_shock_tube->str proc~save_time_serie save_time_serie program~foreseer_test_shock_tube->proc~save_time_serie proc~parse_command_line_interface parse_command_line_interface program~foreseer_test_shock_tube->proc~parse_command_line_interface proc~initialize~9 initialize program~foreseer_test_shock_tube->proc~initialize~9 proc~save_time_serie->str proc~conservative_to_primitive_compressible conservative_to_primitive_compressible proc~save_time_serie->proc~conservative_to_primitive_compressible cton cton proc~parse_command_line_interface->cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables BC_L BC_R CFL Dx Ni domain dt results riemann_solver_schemes rk_integrator rk_stage rk_stages_number s s_scheme step steps_max t t_max t_scheme time_serie verbose weno_order weno_variables x Subroutines initialize parse_command_line_interface save_time_serie Source Code foreseer_test_shock_tube Variables Type Attributes Name Initial character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R8P) :: CFL CFL value. real(kind=R8P) :: Dx Space step discretization. integer(kind=I4P) :: Ni Number of grid cells. type( euler_1d ) :: domain Domain of Euler equations. real(kind=R8P) :: dt Time step. logical :: results Flag for activating results saving. character(len=99), allocatable :: riemann_solver_schemes (:) Riemann Problem solver scheme(s). type(tvd_runge_kutta_integrator) :: rk_integrator Runge-Kutta integrator. type( euler_1d ), allocatable :: rk_stage (:) Runge-Kutta stages. integer(kind=I4P) :: rk_stages_number Runge-Kutta stages number. integer(kind=I4P) :: s Schemes counter. character(len=99) :: s_scheme Space integration scheme. integer(kind=I4P) :: step Time steps counter. integer(kind=I4P) :: steps_max Maximum number of time steps. real(kind=R8P) :: t Time. real(kind=R8P) :: t_max Maximum integration time. character(len=99) :: t_scheme Time integration scheme. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I4P) :: weno_order WENO reconstruction order. character(len=:), allocatable :: weno_variables Variables set on which WENO reconstruction is done. real(kind=R8P), allocatable :: x (:) Cell center x-abscissa values. Subroutines subroutine initialize (riemann_solver_scheme) Initialize the test. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: riemann_solver_scheme Riemann Problem solver scheme. subroutine parse_command_line_interface () Parse Command Line Interface (CLI). Arguments None subroutine save_time_serie (filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R8P), intent(in) :: t Current integration time. Source Code program foreseer_test_shock_tube !< FORESEER test: shock tube tester, 1D Euler equation. use flap , only : command_line_interface use foodie , only : tvd_runge_kutta_integrator use foreseer , only : conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible , & eos_compressible use foreseer_euler_1d , only : euler_1d use penf , only : cton , FR8P , I4P , R8P , str use vecfor , only : ex , vector implicit none integer ( I4P ) :: weno_order !< WENO reconstruction order. character ( len = :), allocatable :: weno_variables !< Variables set on which WENO reconstruction is done. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer ( I4P ) :: rk_stages_number !< Runge-Kutta stages number. type ( euler_1d ), allocatable :: rk_stage (:) !< Runge-Kutta stages. real ( R8P ) :: dt !< Time step. real ( R8P ) :: t !< Time. integer ( I4P ) :: step !< Time steps counter. type ( euler_1d ) :: domain !< Domain of Euler equations. real ( R8P ) :: CFL !< CFL value. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I4P ) :: Ni !< Number of grid cells. real ( R8P ) :: Dx !< Space step discretization. real ( R8P ), allocatable :: x (:) !< Cell center x-abscissa values. integer ( I4P ) :: steps_max !< Maximum number of time steps. real ( R8P ) :: t_max !< Maximum integration time. character ( 99 ), allocatable :: riemann_solver_schemes (:) !< Riemann Problem solver scheme(s). character ( 99 ) :: s_scheme !< Space integration scheme. character ( 99 ) :: t_scheme !< Time integration scheme. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I4P ) :: s !< Schemes counter. call parse_command_line_interface do s = 1 , size ( riemann_solver_schemes , dim = 1 ) if ( verbose ) print \"(A)\" , 'Use Riemann Problem solver \"' // trim ( adjustl ( riemann_solver_schemes ( s ))) // '\"' call initialize ( riemann_solver_scheme = riemann_solver_schemes ( s )) call save_time_serie ( filename = 'euler_1D-' // & trim ( adjustl ( s_scheme )) // '-' // & trim ( adjustl ( t_scheme )) // '-' // & trim ( adjustl ( riemann_solver_schemes ( s ))) // '.dat' , t = t ) step = 0 time_loop : do step = step + 1 dt = domain % dt ( steps_max = steps_max , t_max = t_max , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) if ( verbose ) print \"(A)\" , 'step = ' // str ( n = step ) // ', time step = ' // str ( n = dt ) // ', time = ' // str ( n = t ) if (( t == t_max ). or .( step == steps_max )) exit time_loop enddo time_loop enddo contains subroutine initialize ( riemann_solver_scheme ) !< Initialize the test. character ( * ), intent ( in ) :: riemann_solver_scheme !< Riemann Problem solver scheme. type ( primitive_compressible ), allocatable :: initial_state (:) !< Initial state of primitive variables. integer ( I4P ) :: i !< Space counter. if ( allocated ( rk_stage )) deallocate ( rk_stage ) ; allocate ( rk_stage ( 1 : rk_stages_number )) call rk_integrator % init ( stages = rk_stages_number ) t = 0._R8P if ( allocated ( x )) deallocate ( x ) ; allocate ( x ( 1 : Ni )) if ( allocated ( initial_state )) deallocate ( initial_state ) ; allocate ( initial_state ( 1 : Ni )) Dx = 1._R8P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 1._R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 1._R8P enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R8P * Dx initial_state ( i )% density = 0.125_R8P initial_state ( i )% velocity = 0._R8P initial_state ( i )% pressure = 0.1_R8P enddo call domain % initialize ( Ni = Ni , Dx = Dx , & BC_L = BC_L , BC_R = BC_R , & initial_state = initial_state , & eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ), & weno_order = weno_order , & weno_variables = weno_variables , & riemann_solver_scheme = riemann_solver_scheme ) endsubroutine initialize subroutine parse_command_line_interface () !< Parse Command Line Interface (CLI). type ( command_line_interface ) :: cli !< Command line interface handler. character ( 99 ) :: riemann_solver_scheme !< Riemann Problem solver scheme. integer ( I4P ) :: error !< Error handler. character ( len = :), allocatable :: buffer !< String buffer. call cli % init ( description = 'FORESEER test: shock tube tester, 1D Euler equations' , & examples = [ \"foreseer_test_shock_tube         \" , & \"foreseer_test_shock_tube --tserie\" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '60' ) call cli % add ( switch = '--t-max' , help = 'Maximum integration time' , required = . false ., act = 'store' , def = '0.' ) call cli % add ( switch = '--riemann' , help = 'Riemann Problem solver' , required = . false ., act = 'store' , def = 'all' , & choices = 'all,exact,hllc,llf,pvl,roe' ) call cli % add ( switch = '--s-scheme' , help = 'Space intergation scheme' , required = . false ., act = 'store' , def = 'weno-char-1' , & choices = 'weno-char-1,weno-char-3,weno-char-5,weno-char-7,weno-char-9,weno-char-11,weno-char-13,weno-char-15,weno-char-17,' // & 'weno-cons-1,weno-cons-3,weno-cons-5,weno-cons-7,weno-cons-9,weno-cons-11,weno-cons-13,weno-cons-15,weno-cons-17,' // & 'weno-prim-1,weno-prim-3,weno-prim-5,weno-prim-7,weno-prim-9,weno-prim-11,weno-prim-13,weno-prim-15,weno-prim-17' ) call cli % add ( switch = '--t-scheme' , help = 'Time intergation scheme' , required = . false ., act = 'store' , def = 'tvd-rk-1' , & choices = 'tvd-rk-1,tvd-rk-2,tvd-rk-3,tvd-rk-5' ) call cli % add ( switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.7' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-max' , val = t_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--riemann' , val = riemann_solver_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--s-scheme' , val = s_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--t-scheme' , val = t_scheme , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--cfl' , val = CFL , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop if ( t_max > 0._R8P ) steps_max = 0 buffer = trim ( adjustl ( s_scheme )) select case ( buffer ( 6 : 9 )) case ( 'char' ) weno_variables = 'characteristic' case ( 'cons' ) weno_variables = 'conservative' case ( 'prim' ) weno_variables = 'primitive' endselect weno_order = cton ( buffer ( 11 :), knd = 1_I4P ) select case ( trim ( adjustl ( t_scheme ))) case ( 'tvd-rk-1' ) rk_stages_number = 1 case ( 'tvd-rk-2' ) rk_stages_number = 2 case ( 'tvd-rk-3' ) rk_stages_number = 3 case ( 'tvd-rk-5' ) rk_stages_number = 5 endselect if ( trim ( adjustl ( riemann_solver_scheme )) == 'all' ) then riemann_solver_schemes = [ 'exact' , 'hllc ' , 'llf  ' , 'pvl  ' , 'roe  ' ] else riemann_solver_schemes = [ trim ( adjustl ( riemann_solver_scheme ))] endif endsubroutine parse_command_line_interface subroutine save_time_serie ( filename , finish , t ) !< Save time-serie results. character ( * ), intent ( in ), optional :: filename !< Output filename. logical , intent ( in ), optional :: finish !< Flag for triggering the file closing. real ( R8P ), intent ( in ) :: t !< Current integration time. integer ( I4P ), save :: tsfile !< File unit for saving time serie results. type ( primitive_compressible ) :: primitive !< Primitive variables. integer ( I4P ) :: i !< Counter. if ( time_serie ) then if ( present ( filename )) then open ( newunit = tsfile , file = filename ) endif write ( tsfile , '(A)' ) 'VARIABLES = \"x\" \"rho\" \"u\" \"p\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni primitive = conservative_to_primitive_compressible ( conservative = domain % U ( i ), eos = domain % eos ) write ( tsfile , '(4' // '(' // FR8P // ',1X))' ) x ( i ), primitive % density , primitive % velocity % x , primitive % pressure enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif endsubroutine save_time_serie endprogram foreseer_test_shock_tube","tags":"","loc":"program/foreseer_test_shock_tube.html","title":"foreseer_test_shock_tube – FORESEER"}]}